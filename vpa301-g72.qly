#STPBuilderApp
#hide #option _TOOL_TOUCHSCREEN
'*************************************
'Date:   January 8, 2014
'Author: Chris Johnson
'version: VPA 301-G72jan82014
'Added RESTART button to powerup screen
'Modified code relative to Error Handling
'additional changes on error messages and handling
' Jan 09 2014 - change to "Operator Terminal reboot unexpectedly"
' jAN 10 2014 - IF DAQ loop stopped, disable Ignore Error
'Jan 20 2014 - 3 dec pl on eb_Flowr, set min to .002
'****************************************
#option _SS_Lines
#option _SS_Marquee
init gmc_defaultgalilcommv2 := galilcomm

dim currentEB as EditBoxV2
dim currentvalue as string



    dim PowerUp as float
    dim PowerUpDetected as boolean
    init PowerUpDetected := false
    dim SPlast as float
    init SPlast :=0
    dim MLlastA as float
    init MLlastA :=0
    dim MLlastB as float
    init MLlastB :=0
    dim MLdeltaA as float
    init MLdeltaA :=0
    dim MLdeltaB as float
    init MLdeltaB :=0
    dim Timelast$ as string
    init Timelast$ :="time"
    dim MLlastTot as float
    init MLlastTot :=0

    dim SPcur as float
    init SPcur := 0
    dim Vcur as float
    init Vcur := 0
    dim Pzero as float
    init Pzero := 0
    dim MLcurA as float
    dim MLcurB as float
    dim Pcur as float
    dim PcurA as float
    dim PcurB as float
'    dim MLprev as float         'previous volume displaced to add to MLcur to get MLtot
'    init MLprev :=0
    Dim RodDia as float
    init RodDia := 0
    Dim PRange as float
    init PRange := 0
    dim StrokeA as float
    init StrokeA := 0
    dim VolumeA as float
    init VolumeA := 0
    dim VolumeB as float
    init VolumeB := 0
    dim PmpStart as float
    init PmpStart := 0
    dim RcvStart as float
    init RcvStart := 0
    dim LineNo as Integer
    dim MLnew as float
    init MLnew := 0
    dim MLnewAbs as float
    init MLnewAbs :=0
    dim MLnewRel as float
    init MLnewRel :=0
    dim Rate as float
    init Rate := 0
    dim PistML as float
    init PistML := 0
    dim InitBuret as float
    init InitBuret := 0
    dim FinalBuret as float
    init FinalBuret := 0
    dim BurML as float
    init BurML :=0
    dim DeltaML as float
    init DeltaML :=0
    dim RelMLDP as boolean
    init RelMLDP := false
    dim MLaccum as float
    dim MLtot as Float
'    dim MLDisp as float
    dim Time$ as string
    dim Date$ as string
    dim MLposa as float
    dim MLposb as float
    dim MLzero as float

    dim AbsVolMax as float
    dim RelVolMax as float
    dim CalStartML as float
    dim MaxCalFlow as float
    dim CalFlowML as float
    dim InStartPos as boolean
    dim NewML as float
    dim FwdAlrmA as float
    init FwdAlrmA := 20
    dim RevAlrmA as float
    init RevAlrmA :=0
    dim FwdAlrmB as float
    init FwdAlrmB := 20
    dim RevAlrmB as float
    init RevAlrmB :=0
    dim Disabled as boolean
    init Disabled := true
    dim ShowVolts as boolean
    Init ShowVolts := true
    Dim VoltsperPSIA as float
    Dim VoltsperPSIB as float
    Dim Shift as Boolean
    Init Shift := False
    Dim RodSize as Integer
    Dim Pxdcr as Integer
    Dim MLpermmA as float
    Dim MLpermmB as float
    Dim SPnext as float
    Init SPnext := 0
    Dim Ptarget as float
    Init Ptarget := 0
    Dim Prate as float
    Init Prate := 0
    Dim Pratemin as float
    Init Pratemin := 0
    Dim Pinc as float
    Init Pinc := 0
    Dim rampcomplete as boolean
    Init rampcomplete := false
    Dim cyclecomplete as boolean
    Init cyclecomplete := false
    dim PMax as float
    init PMax := 0
    dim PMaxWarn as float
    init PMaxWarn := 0
    dim RevFlowRmax as float
    init RevFlowRmax :=0
    dim FlowRLimWarn as Float
    init FlowRLimWarn := 0
    Dim LastScreen as string
    init LastScreen :="none"

    dim StopTimeSecs as float
    init StopTimeSecs:=0
    dim StartTimeSecs as float
    init StartTimeSecs:=0
    Dim Profile_Seconds as integer
    Init Profile_Seconds :=0
    Dim Segment_Seconds as Integer
    Init Segment_Seconds :=0


    dim HelpIndex as integer
    init HelpIndex := 0

    dim LostDAQ as boolean
    init LostDAQ :=false
    Dim Krefl as float
    init Krefl:=1.0

    Dim P_Cont_On as boolean
    init P_Cont_On:=false
    Dim Full_Scale_volts as float
    Dim Full_Scale_voltsA as float
    Dim Full_Scale_voltsB as float
    Dim Amin as Float
    Dim Amax as Float
    Dim Bmin as Float
    Dim Bmax as Float
    Dim Active_Cyl as string
    Dim VolpCyl as Float
    Dim Ramp_Pending as Boolean
    init Ramp_Pending :=false
    Dim PState as Float
    init PState := 0
    Dim PStatelast as Float
    Dim Transducer as string
    Dim Cylinder as String
    Dim CycleParent as String
    Dim Remote as Float
    Init Remote := 0
    Dim Setup as Boolean
    Init Setup := False
    dim fstate as float
    dim fstatelast as float
    dim Remote_Control as boolean
    Init Remote_Control :=false
    dim Target_Volume as float
    Dim Tar_Vol_Reached as boolean
    init Tar_Vol_Reached := false
    Dim InitComplete as boolean
    init InitComplete :=false
    Dim FlowStopped as boolean
    init FlowStopped := true
    Dim EStop as boolean
    init EStop := false
    dim defaultConfigMsg as string
    init defaultConfigMsg :="Positions are indicated in terms of volume (ml) in the cylinder. Forward is towards full direction. Reverse is towards empty direction."
    dim mlpermin as float
    init mlpermin :=0
    dim mlmax as float
    init mlmax := 0
    dim CurRate as float
    init CurRate :=0
    dim CalMode as boolean
    init CalMode :=false
    dim PrevValue as string
    dim P_Stop_Pressed as boolean
    init P_Stop_Pressed:=false
    dim ValueChanged as boolean
    init ValueChanged:=false
    dim RampHold as boolean
    init RampHold:= false
    dim Refilling as boolean
    init Refilling:=false
    dim RefillingA as boolean
    Init RefillingA:=false
    dim RefillingB as boolean
    Init RefillingB:=false
    dim ReadytoFlowA as boolean
    init ReadytoFlowA:=false
    dim ReadytoFlowB as boolean
    init ReadytoFlowB:=false
    dim CurrentlyRamping as boolean
    init CurrentlyRamping:=false
    dim MaintDateString as string
    Init MaintDateString:=""
    Dim MaintHours as Float
    Init MaintHours:=0
    Dim RunHours as Float
    Init RunHours:=0
    Dim StartTime as Integer
    Dim StopTime as Integer
    Dim FRMax as Float
    Init FRMax:=600
    dim NewErr as Float
    init NewErr :=0
    Dim ErrNo as Integer
    init ErrNo := 0
    Dim ErrorNoArray[5]as integer
    Init ErrorNoArray := [0,0,0,0,0]
    Dim ErrorTime0 as string
    Init ErrorTime0 := "None"
    Dim ErrorTime1 as string
    Init ErrorTime1 := "None"
    Dim ErrorTime2 as string
    Init ErrorTime2 := "None"
    Dim ErrorTime3 as string
    Init ErrorTime3 := "None"
    Dim ErrorTime4 as string
    Init ErrorTime4 := "None"
    Dim ErrorIndex as Integer
    Init ErrorIndex := 0
    dim AlreadyWarned as Boolean
    Init AlreadyWarned :=false
    dim AlreadyWarnedMaxFlow as Boolean
    Init AlreadyWarnedMaxFlow :=false
    dim ErrorDisplayDisabled as boolean
    Init ErrorDisplayDisabled := false
    Dim FloVolA as float
    Init FloVolA := 0
    Dim FlowRA as float
    Init FlowRA :=0
    Dim RefillRA as float
    Init RefillRA :=0
    Dim FloVolB as float
    Init FloVolB := 0
    Dim FlowRB as float
    Init FlowRB :=0
    Dim RefillRB as float
    Init RefillRB :=0
    Dim FlowRLim as float
    Init FlowRLim:=600
    dim MsgNo as Integer
    Init MsgNo :=1
    dim Pumping as Boolean 'set true if controlling in flow or pressure mode
    Init Pumping :=false
    dim ReflRate as Float
    Init ReflRate :=0
    dim InitRate as Float
    Init InitRate :=0
    dim PmpMode as Float
    Init PmpMode :=1
    dim DH as float
    Init DH :=0
    dim Hold_This_Error as boolean
    Init Hold_This_Error :=false
    dim InVopn as boolean
    Init InVopn :=False
    dim Segment_Selected as integer
    Init Segment_Selected :=0
    Dim Current_Segment as integer
    Init Current_Segment := 0
    Dim TarVolArray[7] as Float
    Init TarVolArray:=[0,0,0,0,0,0,0]
    dim SegTimeArray[7] as float
    Init SegTimeArray :=[0,0,0,0,0,0,0]
    dim TarPressArray[7]as float
    Init TarPressArray :=[0,0,0,0,0,0,0]
    dim SegRateArray[7]as float
    Init SegRateArray :=[0,0,0,0,0,0,0]
    dim SegTypeArray[7] as integer
    Init SegTypeArray :=[0,0,0,0,0,0,0]
    dim NumberofSegments as integer
    init NumberofSegments :=0
    dim Profile_Total_Time as float
    Init Profile_Total_Time :=0
    dim Profile_Start_Time as float
    Init Profile_Start_Time :=0
    dim Seg_Start_Time as float
    Init Seg_Start_Time :=0
    dim LastSegment as boolean
    Init LastSegment := false
    dim Next_Segment as Integer
    Init Next_Segment :=0
    dim Profile_Definition_Complete as Boolean
    Init Profile_Definition_Complete:=false
    dim Open_Valves_at_Over_Pressure as Boolean
    Init Open_Valves_at_Over_Pressure:=true
    dim Profile_Stopped as Boolean
    Init Profile_Stopped := false
    dim FlowingA as float
    Init FlowingA :=0
    dim FlowingB as float
    Init FlowingB :=0
    dim Vol_Flowed as float
    Init Vol_Flowed :=0
    dim MLstartCal as float
    Init MLstartCal := 0
    dim CalFlowing as boolean
    Init CalFlowing := false
    dim exitingpscreen as boolean
    init exitingpscreen:=false
    dim RestartRequired as boolean
    Init RestartRequired :=false
    Dim Sim_mode as Boolean
    Init Sim_mode := false
    Dim psi_per_sec as Boolean
    Init psi_per_sec :=true
    Dim flow_limit_disabled as Boolean
    Init flow_limit_disabled :=true
    Dim I_sent_Restart as Boolean
    Init I_sent_Restart:=false
    Dim Exiting_Remote as Boolean
    Init Exiting_Remote:=false
    REM Debug and second port writing variables
    Dim WriteErrorToPortTwo, WarnSpeedComCheck, OverSpeedComCheck, NewErrComCheck, PowerUpComCheck, PcurAComCheck, PcurBComCheck, MLtotComCheck, DAQLoopComCheck as boolean
    init WriteErrorToPortTwo:=false
    Dim CurrentTime as Integer
    Dim CurrentDate as String
    dim debugText as string

Func Write_To_Debug(DebugDesc_ as charstr, DebugSource_ as string)
    REM Function gets date and time and outputs message to the debug screen and to port two if the error port is enabled.
    dim DateAndError as string


    CurrentTime=DateTimeFunctions_Maintenance.GetCurrentTime()
    CurrentDate=DateTimeFunctions_Maintenance.GetDateString("\nMM/dd/yyyy HH:mm:ss ", CurrentTime)
    DateAndError=CurrentDate+" "+DebugSource_+": "+DebugDesc_
    DebugEB.appendText=DateAndError

    if WriteErrorToPortTwo then
        transmit(COM2, DateAndError, false)
    endif

endfunc


Func Start_P_Mode()
    dim strCommand as string
    PStatelast=12
    GMCPoll_PState_Status.enabled=true
    GMCPoll_CurFlow.enabled=true
    valueChanged=false
    'enable alarms
    Disabled = false
    Set_Press_Buttons()

    'send Pready=0
    GMCCommand.command = "Pready=0"
    GMCCommand.executeCommand = true
    'send XQ#STRTPRS
    GMCCommand.command = "XQ#STRTPRS,1"
    GMCCommand.executeCommand = true

    GMCPoll_Pready.enabled=true

    StartTime=DateTimeFunctions_Maintenance.GetCurrentTime()

Endfunc
Func Stop_P_Mode()
    Send_GMCcommand("ReStpP=1")
    P_Cont_On = false
    Pumping=false
    If RampComplete==false then
        hold_press_ramp()
    endif
    Set_Press_Buttons()
    GMCPoll_CurFlow.enabled=false
    lbl_Current_Flow_Rate.value=""
    lbl_P_Act_A.value=""
    lbl_P_Act_B.value=""

'    elps_a_1.bgcolor=160
'    elps_b_1.bgcolor=160
    'disable alarms
    Disabled = True
    StopTime=DateTimeFunctions_Maintenance.GetCurrentTime()
    StopTimeSecs=StopTime
    StartTimeSecs=StartTime
    RunHours = (StopTimeSecs-StartTimeSecs)/3600
    MaintHours=MaintHours+RunHours
    RunHours=0
    lbl_Maint_hrs.value=_FormatFloat(MaintHours,6,2,_FLOAT_NORMAL)
    pv_maintenance.Save()
endfunc
Func Stop_Polling()
    GMCPoll_Ramping.enabled=false
    GMCPoll_Pready.enabled=false
    GMCPoll_Flow_Rate.enabled=false
    GMCPoll_TarVol.enabled=false
    GMCPoll_Target_Press.enabled=false
    GMCPoll_PState_status.enabled=false
    GMCPoll_FState_Cal.enabled=false
    GMCPoll_MLtot.enabled=false
    GMCPoll_MLcurA.enabled=false
    GMCPoll_MLcurB.enabled=false
    GMCPoll_Pcur.enabled=false
    GMCPoll_Finding.enabled=false
    GMCPoll_Flowing.enabled=false

endfunc
Func Startup ()

    handles MSG_INIT
    userDirectMsg(default, _msg_post_init, 0, false)


Endfunc
func Start_Flow()
    dim strCommand as string
    'enable alarms
    valueChanged=false
    Disabled = false
    FlowStopped=false
    Pumping=true
    but_ZeroVol.enabled=false
    But_StartFlow.value="STOP"
    lbl_Flow_Instructions.value="Flow Started"
    'Send FState=1 so skb_Flow_Mode sklist does not get reset immediately
    send_GMCcommand("FState=1")
    'Send XQ#STRTFLO
    send_GMCcommand("XQ#STRTFLO,1")
    StartTime=DateTimeFunctions_Maintenance.GetCurrentTime()


    fstatelast=12
    GMCPoll_Flowing.enabled=true


endfunc
func Stop_Flow()
    GMCCommand.command = "XQ#STPBOTH,1"
    GMCCommand.executeCommand = true
    FlowStopped=True
    Pumping=false
'    lbl_Flow_Instructions.value="Flow Stopped"
'    Set_Flow_Buttons()
    'disable alarms
    Disabled = True
    GMCPoll_CurFlow.enabled=false
    lbl_Current_Flow_Rate.value =""
    StopTime=DateTimeFunctions_Maintenance.GetCurrentTime()
    StopTimeSecs=StopTime
    StartTimeSecs=StartTime
    RunHours = (StopTimeSecs-StartTimeSecs)/3600
    MaintHours=MaintHours+RunHours
    RunHours=0
    lbl_Maint_hrs.value=_FormatFloat(MaintHours,6,2,_FLOAT_NORMAL)
    pv_maintenance.Save()

endfunc

func PostStartup(stat as integer) returns boolean
    handles _msg_post_init
'Take out comments when thru testing - set profile screen enabled=false-set title screen.enabled=true
'set GMCPoll_NewErr.enabled=true, set tmr_InitCfg.enabled true??? see below
'    Init_Title_screen()
    if not Sim_mode then
        tmr_check_connection.enabled=true
'        but_Setup.enabled=true
'        but_FlowMode.enabled=false
'        but_PressureMode.enabled=false
'        tmr_check_connection.enabled=true
    else
        Init_Title_screen()
    endif
    return true
endfunc
func Cancel_PowerUp()
    PowerUp = 0
    PowerUpDetected=false
    GMCCommand.command = "PowerUp=0"
    GMCCommand.executeCommand = true
    tmrPowerUp.enabled=true
endfunc
'func Clear_Error()
'        If ErrorNoArray[ErrorIndex]==11 then
'        GMCCommand.command = "SH"
'        GMCCommand.executeCommand = true
'        AlreadyWarned=false
'        AlreadyWarnedMaxFlow=false
'        Hold_This_Error=false
'        Exit_Error_Popup_Screen()
'        P_Cont_On=false
'        P_Stop_Pressed=false
'        InitComplete=false
 '       CycleComplete=false
'        Close_All()
'        Init_Title_Screen()
'    else
'        AlreadyWarned=false
'        AlreadyWarnedMaxFlow=false
'        Exit_Error_Popup_Screen()
'    endif
'endfunc


func Close_All()
    Cycle_Popup_Screen.enabled=false
    Wait_For_Cycle_screen.enabled=false
    P_Cal_screen.enabled=false
    Fact_Set_Warning_screen.enabled=false
'    DAQ_Warning_screen.enabled=false
'    DP_Warning_screen.enabled=false
'    Cycle_Warning_screen.enabled=false
    Vol_Cal_screen.enabled=false
    Config_screen.enabled=false
    Initialize_screen.enabled=false
    Flow_mode_screen.enabled=false
    Pressure_mode_screen.enabled=false
    Sys_Setup_screen.enabled=false
    Error_Popup_Screen.enabled=false
    Limits_screen.enabled=false
    Power_Up_Screen.enabled=false
    Title_Screen.enabled=false
    Zero_Pressure_Popup_Screen.enabled=false
    error_log_screen.enabled=false
    debugScrn.enabled=false

endfunc
func Clip_String(strIn as string,nochar as integer)returns string
    dim strLen as integer
    dim strTrimmed as String

'Calculate string length
    strLen = len(strIn)
'Separate off last 2 characters
    strTrimmed = left(strIn,strLen-nochar)

    return strTrimmed

endfunc

func Check_PowerUp()
    GMCCom_PowerUp.executeCommand=true
endfunc

func Controller_Communication_Error(strObj as String,strResp as String, FailReasonResp as GMC_FailureReason)
    dim DebugMessage as string
    warning_sound()
    lbl_msg_Title.enabled=true
    lbl_msg_Title.value="Galil Communication Error: " + strObj
    DebugMessage = "Global Function Controller_Communication_Error, FailureReceived response="+strResp+", FailureReceived reason="+str(FailReasonResp)
    Write_To_Debug(lbl_msg_title.value, DebugMessage)
endfunc
func Cycle_To_Start()
    'send "Cycle=1
    GMCCommand.command = "Cycle=1"
    GMCCommand.executeCommand = true
    cyclecomplete=false
    'send "XQ#CYCTOST
    GMCCommand.command = "XQ#CYCTOST,1"
    GMCCommand.executeCommand = true
    Cycle_Popup_Screen.enabled=true
    GMCPoll_Cycle.enabled=true
    lbl_Cycle_Msg_2.value="Cylinders moving to ML Start position"

    set_Flow_Buttons()
    Set_Press_Buttons()
endfunc
func Define_Segment_Parameters(Segment as Integer) 'Segment is the current segment
    if SegTypeArray[Segment]== 1 or SegTypeArray[Segment]== 2 then
        'calculate constant flow parameters mlpermin, mlmax
        mlpermin=SegRateArray[Segment]
        mlmax=2000000000
    endif
    if SegTypeArray[Segment]== 3 then
        'Calculate pressure ramp rate and pressure target Prate,Ptarget
        Prate=SegRateArray[Segment]
        Ptarget=TarPressArray[Segment]
    endif
    if SegTypeArray[Segment]== 4 then
        'Calculate time
    endif
    'set display
    if segment==1 then
        lbl_Profile_Segment_1.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 1 executing"
    endif
    if segment==2 then
        lbl_Profile_Segment_1.bgColor=clr_softkeybarbackground
        lbl_Profile_Segment_2.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 2 executing"
    endif
    if segment==3 then
        lbl_Profile_Segment_2.bgColor=clr_softkeybarbackground
        lbl_Profile_Segment_3.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 3 executing"
    endif
    if segment==4 then
        lbl_Profile_Segment_3.bgColor=clr_softkeybarbackground
        lbl_Profile_Segment_4.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 4 executing"
    endif
    if segment==5 then
        lbl_Profile_Segment_4.bgColor=clr_softkeybarbackground
        lbl_Profile_Segment_5.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 5 executing"
    endif
    if segment==6 then
        lbl_Profile_Segment_5.bgColor=clr_softkeybarbackground
        lbl_Profile_Segment_6.bgColor=clr_buttonbackgroundalt
        lbl_Profile_Msg.value="Segment 6 executing"
    endif
endfunc

func DispKP(obj as EditBoxV2)
    currentEB := obj
    PrevValue=currentEB.value
    currentEB.Value=currentvalue
    currentEB.bgcolor=clr_buttonbackground
    PopupKP.enabled = true
    PopupKP.value=0
    SendToFront(popupkp)
    PopupKP.min = obj.min
    PopupKP.max = obj.max

    if (currenteb==eb_rate_profile_1) then
        if (SegTypeArray[1]==1) or  (SegTypeArray[1]==2) then
            eb_Rate_profile_1.DecimalPlaces=3
        endif
    endif
    if (currenteb==eb_rate_profile_2) then
        if (SegTypeArray[2]==1) or  (SegTypeArray[2]==2) then
            eb_Rate_profile_2.DecimalPlaces=3
        endif
    endif
    if (currenteb==eb_rate_profile_3) then
        if (SegTypeArray[3]==1) or  (SegTypeArray[3]==2) then
            eb_Rate_profile_3.DecimalPlaces=3
        endif
    endif
    if (currenteb==eb_rate_profile_4) then
        if (SegTypeArray[4]==1) or  (SegTypeArray[4]==2) then
            eb_Rate_profile_4.DecimalPlaces=3
        endif
    endif
    if (currenteb==eb_rate_profile_5) then
        if (SegTypeArray[5]==1) or  (SegTypeArray[5]==2) then
            eb_Rate_profile_5.DecimalPlaces=3
        endif
    endif
    if (currenteb==eb_rate_profile_6) then
        if (SegTypeArray[6]==1) or  (SegTypeArray[6]==2) then
            eb_Rate_profile_6.DecimalPlaces=3
        endif
    endif
    PopupKP.MaxAfterDecimal = obj.DecimalPlaces


    If currenteb==eb_flowr then
        eb_flowr.DecimalPlaces=3
        PopupKP.MaxAfterDecimal = 3
    endif
endfunc

func _D(data as string)
'    DebugEB.appendText = data + "\n"
endfunc
func Date_and_Time(newdateTime$ as reference to string)
    dim day as integer
    dim month as integer
    dim year as integer
    dim dotw as weekday
    dim hour as integer
    dim minute as integer
    dim second as integer
    dim strYear as string
    dim strMinute as string
    dim strHour as string
    dim strMonth as string
    dim strDay as string

    gettime(day,month,year,dotw,hour,minute,second)

    If year <10 then
        strYear = "0" + str(year)
    else
        strYear = str(year)
    endif
    If minute<10 then
        strMinute = "0"+str(minute)
    else
        strMinute = str(minute)
    endif
    If hour<10 then
        strHour = "0"+str(hour)
    else
        strHour = str(hour)
    endif
    If day<10 then
        strDay = "0"+str(day)
    else
        strDay = str(day)
    endif
    If month<10 then
        strMonth = "0"+str(month)
    else
        strMonth = str(month)
    endif

    newdateTime$ = strHour + ":" + strMinute + "  " + strDay + " " + strMonth + " "+ strYear

endfunc
func Display_Error_Message_Detected(ErrorNum as Integer)
    If ErrorNum == 0 then
        lbl_Error_Msg.value="No Error Reported"
        Return
    endif
    If ErrorNum == 1 then
        lbl_Error_Msg.value="Cylinder A reached upper limit"
        Return
    endif
    If ErrorNum == 2 then
        lbl_Error_Msg.value="Cylinder A reached lower limit"
        Return
    endif
    If ErrorNum == 3 then
        lbl_Error_Msg.value="Cylinder B reached upper limit"
        Return
    endif
    If ErrorNum == 4 then
        lbl_Error_Msg.value="Cylinder B reached lower limit"
        Return
   endif
     If ErrorNum == 5 then
        lbl_Error_Msg.value="Cylinder A exceeded pressure warning limit."
        Return
    endif
     If ErrorNum == 6 then
        lbl_Error_Msg.value="Cylinder B exceeded pressure warning limit."
        Return
    endif
    If ErrorNum == 7 then
        lbl_Error_Msg.value="Exceeded warning flow rate set for pressure control mode"
        Return
    endif
    If ErrorNum == 8 then
        lbl_Error_Msg.value="Cylinder A exceeded 25% of the cylinder volume (or volume available) in attempting to match pressure in Cylinder B"
        Return
    endif
    If ErrorNum == 9 then
        lbl_Error_Msg.value="Cylinder B exceeded 25% of the cylinder volume (or volume available) in attempting to match pressure in Cylinder A"
        Return
    endif
    If ErrorNum == 10 then
        lbl_Error_Msg.value="Exceeded maximum flow rate set for pressure control mode.  Pump has stopped."
        Return
    endif
    If ErrorNum == 11 then
        lbl_Error_Msg.value="Position error reported by the controller.  Pump has stopped"
        Return
    endif
    If ErrorNum == 12 then
        lbl_Error_Msg.value="Cylinder A reported pressure greater than P Max.  Pump has stopped"
        Return
    endif
    If ErrorNum == 13 then
        lbl_Error_Msg.value="Cylinder B reported pressure greater than P Max. Pump has stopped"
        Return
    endif
    If ErrorNum == 14 then
        lbl_Error_Msg.value="Data acquisition loop stopped. Pump has stopped"
        Return
    endif
    If ErrorNum == 15 then
        lbl_Error_Msg.value="Cylinder B was not ready for transition"
        Return
    endif
    If ErrorNum == 16 then
        lbl_Error_Msg.value="Cylinder A was not ready for transition"
        Return
    endif
    If ErrorNum == 17 then
        lbl_Error_Msg.value="Cylinder A limit switch tripped in Pressure Mode"
        Return
    endif
    If ErrorNum == 18 then
        lbl_Error_Msg.value="Cylinder B limit switch tripped in Pressure Mode"
        Return
    endif
    If ErrorNum == 19 then
        lbl_Error_Msg.value="Limit switch hit while trying to match pressure. Re-Zero transducers or change start position to avoid this error."
        Return
    endif
    If ErrorNum == 20 then
        lbl_Error_Msg.value="Limit switch hit for unknown reasons. Restart and initialize the pump."
        Return
    endif
    If ErrorNum > 99 then
        lbl_Error_Msg.value="Command error reported by the controller"
        Return
    Else
        lbl_Error_Msg.value="Invalid Error Number"
    endif

endfunc
func End_Profile()
    eb_Rate_Profile_1.editType=eb_ReadOnly
    eb_Rate_Profile_2.editType=eb_ReadOnly
    eb_Rate_Profile_3.editType=eb_ReadOnly
    eb_Rate_Profile_4.editType=eb_ReadOnly
    eb_Rate_Profile_5.editType=eb_ReadOnly
    eb_Rate_Profile_6.editType=eb_ReadOnly
    eb_Limit_Profile_1.editType=eb_ReadOnly
    eb_Limit_Profile_2.editType=eb_ReadOnly
    eb_Limit_Profile_3.editType=eb_ReadOnly
    eb_Limit_Profile_4.editType=eb_ReadOnly
    eb_Limit_Profile_5.editType=eb_ReadOnly
    eb_Limit_Profile_6.editType=eb_ReadOnly
    ddl_Profile_1.inactive=true
    ddl_Profile_2.inactive=true
    ddl_Profile_3.inactive=true
    ddl_Profile_4.inactive=true
    ddl_Profile_5.inactive=true
    ddl_Profile_6.inactive=true
    lbl_Profile_Segment_1.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_2.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_3.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_4.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_5.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_6.bgColor=clr_softkeybarbackground

endfunc

func Error_msg()

    If PowerUp == 1 then
        lbl_pressure_msg.value="Power Interupted"
        lbl_msg_Title.value="Controller Restart detected"
    Else
        lbl_pressure_msg.value=""
        lbl_msg_Title.value=""
    EndIf
endfunc

func Exit_Limits_screen()
    Limits_screen.enabled=false
    If LastScreen=="Pressure_mode_screen" then
        Pressure_mode_screen.enabled = true
    endif
    If LastScreen=="Flow_mode_screen" then
        Flow_mode_screen.enabled = true
    endif
    If LastScreen=="Sys_Setup_screen" then
        Sys_Setup_screen.enabled=true
    endif
    If LastScreen=="Profile_screen" then
        Profile_screen.enabled=true
    endif
    AlreadyWarned=false
    AlreadyWarnedMaxFlow=false
endfunc

func Exit_Manual_Control_Screen()
    'If either cylinder is flowing, stop it before exiting

     Manual_Control_screen.enabled = false

    'Disable polling for position and pressure
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
    'gmcpoll_pcur.enabled =true
    'gmcpoll_mltot.enabled=true
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false

    'Reenable the Title Screen with buttons set appropriately
    Init_Title_Screen()
endfunc

func Exit_P_Cal_Screen()
    P_Cal_screen.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
endfunc

func Exit_Power_Up_screen()
    Power_Up_Screen.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    tmr_CheckML.enabled=true
    GMCPoll_NewErr.enabled=true
    GMCPoll_Remote.enabled=false
    P_Cont_On = false
    FlowStopped=true
endfunc
func Exit_Press_Mode_screen()
    exitingpscreen=true
    Stop_P_Mode()
    Set_Press_Buttons()
    pressure_mode_screen.enabled=false
    gmcpoll_Target_Press.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
    gmcpoll_pcur.enabled =false
    gmcpoll_mltot.enabled=false
    eb_Target_Press.value=""
    If Refilling then
        but_PressureMode.enabled=false
        but_FlowMode.enabled=false
        but_Man_Control.enabled=false
        but_ProfileMode.enabled=false
        tmr_Wait_For_Refill.enabled= true
    else
        GMCPoll_PState_Status.enabled=false
    endif
    Init_Title_screen()

endfunc
func Exit_Config_screen()
    Config_Screen.enabled=false
    Init_Setup_screen()
    'Reset anybackground colors that were edited
    eb_start_vol_pump.bgcolor=clr_buttonbackground
    eb_start_receive.bgcolor=clr_buttonbackground
    eb_Amax.bgcolor=clr_buttonbackground
    eb_Amin.bgcolor=clr_buttonbackground
    eb_Bmax.bgcolor=clr_buttonbackground
    eb_Bmin.bgcolor=clr_buttonbackground
    eb_VolPCyl.bgcolor=clr_buttonbackground
    eb_Pmax.bgcolor=clr_buttonbackground
    eb_FillR.bgcolor=clr_buttonbackground

endfunc



func Exit_Initialize_Screen()
    If GMCPoll_Finding.enabled then
        GMCPoll_Finding.enabled=false
        GMCCommand.command = "XQ#STPCYCL,5"
        GMCCommand.executeCommand = true
    endif
    Initialize_screen.enabled=false
    Init_Setup_screen()
endfunc
func Exit_Error_Popup_Screen()

    Error_Popup_Screen.enabled=false
endfunc

func Exit_Flow_Mode_screen()
    gmcpoll_Flow_Rate.enabled=false
    gmcpoll_TarVol.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
    gmcpoll_pcur.enabled =false
    gmcpoll_mltot.enabled=false
    eb_FlowR.Value=""
    eb_tar_vol.Value="INF"
    flow_mode_screen.enabled=false
    Init_Title_screen()
endfunc
func Exit_Profile_Screen()
    Profile_screen.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
    gmcpoll_pcur.enabled =false
    gmcpoll_mltot.enabled=false
    GMCPoll_CurFlow.enabled=false
    tmr_Profile_Times.enabled=false
    tmr_segment.enabled=false
endfunc
func Exit_Segment(segment as integer)
    dim Stoprequired as Boolean
    LastSegment= false
    Stoprequired=true
'decide if we need to end a segment
'This is the last segment
If Current_Segment== NumberofSegments then
        'we are done
    LastSegment= true
    Stoprequired=true
else
    LastSegment= false
    Next_Segment=Current_Segment+1
   'determine if stoprequired before next segment
'this is the first segment, or we are flowing and still flowing, or transitioning from Pramp to P
    If segment==0 then
        Stoprequired=False
    else
        If(( FState>0) and ((SegTypeArray[Next_Segment]==1) or (SegTypeArray[Next_Segment]==2))) then
            Stoprequired=False
        endif
        If PState>0 and (SegTypeArray[Next_Segment]==3 or SegTypeArray[Next_Segment]==4) then
            Stoprequired=False
        endif
    endif
endif


if not Stoprequired then
    Start_Segment(Next_Segment)
else
    If FState>0 then
        Stop_Flow()
        tmr_refill.enabled=true
        IF LastSegment then
            lbl_Profile_Msg.value="Waiting for pump refill to complete"
        endif
    endif
    If PState>0 then
        Stop_P_Mode()
        tmr_refill.enabled=true
        IF LastSegment then
            lbl_Profile_Msg.value="Waiting for pump refill to complete"
        endif
    endif
endif

endfunc
func Exit_Sys_Setup_Screen()
    Sys_Setup_screen.enabled=false
    Init_Title_screen()
endfunc

func Exit_Title_Screen()
    P_Cont_On = false
    Title_Screen.enabled= false
    Send_GMCcommand("Local=1")
    GMCPoll_Remote.enabled=false
    Exiting_Remote=false
endfunc

func Exit_Vol_Cal_screen()
     If GMCPoll_Flowing.enabled then  'stop motion
           Stop_Flow()
        endif
    lbl_ml_per_mm.BlinkPeriod=0
    vol_cal_screen.enabled = false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    gmcpoll_mlcura.enabled=false
    gmcpoll_mlcurb.enabled=false
    Init_Setup_screen()
    lbl_ml_per_mm_calc.BlinkPeriod=0
    CalFlowing=false
endfunc
func Exit_Remote_Display()
    Exiting_Remote=true
    Remote_Display.enabled=false
    Title_screen.enabled=true
    gmcpoll_Target_Press.enabled=false
    gmcpoll_TarVol.enabled=false
    GMCPoll_Pcur.enabled=false
    GMCPoll_CurFlow.enabled=false
    gmcpoll_Flow_Rate.enabled=false
    GMCPoll_MLtot.enabled=false
    GMCPoll_PcurA.enabled=false
    GMCPoll_PcurB.enabled=false
    GMCPoll_Flowing.enabled=false
    GMCPoll_PState_status.enabled=false
    GMCPoll_MLcurA.enabled=false
    GMCPoll_MLcurB.enabled=false
    GMCcom_CyclDone3.executeCommand=true
    REM Start NewErr Poll
    gmcpoll_newerr.enabled=true
endfunc
'func Define_Active_Cyl()
'    If MLcurA >Amin and MLcurA < Amax then
'        Active_Cyl="CylA"
'    elseif MLcurB > Bmin and MLcurB < Bmax then
'        Active_Cyl="CylB"
'    else
'        Active_Cyl="none"
'    endif
'endfunc

'func Find_Stroke_Limits()
'    Amin = StartMLA-VolpCyl
'    if Amin < 1.0 then
'        Amin = 1.0
'    endif
'    If Amin < RevAlrmA then
 '       Amin = RevAlrmA
'    endif
'    Amax= StartMLA + .03
'    if Amax>FwdAlrmA then
'        Amax = FwdAlrmA
'    endif
'    Bmin = StartMLB-VolpCyl
'    if Bmin < 1.0 then
'        Bmin = 1.0
'    endif
'    If Bmin < RevAlrmB then
'        Bmin = RevAlrmB
'    endif
'    Bmax= StartMLB + .03
'    if Bmax>FwdAlrmB then
 '       Bmax = FwdAlrmB
'    endif
'endfunc
func Get_Current_Config()
    GMCcom_Rod.executeCommand=true

'    _D("GMCcom_Diaph executeCommand=true in Get_Current_Config, " + galilcomm.GetStateString())
    gmccom_prange.executeCommand=true
    GMCcom_Stroke.executeCommand=true
    gmccom_volumea.executeCommand=true
    gmccom_volumeb.executeCommand=true
    gmccom_pmpstart.executeCommand=true
    gmccom_rcvstart.executeCommand=true
    gmccom_VolpCyl.executeCommand=true
    gmccom_vppsia.executeCommand=true
    gmccom_vppsib.executeCommand=true
    gmccom_pfsva.executeCommand=true
    gmccom_pfsvb.executeCommand=true
    gmccom_Pmax.executeCommand=true
    gmccom_FillR.executeCommand=true
    gmccom_FRMax.executeCommand=true
    gmccom_PmpMode.executeCommand=true
    gmccom_ReflRate.executeCommand=true
    gmccom_InVopn.executeCommand=true
    gmccom_InitRate.executeCommand=true


    'Add stuff to get and display FwdAlarm and RevAlarm
    gmccom_fwdalrma.executeCommand=true
    gmccom_revalrma.executeCommand=true
    gmccom_fwdalrmb.executeCommand=true
    gmccom_revalrmb.executeCommand=true
    gmccom_Amax.executeCommand=true
    gmccom_Bmax.executeCommand=true
    gmccom_Amin.executeCommand=true
    gmccom_Bmin.executeCommand=true

endfunc
func Handle_Error(errorID as Integer)
    dim strTime as string
    Date_and_Time(strTime)
    error_log_eb.Append("\n"+strtime+" Error ID "+str(ErrorID), true)
    gmccom_update_current_values.executeCommand=true



REM Rem Buttons can only be set in Set_Error_Buttons
'    if errorID==14 then 'we must force them to restart the pump
'        but_Ignore_Error.enabled=false
'    endif
    if Hold_This_Error then'we won't handle any more errors
        return
    endif
    if errorID>11 and errorID<14 then '12 and 13 are exceeded max press A and B
        If FlowStopped then  'only apply this error in flowmode
            return
        endif
    endif
    if ErrorDisplayDisabled and errorID==19 then
        return
        'Don't display if warnings disabled.
    endif
    if ErrorDisplayDisabled and errorID >4 and errorID<8 then
        'do not update the error log or display message
    else
        debugText="Error ID "+str(ErrorID)+"\nCurrent Values - PcurA: " +str(PcurA) +", PcurB: " +str(PcurB) +", Pcur: " +str(Pcur) +", AveSp: " + str(currate)+", Pressure warning limit: " +eb_Pmax_Warn.Value +", Pressure Shutdown limit " + eb_PMax_1.value +", Flow Warning " + eb_flowRlim_Warn.value +", Flow Shutdown " + eb_FlowRlim_1.Value
        Write_To_Debug(debugText, "Global Function Handle_Error")

        Date_and_Time(strTime)
        Update_Error_Arrays(errorID,strTime)
        Init_Error_Popup_Screen(errorID)
    endif
endfunc



func hold_press_ramp()
    '   Send Ramping=0
    GMCCommand.command = "Ramping=0"
    GMCCommand.executeCommand = true
    RampHold=true
    CurrentlyRamping=false
    GMCPoll_Ramping.enabled=False
endfunc

func Init_Config_Screen()
    lbl_Sys_Config_Instructions.value=defaultConfigMsg
    but_OK.enabled= false
    Config_Screen.enabled=true
' fix - I don't think this needs to be populated at init - do we need to do something with Config_screen2?
'    eb_volpcyl.Value=_FormatFloat(VolpCyl,6,2,_FLOAT_NORMAL)

    tmr_Delay_Get_Config.enabled=true
endfunc

func Init_Const_P_Screen()
    pressure_mode_screen.enabled = true
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=true
    gmcpoll_pcur.enabled =true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    gmcpoll_mltot.enabled=true
    RampHold=false
    eb_Target_Press.fgColor=160
    exitingpscreen=false

    eb_Target_Press.value= _formatfloat(0,6,2,_FLOAT_NORMAL)
    Ptarget=0
    eb_PressR.value= _formatfloat(0,6,2,_FLOAT_NORMAL)
    Prate=0
    lbl_Current_Flow_Rate_1.value="0.00"
    eb_FlowRLim.Value=_formatfloat(FlowRLim,6,2,_FLOAT_NORMAL)
    Set_Press_Buttons()

    If psi_per_sec then
        but_psi_per_sec_min.Value="psi/sec"
        eb_PressR.max=200
    else
        but_psi_per_sec_min.Value="psi/min"
        eb_PressR.max=12000
    endif

endfunc

func Init_Error_Popup_Screen(errorID as Integer)
    if Hold_This_Error then
        return
    endif
    I_sent_Restart=false
    REM These commands are not executed before we check the code. They are queued up and performed as seperate messages.
    REM GMCcom_PowerUp_1 was deleted because we couldn't figure out why we were calling it and
    REM because it was turing the Ignore button on at the wrong time.
'    GMCcom_PowerUp_1.executeCommand=true
'    GMCCom_Rev.executeCommand=true
'    GMCcom_ErrCode.executeCommand=true
'    GMCcom_LineNum.executeCommand=true

    if errorID > 0 and errorID <5 then
        REM 1 = cylinder A at lower limit
        REM 2 = cylinder A at upper limit
        REM 3 = cylinder B at lower limit
        REM 4 = cylinder B at upper limit
        Set_Error_Buttons(2)
    endif

    if errorID > 4 and errorID < 8 then
        REM 5 cyinlder A pressure warning limit hit
        REM 6 cylinder B pressure warning limit hit
        REM 7 Eceeded warning flow rate set for pressure control mode.

        REM no reason to set buttons if ErrorDisplayDisabled, error screen is not shown
        'If ErrorDisplayDisabled then
        '    Set_Error_Buttons(1)
        'else
        Set_Error_Buttons(0)
        'endif
    endif

    if errorID==8 or errorID==9 then
        REM Cylinder exceeded 25% compressibility
        REM This error is mostly handled by Galil, just display a warning.

        'If NOT P_Cont_On then
        Set_Error_Buttons(1)
        'else
        '   Set_Error_Buttons(3)
        '    Hold_This_Error=True
        'endif
    endif

    if errorID==11 or errorID==14 then
        REM 11 Position error
        REM 14 DAQ loop has stopped
        RestartRequired=true
        'STOP ASKING ABOUT POWERUP AND _XQ0
        tmrPowerUp.enabled=false
    endif
    if errorID>9 and errorID<15 then
        REM 10 Exceeded maximum flow rate set for pressure mode
        REM 12 Cylinder A pressure greater than PMax
        REM 13 Cylinder B pressure greater than PMax
        Set_Error_Buttons(2)
        Hold_This_Error=True
    endif
    if errorID>14 and errorID<19 then
        REM 15 Cylinder B was not ready for transition
        REM 16 Cylinder A was not ready for transition
        REM 17 Cylinder A limit switch tripped in pressure mode. - Replaced with errors 19 and 20
        REM 18 Cylinder B limit switch tripped in pressure mode. - Replaced with errors 19 and 20
        Set_Error_Buttons(3)
        Hold_This_Error=True
    endif
    If errorID==19 then
        REM Limit switch hit while trying to match pressure. If in flow mode, Galil should handle and keep flowing,
        REM in pressure mode the cylinder dies.
        Set_Error_Buttons(1)

    endif
    If errorID==20 then
        REM Limit switch and we don't know why.
        Set_Error_Buttons(3)
        Hold_This_Error=True
    endif
    If errorID>20 then
        REM Controller errors
        Set_Error_Buttons(2)
        Hold_This_Error=True
        lbl_ErrCode.enabled=true
        lbl_Rev.enabled=true
        lbl_LineNum.enabled=true
        lbl_ErrCode1.enabled=true
        lbl_Rev1.enabled=true
        lbl_LineNum1.enabled=true
    else
        lbl_ErrCode.enabled=false
        lbl_Rev.enabled=false
        lbl_LineNum.enabled=false
        lbl_ErrCode1.enabled=false
        lbl_Rev1.enabled=false
        lbl_LineNum1.enabled=false
    endif
    warning_sound()
    Error_Popup_Screen.enabled=true
    lbl_ErrNo.value=_FormatFloat(ErrorNoArray[0],3,0,_float_normal)
    lbl_ErrTime.value= ErrorTime0
    Display_Error_Message_Detected(ErrorNoArray[0])
    ErrorIndex=0

endfunc


func Init_Flow_Mode_screen()

    flow_mode_screen.enabled = true
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=true
    gmcpoll_pcur.enabled =true
    gmcpoll_mltot.enabled=true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    FlowStopped=True
    eb_FlowR.Value="0"
    mlpermin=0
    eb_Tar_Vol.Value="INF"
    mlmax=2000000000
   lbl_Current_Flow_Rate.value="0.00"
   Set_Flow_Buttons()
endfunc

func Init_IP_Address_screen()
    GMCcom_IA.executeCommand=true
    GMCcom_DH.executeCommand=true
    IP_Address_Screen.enabled=true
endfunc

func Init_Limits_screen()

        Limits_screen.enabled=true
        eb_Pmax_1.value=_FormatFloat(Pmax,6,2,_FLOAT_NORMAL)
        eb_Pmax_Warn.value=_FormatFloat(PmaxWarn,6,2,_FLOAT_NORMAL)
        eb_flowrlim_1.value=_FormatFloat(FlowRLim,6,2,_FLOAT_NORMAL)
        eb_FlowRLim_warn.value=_FormatFloat(FlowRLimWarn,6,2,_FLOAT_NORMAL)
        if ErrorDisplayDisabled then
            but_Enable_warnings.value="DISABLED"
            lbl_Warnings_Enabled.bgColor=196
        else
            but_Enable_warnings.value="ENABLED"
            lbl_Warnings_Enabled.bgColor=clr_softkeybarbackground
        endif
        eb_Pmax_1.bgcolor=clr_buttonbackground
        eb_Pmax_Warn.bgcolor=clr_buttonbackground
        eb_flowrlim_1.bgcolor=clr_buttonbackground
        eb_FlowRLim_warn.bgcolor=clr_buttonbackground

        if Open_Valves_at_Over_Pressure then
            lbl_Open_Valves_On_OP.bgColor=clr_softkeybarbackground
            but_Enable_Open_Valves.value="ENABLED"
        else
            lbl_Open_Valves_On_OP.bgColor=196
            but_Enable_Open_Valves.value="DISABLED"
        endif

        if not flow_limit_disabled then
            lbl_Flow_Shutdown.bgColor=clr_softkeybarbackground
            but_Enable_Shutdown.value="ENABLED"
        else
            lbl_Flow_Shutdown.bgColor=196
            but_Enable_Shutdown.value="DISABLED"
        endif

endfunc
func Init_Manual_Control_screen()

    Manual_Control_screen.enabled = true

    gmccom_ReflRate_ManA.executeCommand=true
    gmccom_ReflRate_ManB.executeCommand=true

    'Enable polling for position and pressure
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=true
    'gmcpoll_pcur.enabled =true
    'gmcpoll_mltot.enabled=true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true

    'Set button states
    but_Start_Flow_Man_A.enabled=false
    but_Start_Flow_Man_B.enabled=false
    but_Refill_A.enabled=true
    but_Refill_B.enabled=true
    but_Estop_1.enabled=false


    If FlowRA <> 0 and FloVolA <> 0 then
        ReadytoFlowA=true
    else
        ReadytoFlowA=false
    endif
    If FlowRB <> 0 and FloVolB <> 0 then
        ReadytoFlowB=true
    else
        ReadytoFlowB=false
    endif
    Set_Manual_Flow_Buttons()

    'Close all valves as the initial state
    but_ClsAll.click()
    but_Aout.Value="CLOSED"
    but_AIn.Value="CLOSED"
    but_Bout.Value="CLOSED"
    but_BIn.Value="CLOSED"


endfunc

func Init_Power_Up_Screen()
    Power_Up_Screen.enabled=true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    GMCPoll_Remote.enabled=true
    lbl_MLtot.value=_FormatFloat(MLtot,6,2,_FLOAT_NORMAL)
    lbl_PUtime.value=TimeLast$
    lbl_vol_cur_A.value=_FormatFloat(MLlastA,6,2,_FLOAT_NORMAL)
    lbl_vol_cur_B.value=_FormatFloat(MLlastB,6,2,_FLOAT_NORMAL)
    lbl_Vol_Cur_change_A.value=_FormatFloat(MLdeltaA,6,4,_FLOAT_NORMAL)
    lbl_Vol_Cur_change_B.value=_FormatFloat(MLdeltaB,6,4,_FLOAT_NORMAL)


endfunc

func Init_P_Cal_screen()
    but_transducer_select.Value="A"
    gmccom_prange.executeCommand=true
    gmccom_vppsia.executeCommand=true
    gmccom_pfsva.executeCommand=true
    eb_psi_actual.Value=""
    lbl_FS_volts_new.enabled=false
    lbl_volts_per_psi_new.enabled=false
    gmcpoll_pcura.enabled=true
    'set buttons
    but_zero.enabled=false
    but_accept_Pres_Calc.enabled=false
    but_calculate_constant.enabled=false
    lbl_Calibrate_1.enabled= false
    lbl_Calibrate_2.enabled= false
    lbl_Calibrate_3.enabled= false
    lbl_psi_indicated.enabled=false
    eb_psi_actual.enabled= false
    But_Transducer_Select.inactive=false

    lbl_New_Constant_1.enabled=false
    lbl_New_Constant_2.enabled=false
    eb_fs_volts.enabled=false

    lbl_p_cal_msg.value="Press NEW CONST to enter new Full Scale Volts or CALIBRATE to begin calibration process"
    CalMode=false
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=true
    p_cal_screen.enabled=true

endfunc

func Init_Press_Ramp()
    dim strCommand as string


    RampHold=false
    rampcomplete = false

    eb_target_press.fgcolor=244
'   Send TarPres
    strCommand = "TarPres=" + str(Ptarget)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
'   Send RampRate
    strCommand = "RampRate=" + str(Prate)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
'   Send Ramping=1
    GMCCommand.command = "Ramping=1"
    GMCCommand.executeCommand = true
    CurrentlyRamping=true
'   Start looking for Ramping = 0
    GMCPoll_Ramping.enabled=true

endfunc
func Init_Profile_Screen()
    Zero_Profile_Arrays()
    Profile_screen.enabled=true
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=true
    gmcpoll_pcur.enabled =true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    gmcpoll_mltot.enabled=true
    GMCPoll_CurFlow.enabled=true
    'set all segments to not selected
    ddl_Profile_1.selected=0
    ddl_Profile_2.selected=0
    ddl_Profile_3.selected=0
    ddl_Profile_4.selected=0
    ddl_Profile_5.selected=0
    ddl_Profile_6.selected=0
    'clear all rate and limit boxes
        eb_Limit_Profile_1.Value=""
    eb_Limit_Profile_2.Value=""
    eb_Limit_Profile_3.Value=""
    eb_Limit_Profile_4.Value=""
    eb_Limit_Profile_5.Value=""
    eb_Limit_Profile_6.Value=""
    eb_Rate_Profile_1.Value=""
    eb_Rate_Profile_2.Value=""
    eb_Rate_Profile_3.Value=""
    eb_Rate_Profile_4.Value=""
    eb_Rate_Profile_5.Value=""
    eb_Rate_Profile_6.Value=""
    'make only segment 1 available
    ddl_Profile_1.inactive=false
    ddl_Profile_2.inactive=true
    ddl_Profile_3.inactive=true
    ddl_Profile_4.inactive=true
    ddl_Profile_5.inactive=true
    ddl_Profile_6.inactive=true
    'Hide editboxes and units labels till a profile type is selected
    eb_Rate_Profile_1.enabled = false
    eb_Limit_Profile_1.enabled= false
    lbl_Rate_Seg_1.enabled=false
    lbl_Lim_Seg_1.enabled=false
    eb_Rate_Profile_2.enabled = false
    eb_Limit_Profile_2.enabled= false
    lbl_Rate_Seg_2.enabled=false
    lbl_Lim_Seg_2.enabled=false
    eb_Rate_Profile_3.enabled = false
    eb_Limit_Profile_3.enabled= false
    lbl_Rate_Seg_3.enabled=false
    lbl_Lim_Seg_3.enabled=false
    eb_Rate_Profile_4.enabled = false
    eb_Limit_Profile_4.enabled= false
    lbl_Rate_Seg_4.enabled=false
    lbl_Lim_Seg_4.enabled=false
    eb_Rate_Profile_5.enabled = false
    eb_Limit_Profile_5.enabled= false
    lbl_Rate_Seg_5.enabled=false
    lbl_Lim_Seg_5.enabled=false
    eb_Rate_Profile_6.enabled = false
    eb_Limit_Profile_6.enabled= false
    lbl_Rate_Seg_6.enabled=false
    lbl_Lim_Seg_6.enabled=false
    'make all edit boxes readWrite
    eb_Rate_Profile_1.editType=eb_ReadWrite
    eb_Rate_Profile_2.editType=eb_ReadWrite
    eb_Rate_Profile_3.editType=eb_ReadWrite
    eb_Rate_Profile_4.editType=eb_ReadWrite
    eb_Rate_Profile_5.editType=eb_ReadWrite
    eb_Rate_Profile_6.editType=eb_ReadWrite
    eb_Limit_Profile_1.editType=eb_ReadWrite
    eb_Limit_Profile_2.editType=eb_ReadWrite
    eb_Limit_Profile_3.editType=eb_ReadWrite
    eb_Limit_Profile_4.editType=eb_ReadWrite
    eb_Limit_Profile_5.editType=eb_ReadWrite
    eb_Limit_Profile_6.editType=eb_ReadWrite
    'hightlight first profile background and give instructions
    lbl_Profile_Segment_1.bgColor=clr_buttonbackgroundalt
    lbl_Profile_Segment_2.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_3.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_4.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_5.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_6.bgColor=clr_softkeybarbackground

    lbl_Profile_Msg.value="Select Profile type for segment 1."
    but_Profile.enabled=false
    but_end_Profile_Def.enabled=false
    but_Limits_3.enabled=false
    but_OpenValves_1.enabled=false
    but_ZeroXdcrs_1.enabled=false
    but_CycToStart_2.enabled=false
    Profile_Definition_Complete=false

endfunc
func Init_Setup_screen()
    Reset_Profile_Arrays()
    IF InitComplete then
        but_initialize.enabled=true
        but__exit_Sys_setup.enabled=true
        but__FactorySettings.enabled=true
        but__Valve_Control.enabled=true
        but_Configure.enabled=true
        but_PressureCalibration.enabled=true
        but_FlowCalibration.enabled=true
        lbl_Sys_Setup_Msg.value="Initialization has been completed."
    else
        but_initialize.enabled=true
        but__exit_Sys_setup.enabled=true
        but__FactorySettings.enabled=true
        but__Valve_Control.enabled=true
        but_Configure.enabled=true
        but_PressureCalibration.enabled=false
        but_FlowCalibration.enabled=false
        lbl_Sys_Setup_Msg.value="Initialization must be completed."
    endif
    Sys_Setup_Screen.enabled=true
endfunc
func Init_Title_screen()
    lbl_Receive_Mode_Warning.enabled=false
    Title_Screen.enabled= true
    Send_GMCcommand("Local=0")
    GMCPoll_Remote.enabled=true
    GMCPoll_DAQ.enabled=true
    Setup=false
    If Refilling then
        but_Man_Control.enabled=false
        but_PressureMode.enabled=false
        but_FlowMode.enabled=false
        but_ProfileMode.enabled=false
        'Loop to check for refilling done
        tmr_Wait_For_Refill.enabled=true

    elseif Not InitComplete then
        but_Man_Control.enabled=false
        but_PressureMode.enabled=false
        but_FlowMode.enabled=false
        but_ProfileMode.enabled=false
    else
        but_Man_Control.enabled=true
        but_PressureMode.enabled=true
        but_FlowMode.enabled=true
        but_ProfileMode.enabled=true
    endif
endfunc
func Init_Valve_Screen()
    but_Save_Valve_Config.enabled=false
    gmccom_InVopn.executeCommand=true
    Valve_Screen.enabled=true
endfunc
func Init_Vol_Cal_Screen ()
    Vol_Cal_screen.enabled=true
    but_start_flow_cal.value="START FLOW"
    but_start_flow_cal.enabled=false
    but_Accept_Vol_Calc.enabled=false
    but_fill_to_start.enabled=false
    but_Calculate_Volume.enabled=false
    eb_Flow_Vol.Value=_FormatFloat(0,6,2,_FLOAT_NORMAL)
    eb_Cal_Start.Value=_FormatFloat(0,6,2,_FLOAT_NORMAL)
    eb_ml_measured.Value=_FormatFloat(0,6,2,_FLOAT_NORMAL)
    InStartPos=false
    lbl_ml_per_mm_CALC.value=""
    eb_ml_measured.enabled=false
    gmccom_mlpmma.executeCommand=true
    gmccom_mlpmmb.executeCommand=true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    gmcpoll_mlcura.enabled=true
    gmcpoll_mlcurb.enabled=false
    but_Cylinder_Select.Value="CYL A"
    But_Cylinder_Select.inactive=false
    But_Valve_Select.inactive=false

endfunc
func Init_Remote_Display()
    Remote_Display.enabled=true
    Title_screen.enabled=false
    gmcpoll_Target_Press.enabled=true
    gmcpoll_TarVol.enabled=true
    GMCPoll_Pcur.enabled=true
    GMCPoll_CurFlow.enabled=true
    gmcpoll_Flow_Rate.enabled=true
    GMCPoll_MLtot.enabled=true
    GMCPoll_PcurA.enabled=true
    GMCPoll_PcurB.enabled=true
    GMCPoll_Flowing.enabled=true
    GMCPoll_PState_status.enabled=true
    GMCcom_VolumeA.executeCommand=true
    GMCcom_VolumeB.executeCommand=true
    GMCPoll_MLcurA.enabled=true
    GMCPoll_MLcurB.enabled=true
    GMCPoll_Remote.enabled=true
    REM don't poll for errors
    GMCPoll_NewErr.enabled=false
endfunc
func MLlast(newvalA as float,newvalB as float)
        MLlastA := newvalA
        MLlastB := newvalB
endfunc
func Start_tmr_Segment(Segment as Integer)
        dim SegTimeSecs as Integer

        SegTimeSecs=SegTimeArray[Segment]*60
        If SegTimeSecs<5 then
            SegTimeSecs=5
        endif
        tmr_Segment.TimePeriod=SegTimeSecs
        tmr_Segment.enabled=true
        If Segment > 1 then
            Segment_Seconds=0
        endif
endfunc
func Profile_Transition(Segment as integer)'segment is the one we are transferring from
    If Segment==0 then
        Start_Segment(1)
    Else
        If SegTypeArray[Segment+1]==4 then
        'if next segment is 4, we just set the timer again and increment
            Current_Segment=Current_Segment+1
            Define_Segment_Parameters(Current_Segment)
            Start_tmr_Segment(Current_Segment)
        else
            Exit_Segment(Segment)
        endif
    endif
endfunc
func Reset(MLA as float,MLB as float)
    dim strCommand as string
    'send RstPosA
    strCommand = "ResetMLA=" + str(MLA)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
    'send RstPosB
    strCommand = "ResetMLB=" + str(MLB)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
    'send XQ#RESET, 1
    strCommand = "XQ#RESET, 1"
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
endfunc
func Reset_Profile_Arrays()
    dim stepamount as integer
    init stepamount := 1
    dim countup as integer
    init countup := 0

    for countup = 0 to 7 step stepamount

    TarVolArray[countup]=0
    SegTimeArray[countup]=0
    TarPressArray[countup]=0
    SegRateArray[countup]=0
    SegTypeArray[countup]=0
    countup = countup +1
    next


endfunc

'func Restart_DAQ()
    'Send XQ#AUTO
'    GMCCommand.command = "XQ#AUTO"
'    GMCCommand.executeCommand = true
'    DAQ_Warning_screen.enabled=true
REM tmr_delay_check_Daq and GmcCom_daq items deleted since they weren't used anywhere. -SD
'    tmr_delay_check_DAQ.enabled = true
'endfunc

func Send_Config()
    dim strCommand as string
    'send PmpStart
    strCommand = "PmpStart=" + eb_start_vol_pump.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send RcvStart
    strCommand = "RcvStart=" + eb_start_receive.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send Amax
    strCommand = "Amax=" + eb_Amax.value
    Send_GMCcommand(StrCommand)

    'send Amin
    strCommand = "Amin=" + eb_Amin.value
    Send_GMCcommand(StrCommand)

    'send Bmax
    strCommand = "Bmax=" + eb_Bmax.value
    Send_GMCcommand(StrCommand)

    'send Bmin
    strCommand = "Bmin=" + eb_Bmin.value
    Send_GMCcommand(StrCommand)

    'send ReflPc
    strCommand = "ReflPc=" + eb_FillR.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send ReflFmn
    strCommand = "ReflFmn=" + eb_ReflRate.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send InitRate
    strCommand = "InitRate=" + eb_InitRate.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send VolpCyl
    strCommand = "VolpCyl=" + eb_VolPCyl.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send PMax
    strCommand = "PMax=" + eb_Pmax.value
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send PmpMode
    If rb_PumpMode.isChecked==true then
        strCommand = "PmpMode= 1"
    else
        strCommand = "PmpMode= 0"
    endif
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'SET BURN FLAG
    GMCCommand.command = "Burn=1"
    GMCCommand.executeCommand = true

    'Calculate new MLStart positions and burn new values
    strCommand = "XQ#STRTPOS,1"
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true

    'send Diaphragm range
'    Pxdcr = ddl_DP_Range.selected
'    strCommand = "Pxdcr=" + str(Pxdcr)
'    GMCCommand.command = strCommand
'    GMCCommand.executeCommand = true
'    GMCCommand.command = "XQ#VSCALE,1"
'    GMCCommand.executeCommand = true

    'send Rod Dia
'    RodSize = ddl_Rod_Dia.selected
'    strCommand = "RodSize=" + str(RodSize)
'    GMCCommand.command = strCommand
'    GMCCommand.executeCommand = true
'    GMCCommand.command = "XQ#SETSCAL,1"
'    GMCCommand.executeCommand = true
     'send JgSpdMn

'    strCommand="ReflRate=" + eb_reflRate.value
'    GMCCommand.command = strCommand
'    GMCCommand.executeCommand = true
    GMCCommand.command = "XQ#DEFSPD,5"
    GMCCommand.executeCommand = true

    tmr_Burn_New_Var.enabled=true


endfunc



func Send_FlowR(Vol as float,FlowRate as Float)
    dim strCommand as string

    'Send PmpRate = FlowRate - Invert value before sending (Galil Code requires Negative Value)
    FlowRate=-FlowRate
    strCommand = "PmpRate=" + str(FlowRate)
    Send_GMCcommand(strCommand)
    'Send TarVol= Vol
    If Vol<2000000000 then
        strCommand = "TarVol=" + str(Vol)
    else
        strCommand = "TarVol=2000000000"
    endif
    Send_GMCcommand(strCommand)
    Target_Volume=Vol
    If eb_flowr.DecimalPlaces==2 then
        lbl_Current_Flow_Rate.value = _formatfloat(-FlowRate,6,2,_FLOAT_NORMAL)
    else
        lbl_Current_Flow_Rate.value = _formatfloat(-FlowRate,6,3,_FLOAT_NORMAL)
    endif
endfunc
func Send_GMCcommand(strCommand as string)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
endfunc

func Send_Kprop(Kterm as float,Kxterm as float,Dterm as float,Iterm as float,MaxError as float)
     dim strCommand as string

    strCommand = "Kprop=" + str(Kterm)
    Send_GMCcommand(strCommand)

    strCommand = "Kx=" + str(Kxterm)
    Send_GMCcommand(strCommand)

    strCommand = "Dgain=" + str(Dterm)
    Send_GMCcommand(strCommand)

    strCommand = "Igain=" + str(Iterm)
    Send_GMCcommand(strCommand)

    strCommand = "Emax=" + str(MaxError)
    Send_GMCcommand(strCommand)

    GMCCommand.command = "BV"
    GMCCommand.executeCommand = true

endfunc

func Send_Krefl(Krfactor as float)
    dim strCommand as string

    strCommand = "Krefl=" + str(Krfactor)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true
endfunc

func Send_MLPmm(factor as float,Cyl as string)
    dim strCommand as string

        GMCCommand.command = "Burn=1"
        GMCCommand.executeCommand = true
    If Cyl=="A" then
        strCommand = "MLPmmA=" + str(factor)
        GMCCommand.command = strCommand
        GMCCommand.executeCommand = true

        GMCCommand.command = "XQ#CALCNTA,1"
        GMCCommand.executeCommand = true
    Elseif Cyl=="B" then
        strCommand = "MLPmmB=" + str(factor)
        GMCCommand.command = strCommand
        GMCCommand.executeCommand = true

        GMCCommand.command = "XQ#CALCNTB,1"
        GMCCommand.executeCommand = true

    else
        'some kind of error
        warning_sound()
    endif

endfunc
func Send_SP(NewSP as float)
    dim strCommand as string

    'Send PSetPt=NewSP
    strCommand = "PSetPt=" + str(NewSP)
    GMCCommand.command = strCommand
    GMCCommand.executeCommand = true


endfunc
func Send_PfsV(Scale_Factor as float,xdcr as String)
    Dim strCommand as string

    If xdcr=="A" then
        'Send PfsVA
        strCommand = "PfsVA=" + str(Scale_Factor)
        GMCCommand.command = strCommand
        GMCCommand.executeCommand = true
    endif
    If xdcr=="B" then
        'Send PfsVB
        strCommand = "PfsVB=" + str(Scale_Factor)
        GMCCommand.command = strCommand
        GMCCommand.executeCommand = true
    endif

    GMCCommand.command = "XQ#VSCALE,1"
    GMCCommand.executeCommand = true

endfunc
Func Set_Error_Buttons(CaseNo as Integer)
    If CaseNo==0 then
        but_restart_vpa.enabled=false
        but_Hide_15_Sec.enabled=false
        but_disable_warnings.enabled=true
        but_prev_Error.enabled=true
        but_OK_Error.enabled=true
        But_Ignore_Error.enabled=false
    endif
    If CaseNo==1 then
        but_restart_vpa.enabled=false
        but_Hide_15_Sec.enabled=false
        but_disable_warnings.enabled=false
        but_prev_Error.enabled=true
        but_OK_Error.enabled=true
        But_Ignore_Error.enabled=false
    endif
    If CaseNo==2 then
        but_restart_vpa.enabled=true
        but_Hide_15_Sec.enabled=true
        but_disable_warnings.enabled=false
        but_prev_Error.enabled=false
        but_OK_Error.enabled=false
        But_Ignore_Error.enabled=false
    endif
    If CaseNo==3 then
        but_restart_vpa.enabled=true
        but_Hide_15_Sec.enabled=true
        but_disable_warnings.enabled=false
        but_prev_Error.enabled=false
        but_OK_Error.enabled=false
        But_Ignore_Error.enabled=true
    endif
    if ErrorDisplayDisabled==true then
        but_disable_warnings.Value= "ENABLE WARNINGS"
    else
        but_disable_warnings.Value= "DISABLE WARNINGS"
    endif

endfunc
Func Set_Flow_Buttons()
    dim rateentered as float
    dim targetentered as float


    eb_FlowR.enabled=true
    eb_Tar_Vol.enabled = true
    lbl_Flow_Instructions.value=""

    If eb_FlowR.Value=="" then
        rateentered= 0
    else

        check error
            val(rateentered,eb_FlowR.Value)
        on error
            _ClearException()
        enderr
    endif
    if eb_Tar_Vol.Value=="INF" then
        targetentered=2000000000
    else

        check error
            val(targetentered,eb_Tar_Vol.Value)
        on error
            _ClearException()
        enderr
    endif
    if rateentered<= 0 or CycleComplete== false or (Refilling and Flowstopped) or Fstate==2 or Fstate==5 or (eb_Tar_Vol.Value=="Invalid" and Flowstopped) then
        But_StartFlow.enabled=false
    else
        But_StartFlow.enabled=true
    endif
    If FlowStopped then
        but_StartFlow.Value="START"
        If not Refilling and Fstate<>2 and Fstate<>5 then
            but_CycToStart.enabled=true
            but_ZeroVol.enabled = true
            but_ZeroXdcrs_2.enabled=true
            but_OpenValves_2.enabled=true
            but_QuitFlow.enabled=true
            but_Set_Mode_1.enabled=false
        endif

        but_Limits.enabled=true

    else
        but_StartFlow.Value="STOP"
        but_CycToStart.enabled=false
        but_ZeroVol.enabled = false
        but_Set_Mode_1.enabled=false
        but_Limits.enabled=true
        but_QuitFlow.enabled=false
        but_ZeroXdcrs_2.enabled=false
        but_OpenValves_2.enabled=false
    endif
    if ValueChanged and not FlowStopped then
        but_UpdateFlow.enabled=true
        valueChanged=false
    else
        but_UpdateFlow.enabled=false
    endif

    if PmpMode == 0 then
        but_Set_Mode_1.value ="RECEIVE MODE"
        but_Set_Mode.value ="RECEIVE MODE"
    else
        but_Set_Mode_1.value="PUMP MODE"
        but_Set_Mode.value="PUMP MODE"
    endif

    'Messages
    if rateentered<= 0 then
        lbl_Flow_Instructions.value="Flow Rate must be entered to start"
    endif
    if eb_Tar_Vol.Value=="Invalid" then
        lbl_Flow_Instructions.value="Enter a volume greater than the current volume"
    endif
    if CycleComplete==false then
        lbl_Flow_Instructions.value="Cycle Required to Start"
    endif
    if FlowStopped then
        lbl_Flow_Instructions.bgColor=clr_messagebackground
        lbl_Current_Flow_Rate.value=""
        lbl_Flow_Instructions.bgColor=26
'        lbl_Flow_Instructions.value="Flowing at constant rate"
    endif
endfunc
Func Set_Manual_Flow_Buttons()
    If ReadytoFlowA and not RefillingA then
        but_Start_Flow_Man_A.enabled=true
'    else
'        but_Start_Flow_Man_A.enabled=false
    endif
    If ReadytoFlowB and not RefillingB then
        but_Start_Flow_Man_B.enabled=true
'    else
'        but_Start_Flow_Man_B.enabled=false
    endif
    if flowinga==0 and not refillinga then
        but_refill_a.enabled=true
        but_ain.enabled=true
        but_aout.enabled=true
    endif
    if flowingb==0 and not refillingb then
        but_refill_b.enabled=true
        but_bin.enabled=true
        but_bout.enabled=true
    endif

endfunc

Func Set_Mode(mode as Float)
    If mode==0 then
        but_Set_Mode_1.value ="RECEIVE MODE"
        but_Set_Mode.value ="RECEIVE MODE"
        PmpMode = 0
    else
        but_Set_Mode_1.value="PUMP MODE"
        but_Set_Mode.value="PUMP MODE"
        PmpMode = 1
    endif
    'Send PmpMode=mode
    GMCCommand.command = "PmpMode=" + str(mode)
    GMCCommand.executeCommand = true
    GMCCommand.command = "Burn=1"
    GMCCommand.executeCommand = true
    GMCCommand.command = "XQ#STRTPOS,1"
    GMCCommand.executeCommand = true
endfunc

Func Set_Press_Buttons()
    dim rampentered as float
    dim tarpresentered as float


    eb_PressR.enabled=true
    eb_Target_Press.enabled = true
    lbl_RampStatus.value=""
    but_QuitPressure.enabled=true

    If eb_PressR.Value=="" then
        rampentered=0
    else
        check error
            val(rampentered,eb_PressR.Value)
        on error
            _ClearException()
        enderr
    endif
    if eb_Target_Press.Value=="" then
        tarpresentered = 0
    else
        check error
            val(tarpresentered,eb_Target_Press.Value)
        on error
            _ClearException()
        enderr
    endif
    If P_Cont_On then
        but_Pcont.Value="STOP P CONTROL"
        If not P_Stop_pressed then
            But_Pcont.enabled=true
        endif
    else
        but_Pcont.Value="START P CONTROL"
        if rampentered>0 and tarpresentered>0 and CycleComplete and not Refilling then
            But_Pcont.enabled=true
        else
            But_Pcont.enabled=false
        endif
    endif
    If P_Cont_on and Not RampComplete and ValueChanged then
        But_Ramp.enabled= true
    else
        But_Ramp.enabled=false
    endif
    If RampHold then
        but_Ramp.Value="CONT RAMP"
    elseif CurrentlyRamping and not RampComplete then
        If ValueChanged then
            but_Ramp.Value="UPDATE RAMP"
        else
            but_Ramp.Value="PAUSE RAMP"
        endif
    else
        but_Ramp.Value="START RAMP"
    endif
    If P_Cont_On or P_Stop_Pressed then
        but_ZeroXdcrs.enabled=false
        but_CycToStart_1.enabled = false
        but_OpenValves.enabled=false
        but_Set_Mode.enabled=false
        but_Limits_1.enabled=true
    else
        but_ZeroXdcrs.enabled=true
        but_CycToStart_1.enabled = true
        but_OpenValves.enabled=true
        but_Set_Mode.enabled=true
        but_Limits_1.enabled=true
    endif
    if PmpMode == 0 then
        but_Set_Mode_1.value ="RECEIVE MODE"
        but_Set_Mode.value ="RECEIVE MODE"
    else
        but_Set_Mode_1.value="PUMP MODE"
        but_Set_Mode.value="PUMP MODE"
    endif
    if Refilling then
        tmr_wait_for_refill.enabled=true
    endif

    'Messages
    lbl_RampStatus.value=""
    if rampentered<= 0 then
        lbl_RampStatus.value="Ramp Rate must be entered to start"
    endif
    if tarpresentered< 20 then
        lbl_RampStatus.value="Target Pressure must be at least 20"
    endif
    if CycleComplete==false then
        lbl_RampStatus.value="Cycle Required to Start"
    endif
    if not P_cont_on then
        lbl_Pressure_Msg.bgColor=clr_messagebackground
        lbl_Pressure_Msg.value="Pressure Control Stopped"
    else
        lbl_Pressure_Msg.bgColor=26
        lbl_Pressure_Msg.value="Controlling Pressure"
    endif
    valueChanged=false
endfunc
func Start_Profile()
    Profile_Stopped=false
    Current_Segment=0
    Profile_Total_Time=SegTimeArray[1]+SegTimeArray[2]+SegTimeArray[3]+SegTimeArray[4]+SegTimeArray[5]+SegTimeArray[6]
    Profile_Seconds=0
    Segment_Seconds=0
    tmr_Profile_Times.enabled=true
    Profile_Transition(Current_Segment)
endfunc
func Start_Segment(Segment as Integer)
    'four cases to deal with
    dim CaseCurrent as integer
    init CaseCurrent :=0
    Current_Segment=Segment
    Define_Segment_Parameters(Current_Segment)
    If SegTypeArray[Current_Segment]==1 or SegTypeArray[Current_Segment]==2 then
        If FlowStopped then
            CaseCurrent=1
        else
            CaseCurrent=2
        endif
    endif

    If SegTypeArray[Current_Segment]==3 then
        If P_Cont_On then
            CaseCurrent= 4
        else
            CaseCurrent=3
        endif
    endif
    'Case 1, Stopped to Flow mode
    If CaseCurrent==1 then
        Send_FlowR(mlmax,mlpermin)
        Start_Flow()
        Start_tmr_Segment(Current_Segment)
    endif
    'Case 2 , Flow mode to Flow Mode
    'make sure we know (mlmax,mlpermin)
    If CaseCurrent==2 then
        Send_FlowR(mlmax,mlpermin)
        Send_GMCcommand("RateChng=1")
        Start_tmr_Segment(Current_Segment)
    endif
    'Case 3, Stopped to Pressure ramp
    If CaseCurrent==3 then
        Start_P_Mode()
        Start_tmr_Segment(Current_Segment)
    endif
    'This takes to the next segment automatically
    'Case 4 , Press Const to Press Ramp
    If CaseCurrent==4 then
        Init_Press_Ramp()
        Start_tmr_Segment(Current_Segment)
    endif
endfunc
func Stop_Profile()
    tmr_Segment.enabled=false
    tmr_Profile_Times.enabled=false
    Profile_Stopped=true
'    add code from exit segment here
        If FState>0 then
            Stop_Flow()
            tmr_refill.enabled=true
            IF LastSegment then
                lbl_Profile_Msg.value="Waiting for pump refill to complete"
            endif
        endif
        If PState>0 then
            Stop_P_Mode()
            tmr_refill.enabled=true
            IF LastSegment then
                lbl_Profile_Msg.value="Waiting for pump refill to complete"
            endif
        endif
endfunc
func TicksToDispString(ticks as float) returns string
    return SecondsToDispString(integer(ticks/32768.0))
endfunc

func SecondsToDispString(sec as integer) returns string
    dim hour as integer
    dim min as integer
    dim hStr, mStr, sStr as string

    hour := sec / 3600
    sec := sec mod 3600
    min := sec / 60
    sec := sec mod 60
    hStr := str(hour)
    while (len(hStr) < 2) do
        hStr := "0" + hStr
    loop
    mStr := str(min)
    while (len(mStr) < 2) do
        mStr := "0" + mStr
    loop
    sStr := str(sec)
    while (len(sStr) < 2) do
        sStr := "0" + sStr
    loop
    return hStr + ":" + mStr + ":" + sStr
endfunc

func Update_Error_Arrays(ErNo as Integer,Ertime as String)
    ErrorNoArray[4]=ErrorNoArray[3]
    ErrorNoArray[3]=ErrorNoArray[2]
    ErrorNoArray[2]=ErrorNoArray[1]
    ErrorNoArray[1]=ErrorNoArray[0]
    ErrorNoArray[0]=ErNo
    ErrorTime4=ErrorTime3
    ErrorTime3=ErrorTime2
    ErrorTime2=ErrorTime1
    ErrorTime1=ErrorTime0
    ErrorTime0=ErTime
endfunc

func warning_sound()
    If not tmr_error_beep_delay.enabled then
        Playnote(55,500)
        tmr_error_beep_delay.enabled = true
    endif

endfunc
func Zero_Profile_Arrays()
    TarVolArray[0]=0
    SegTimeArray[0]=0
    TarPressArray[0]=0
    SegRateArray[0]=0
    SegTypeArray[0]=0
    TarVolArray[1]=0
    SegTimeArray[1]=0
    TarPressArray[1]=0
    SegRateArray[1]=0
    SegTypeArray[1]=0
    TarVolArray[2]=0
    SegTimeArray[2]=0
    TarPressArray[2]=0
    SegRateArray[2]=0
    SegTypeArray[2]=0
    TarVolArray[3]=0
    SegTimeArray[3]=0
    TarPressArray[3]=0
    SegRateArray[3]=0
    SegTypeArray[3]=0
    TarVolArray[4]=0
    SegTimeArray[4]=0
    TarPressArray[4]=0
    SegRateArray[4]=0
    SegTypeArray[4]=0
    TarVolArray[5]=0
    SegTimeArray[5]=0
    TarPressArray[5]=0
    SegRateArray[5]=0
    SegTypeArray[5]=0
    TarVolArray[6]=0
    SegTimeArray[6]=0
    TarPressArray[6]=0
    SegRateArray[6]=0
    SegTypeArray[6]=0
    NumberofSegments=0
    Profile_Total_Time=0
    Profile_Start_Time=0
    Seg_Start_Time=0
    LastSegment= false
    Next_Segment=0
endfunc

#ifnot Galil_mcV2_src_GalilCommV2
#option Galil_mcV2_src_GalilCommV2
library Galil_mcV2 source GalilCommGlobals
#undoc func GMC_VerifyGalilCommV2
func GMC_VerifyGalilCommV2 (commObject as reference to objref GalilCommV2)
    if commObject == empty then
        commObject := GMC_DefaultGalilCommV2
        #if _tool tool_persist(commObject) #endif
    endif
endfunc
#doc prop GMC_DefaultGalilCommV2
~Default value for the main communications object when
~objects are created in the Galil Library.
dim GMC_DefaultGalilCommV2 as objref GalilCommV2
#undoc func _ProcessGMCUpdatePeriod
func _ProcessGMCUpdatePeriod(updatePeriod as reference to integer, myObj as objref)
    if (updatePeriod mod 20) <> 0 then
        updatePeriod := (updatePeriod / 20) * 20
        #IF _TOOL tool_persist(updatePeriod) #ENDIF
    endif
    if updatePeriod < 20 and updatePeriod <> 0 then
        updatePeriod := 0
        #IF _TOOL tool_persist(updatePeriod) #ENDIF
    elseif updatePeriod < 40 and updatePeriod <> 0 then
        updatePeriod := 40
        #IF _TOOL tool_persist(updatePeriod) #ENDIF
    endif
    if updatePeriod > 0 then
        RegisterMsgHandler (myObj, MSG_TIMETICK, updatePeriod/20)
    else
        UnregisterMsgHandler(myObj, MSG_TIMETICK, 0)
    endif
endfunc
#endif

#ifnot Basic_src_editboxV2
#option Basic_src_editboxV2
library core source coreEditBox
#endif
#ifnot Basic_src_LabelV2
#option Basic_src_LabelV2
#endif

#ifnot Galil_mcV2_src_GMCPollV2
#option Galil_mcV2_src_GMCPollV2
#endif

#ifnot Basic_src_SoftKeyBarV2
#option Basic_src_SoftKeyBarV2
#ifnot SK_Menu_Container_Globals
#option SK_Menu_Container_Globals
    const message MSG_POPUP_MENU_POSTINIT
    const message MSG_UPDATE_SOFTKEYBARCAPTIONS
    const _softKey_arrow_spacing := 4
    const initG55Popup_ListSize := 10
    #hidden dim _G55_Curr_SoftKeyInfo as SoftKeyV2
    #hidden dim _sk_currLed as integer
    init _sk_currLed := -1
    #hidden dim _sk_ledList[] as integer
    init _sk_ledList := [0,1,2,3,4,5,6,7,8,9,10,11,12]
    #undoc func _PopLeftMenu
    func _PopLeftMenu(mlist as reference to charstr) returns charstr
        dim idx, j as integer
        dim tmp as charstr
        idx := 0
        j := 0
        idx := find(mlist, 0, -1, charstr("("))
        do
            tmp := mid(mlist, idx, 1)
            if tmp == charstr("(") then
                j := j + 1
            elseif tmp == charstr(")") then
                j := j - 1
            endif
            idx := idx + 1
        loop while (j <> 0 and idx < len(mlist)-1)
        tmp := left(mlist, idx)
        mlist := right(mlist, len(mlist)-idx)
        return tmp
    endfunc
    #undoc func _ParseMenuNode
    func _ParseMenuNode(mlist as reference to charstr, caption as reference to charstr, ->
        submlist as reference to charstr, hotchar as reference to char, ->
        id as reference to integer)
        dim idx as integer
        dim tmpchar as charstr
        idx := find(mlist, 0, -1, charstr(","))
        caption := left(mlist, idx)
        mlist := right(mlist, len(mlist)-idx-1)
        if mid(mlist,0,1) == charstr(",") then
            submlist := ""
        else
            submlist := _PopLeftMenu(mlist)
        endif
        idx := find(mlist, 0, -1, charstr(","))
        mlist := right(mlist, len(mlist)-idx-1)
        idx := find(mlist, 0, -1, charstr(","))
        tmpchar := left(mlist, idx)
        if len(tmpchar) > 0 then
            hotchar := tmpchar[0]
        else
            hotchar := 0
        endif
        mlist := right(mlist, len(mlist)-idx-1)
        idx := find(mlist, 0, -1, charstr(";"))
        tmpchar := left(mlist, idx)
        val(id, _CharstrToStr(tmpchar))
        mlist := right(mlist, len(mlist)-idx-1)
    endfunc
library basic source softkeyV2
#endif 'SK_Menu_Container_Globals
#endif

func CommReceiveUrgent (data[] as byte) returns boolean
    handles MSG_COMM_RECEIVE_URGENT
    return true
endfunc
Define Area Object type EditBoxV2 extends coreEditBox
#ToolImage "FFFFFFFFFFFFFFFF69696969400000018FFFFFF28FFFFFF24FFFFFF14FFFFFF18C03FFF28FFFFFF24000000169696969FFFFFFFFFFFFFFFFFFFFFFFF"
'*******************************************************************
'Object:        EditBoxV2
'Author:        Ron Lloyd
'Date:          01 Oct 2009
'
'Description:   EditBox for text entry using the G55 keyPad.
'
'Version:       2.10
'Copyright 2004 QSI Corporation
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved
'*******************************************************************
#doc object EditBoxV2
~The EditBox object is a simple text editor object. It provides the ability to enter and edit
~text using a keyboard or keypad.
~The enter key is reserved to begin editing or save changes.
~The escape key is reserved for canceling changes.
~The edit box can be used as a single line, multiple line or numeric text
~editor.
'to cycle characters in singline mode using up & down then add #option _EB_SINGLINE_CHARCYCLE

func bgcolor(newval as colormap%)
    if bgcolor == newval then
        return
    endif
    default (newval)
endfunc

func value(newval as charStr)
    if value == newval then
        return
    endif
    default (newval)
endfunc

func ScreenRelease (xup as integer, yup as integer) returns boolean
    handles MSG_SCREEN_RELEASE
    if EditType==eb_ReadWrite then
        DispKP(me)
    endif
    return default (xup, yup)
endfunc
Enddef
Define Area Object type G55PopupMenu
#ToolImage "FFFF8001800180018811842182418181824184218811800180018001FFFF"
'#ToolImag "FFFFFFFFF000000FCFFFFFF1CFFFFFF1CCC000F1CCFFFFF1CFFFFFF1CCC000F1CCFFFFF1CFFFFFF1CCC000F1CCFFFFF1CFFFFFF1F0000001F5555556"
'*******************************************************************
'Object:        G55PopupMenu
'Author:        Ronnie Lloyd
'Date:          21 Jun 2011
'
'Description:   PopupMenu, interacts with the keypad translater to selects items.
'
'Version:       1.0
'Copyright 2011 Beijer Electronics Inc
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved
'*******************************************************************

'#doc object G55PopupMenu
'~Interacts with the KeypadTranslater to move up and down items
'~after an item is selected dissapears.  Also uses keypad keys as possible hot keys
'~for quick selection of an item in the menu.  Submenus may also be specified for
'~each item.
#undoc object G55PopupMenu
#defaultitem func
#defaultitem prop

library standard source ToolMessages
library standard source stringarray

#hidden dim enabled as boolean
init enabled := false
#undoc func enabled
func enabled(newval as boolean)
    enabled := newval
    Enable (me, enabled)
endfunc

dim xPos as integer
init xPos := -100
func xPos(newval as integer)
    xPos := newVal
    Relocate (me, xPos, yPos)
    if _kt_FocusObj == me then
        _keySetFocus(me, true)
    endif
endfunc

dim yPos as integer
init yPos := -100
func yPos(newval as integer)
    yPos := newval
    Relocate (me, xPos, yPos)
    if _kt_FocusObj == me then
        _keySetFocus(me, true)
    endif
endfunc

#hidden dim width as integer
init width := 25
#undoc func width
func width(newval as integer)
    width := newval
    Resize (me, width, height)
endfunc

#hidden dim height as integer
init height := 25
#undoc func height
func height(newval as integer)
    height := newval
    Resize (me, width, height)
endfunc

#doc prop initialSelected
#category Main
~This determines the initial selected item in the menu.  If no item is to be initially selected,
~set this item to -1
dim initialSelected as integer
init initialSelected := -1

#doc prop Selected
#category Main
~This is the current selected item in the Menu.  If this is set to -1 then no
~rows are selected in the Menu.  This property may be changed to select
~different rows.
dim selected as integer
init selected := -1
func selected(newVal as integer)
    selected := newVal
    Rerender(me)
endfunc

dim font as sysfont
init font := default
func font(newval as sysfont)
    font := newval
endfunc

dim ptSize as integer
init ptSize := 10
func ptSize(newval as integer)
    ptSize := newval
endfunc

dim borderstyle as styleMap%
init borderstyle := Bdr_CompositeObject
func borderstyle(newval as stylemap%)
    borderstyle := newval
endfunc
dim fgColor as colorMap%
init fgColor := Clr_ButtonForegroundAlt
func fgColor (newVal as colorMap%)
    fgColor := newVal
endfunc

dim bgColor as colormap%
init bgColor := Clr_ButtonBackgroundAlt
func bgColor (newVal as colorMap%)
    bgColor := newVal
endfunc

#doc prop showItemNumbers
#category Main
~If true, this object will display numbers next to each menu item.  These numbers can be used
~on terminals with a keypad or keyboard for quick selection of items 1-9 in the menu.
dim showItemNumbers as boolean
init showItemNumbers := true

' this is the submenu of the next Popupmenu to received parsed data.
dim MainSubMenu as G55PopupMenu

#doc prop menuData
~ This is the content of the menu as well as the content of each submenu.
~ Current Format: (<caption>, <menu data>, <hot char>, <id>;)
dim menuData as charstr
init menuData := ""
func menuData(newval as charstr)
    menuData := newval
    RecalcMenuData()
endfunc

private dim dead as boolean
init dead := true

private dim lineHeight as integer
private dim maxLineHeight as integer
private dim iconSizeX as integer
private dim iconSizeY as integer
private dim borderWidth as integer

private dim prevFocusObj as objref

private dim items[initG55Popup_ListSize] as ArrayHandle
'Stores Main submenu if needed
private dim subMenus[initG55Popup_ListSize] as objref G55PopupMenu
'Stores data for submenu if exists or stores empty string.
private dim subMenuLists[initG55Popup_ListSize] as ArrayHandle
private dim nextMenu as objref G55PopupMenu
private dim prevMenu as objref G55PopupMenu
private dim hotChars[initG55Popup_ListSize] as char
private dim IDs [initG55Popup_ListSize] as integer
private dim count as integer
private dim maxCount as integer
init maxCount := 10

'processes data in the menulist updates the menu data as needed.
private func RecalcMenuData()
    dim i, cnt, idx as integer
    dim mlist, tmplist, tmpitem as charstr
    dim tmpsubmenu as G55PopupMenu
    dim tmphotchar as char
    dim tmpid as integer
    'clear memory of old arrays
    Clear()

    mlist := MenuData
    ' remove first (
    idx := find(mlist, 0, -1, charstr("("))
    mlist := right(mlist, len(mlist)-idx-1)

    'keeps track of size of arrays
    cnt := 0
    idx := find(mlist,0,-1, charstr(";"))
    while (idx <> -1) do

        _ParseMenuNode(mlist, tmpitem, tmplist, tmphotchar, tmpid)

        if tmplist <> charstr("") then
            tmpsubmenu := MainSubMenu
        else
            tmpsubmenu := empty
        endif
        AddItem(tmpitem, tmplist, tmpsubmenu, tmphotchar, tmpid)

        cnt := cnt + 1
        idx := find(mlist,0,-1, charstr(";"))
    loop
endfunc

'This function clears the menu contents.  Generally you will call this before a series of calls
'to AddItem.  This function cannot be called while the menu is being displayed.
private func Clear()
    dim i as integer

    if enabled then
        return
    endif

    for i = count-1 to 0 step -1
        FreeArrayHandle(items[i])
        items[i] := NULL_HANDLE
        FreeArrayHandle(subMenuLists[i])
        subMenuLists[i] := NULL_HANDLE
    next
    count := 0

    nextMenu := empty
    prevMenu := empty
    i := len(ids)
    redim(ids, 0)
    redim(ids, i)
    i := len(hotChars)
    redim(hotChars, 0)
    redim(hotChars, i)
endfunc

'Adds an item to the menu.  This function cannot be called while the menu is being displayed
'param caption: The text to be displayed in the menu
'param submenu: If this menu item is supposed to open up another menu when selected, this is a reference to that menu.  If this item should not open up a sub menu when selected, pass in empty for this parameter.
'param hotChar: Indicates what character in the caption string to underline.  If the user presses this key on a keypad or keyboard, that menu item will be selected
'param ID: An identifier.  This value will be passed into the ItemSelected() event.  While this ID does not need to be unique, it can be useful for determining which menu item was selected.
private func AddItem(caption as charstr, submenudata as charstr, ->
    submenu as objref G55PopupMenu, hotChar as char, ID as integer) returns integer
    dim tmp as charstr
    while count >= maxCount do
        maxCount = maxCount*2
        redim(items, maxCount)
        redim(subMenuLists, maxCount)
        redim(subMenus, maxCount)
        redim(hotChars, maxCount)
        redim(IDs, maxCount)
    loop

    if showItemNumbers then
        ArrayOperation(tmp, str(count+1), array_convert)
        caption := tmp + charstr(". ") + caption
    endif

    items[count] := AllocateArrayHandle(caption)
    submenulists[count] := AllocateArrayHandle(submenudata)
    submenus[count] := submenu
    hotChars[count] := hotChar
    ids[count] := id

    count := count + 1

    return count - 1
endfunc

func GetCount() returns integer
    return count
endfunc

#doc func GetSubmenu
~Returns submenu is selected
func GetSubmenu() returns G55PopupMenu
    if selected == -1 then
        return empty
    endif
    return submenus[selected]
endfunc

#doc func GetPrevMenu
~Returns prevMenu
func GetPrevMenu() returns G55PopupMenu
    return prevMenu
endfunc

private func ShowSubMenu(yPt as integer, subMenu as objref G55PopupMenu)
    dim xPt as integer

    if subMenu == empty then
        return
    endif

    nextMenu := subMenu
    xPt = xPos+width
    if subMenu.ShowMenu(xPt, yPt, HJustify_Left, VJustify_Top) then
        subMenu.prevMenu := me
        if subMenu.xpos <> xpt then 'Got shifted, so we shall try the other side
            subMenu.positionMenu(xPos, yPt, HJustify_Right, VJustify_top)
'            if _keyFocusObj == subMenu then
'                _keySetFocus (subMenu, true)
'            endif
        endif
    else
        nextMenu := empty
    endif
endfunc

#undoc func ShowMenu
~Displays a configured menu.  Before calling this function, you should call AddItem to
~add all items for this and any sub menu objects in use.
#param xPt: The x coordinate to display the menu at (in obj's coordinate system)
#param yPt: The y coordinate to display the menu at (in obj's coordinate system)
'#param obj: Typically, the object that is requesting that the menu be shown.  This is object is only used to determine the coordinate system that xPt and yPt are in.  If you are passing in absolute display coordinates for xPt and yPt, pass default for this parameter.
#param xAlign: Determines whether the menu is left, center or right aligned with respect to xpt.
#param yAlign: Determines whether the menu is top, center or bottom aligned with respect to ypt.
func ShowMenu(xPt as integer, yPt as integer, xAlign as HJustifyFlags, ->
              yAlign as VJustifyFlags) returns boolean

    dim i as integer
    dim maxW, maxH as integer
    dim w, h, xo, yo as integer
    dim ml, mr, mu, md, nlx, nly as integer
    dim tmpStr as charstr

    'Cannot recursively open menus
    #IFNOT _TOOL
    if enabled then
        return false
    endif
    #ENDIF

    'Move to the front of objects in parent.
    sendToFront(me)

    prevMenu := empty
    nextMenu := empty

    for i = count-1 to 0 step -1
        ReadArrayHandle(tmpStr, items[i])
        GetSysTextSize(w, h, xo, yo, font, 0, ptSize, tmpStr, font_normal)
        if w > maxW then
            maxW := w
        endif
    next
    GetSysFontMetrics(ml, mr, mu, md, nlx, nly, font, 0, ptSize, font_normal)

    lineHeight := mu+md+1
    if lineHeight < 18 then
        lineHeight = 18
    endif
    maxLineHeight = mu+md+1
    GetSysTextSize(w, h, xo, yo, font, 0, ptSize, "W", font_normal)
    iconSizeX = w
    iconSizeY = (h/2)*2

    borderWidth := _GetBorderWidth(_StyleMap[borderStyle])
    w := maxW + 2*borderWidth + 4 + iconSizeX+1
    h := count*lineHeight + 2*borderWidth + 2
    if width <> w then
        width := w
        #IF _TOOL tool_persist(width) #ENDIF
    endif
    if height <> h then
        height := h
        #IF _TOOL tool_persist(height) #ENDIF
    endif
    Resize (me, w, h)

    PositionMenu(xPt, yPt, xAlign, yAlign)

    enabled = true
    UnregisterMsgHandler (me, msg_timetick, 0)
    SetCapture(me)

    RegisterKey(me, key_any)
    Rerender(me)
    selected = initialSelected
    dead := false

    return true
endfunc

private func PositionMenu(xPt as integer, yPt as integer, ->
                          xAlign as hJustifyFlags, yAlign as vJustifyFlags)
    #IF _TOOL
    dim oldX, oldY as integer
    oldX := xPos
    oldY := yPos
    #ENDIF
    if (xAlign == HJustify_Center) or (xAlign == HJustify_center) then
        xPos := xPt - width/2
    elseif (xAlign == HJustify_right) or (xAlign == HJustify_right) then
        xPos := xPt - width+1
    else
        xPos := xpt
    endif
    if (yAlign == VJustify_Center) or (yAlign == VJustify_center) then
        yPos := yPt - height/2
    elseif (yAlign == VJustify_bottom) or (yAlign == VJustify_bottom) then
        yPos := yPt - height+1
    else
        yPos := yPt
    endif

    if xPos < 0 then
        xPos := 0
    elseif xPos + width-1 > GetPosInfo(default, get_width) then
        xPos := GetPosInfo(default, get_width) - width +1
    endif
    if yPos < 0 then
        yPos := 0
    elseif yPos+height-1 > GetPosInfo(default, get_height) then
        yPos := GetPosInfo(default, get_height) -height + 1
    endif
    Relocate (me, xPos, yPos)
    #IF _TOOL
    if xPos <> oldX then
        tool_persist(xPos)
    endif
    if xPos <> oldY then
        tool_persist(yPos)
    endif
    #ENDIF
endfunc

#doc override ItemSelected
~This function is called whenever an item is selected in the menu.
#param selectedItem: The row in the menu that was selected.
#param ID: The ID you passed into AddItem for the item that was selected.
func ItemSelected(selectedItem as integer, ID as integer)
    return
endfunc

func DoItemSelected()
    if selected >= 0 then
        if subMenus[selected] <> empty then
            ReadArrayHandle(subMenus[selected].menuData, submenulists[selected])
            showSubMenu(yPos+borderWidth+1+lineHeight*selected, subMenus[selected])
            _keySetFocus(subMenus[selected], false)
        else
            DestroyMenu(true, true, true)
            ItemSelected(selected, ids[selected])
        endif
    endif
endfunc

fixed func Cancel()
    if enabled then
        DestroyMenu(true, true, false)
    endif
endfunc

private func DestroyMenu (collapseAll as boolean, restoreFocus as boolean, linger as boolean)
    dim curMenu as objref G55PopUpMenu
    dim nextDestroyMenu  as objref G55PopUpMenu
    dim bottomMenu as boolean

    #IFNOT _TOOL_ANY
        if _sk_currLed <> -1 then
            check error
                'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
            on error
                _clearException()
            enderr
            _sk_currLed := -1
        endif
    #ENDIF

    curMenu := me
    if collapseAll then
        while curMenu.prevMenu <> empty do
            curMenu := curMenu.prevMenu
        loop
    endif

    bottomMenu := true
    while curMenu <> empty do
        nextDestroyMenu := curMenu.nextMenu
        curMenu.DoDestoryMenu(bottomMenu and restoreFocus, bottomMenu, linger)
        bottomMenu := false
        curMenu := nextDestroyMenu
    loop
endfunc

private func DoDestoryMenu (restoreFocus as boolean, restoreEditMode as boolean, linger as boolean)
    RemoveCapture(me)
    prevMenu := empty
    nextMenu := empty
    dead := true

    if linger then
        Rerender(me)
        RegisterMsgHandler(me, msg_timetick, 8)
    else
        enabled = false
        UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
        '_keySetRecentFocusObject()
        UnregisterMsgHandler (me, msg_timetick, 0)
    endif
endfunc

func StartUp()
    handles MSG_INIT
    Relocate (me, xPos, yPos)
    Resize (me, width, height)
    Enable (me, enabled)
    Attach (me, default)

    UserDirectMsg(me, MSG_POPUP_MENU_POSTINIT, 0, false)
    RecalcMenuData()
endfunc

private func Draw ()
    handles MSG_DRAW

    dim fg, bg as color
    dim xp, yp, w as integer
    dim i, max as integer
    dim iconX as integer
    dim iconY as integer
    dim drawStr, hotStr as charstr
    fg := _colormap[fgColor]
    bg := _colorMap[bgColor]

    SetFgColor(bg)
    setBGColor(bg)
    DrawBox (xPos, yPos, xPos+width-1, yPos+height-1)

    SetFgColor(fg)
    SetTransparent(bg)
    useTransparent(true)
    xp := xPos + borderWidth + 1
    yp := yPos + borderWidth + 1
    w := width-2*borderWidth-2
    max := count-1
    iconX = xPos + width-borderWidth-1-iconSizeX
    for i = 0 to max

        if i == selected then
            SetBgColor(fg)
            DrawBox (xPos+borderWidth, yp, xPos+width-borderWidth-1, yp+maxLineHeight)
            SetFgColor(bg)
            useTransparent(false)
        endif

        ReadArrayHandle(drawStr, items[i])
        _DrawSysTextLine(xp, yp, w, maxLineHeight, ->
                        font, ptSize, drawStr, hJustify_Left, vJustify_Center )
        'underline hotKey
        hotStr := " "
        hotStr[0] := hotChars[i]
        DrawUnderline(xp, yp, font, ptsize, drawStr, hotStr)

        if subMenus[i] <> empty then
            iconY = yp + (maxLineHeight-iconSizeY)/2
            DrawLine(IconX, iconY, iconX, iconY+iconSizeY)
            DrawLine(IconX, iconY, iconX + iconSizeX, iconY+iconSizeY/2)
            DrawLine(iconX + iconSizeX, iconY+iconSizeY/2, iconX, iconY+iconSizeY)
        endif
        yp := yp + lineHeight

        if i == selected then
            SetFgColor(fg)
            SetBgColor(bg)
            UseTransparent(true)
        endif
    next

    DrawBorder(xPos, yPos, width, height, _stylemap[borderStyle], 4+2)

    return
endfunc

private func DrawUnderline(xp as integer, yp as integer, font as sysfont, ->
    ptsize as integer, drawstr as charstr, hotstr as charstr)
    dim idx as integer
    dim w, h, xo, yo, xl, xr, yd as integer

    idx := find(drawStr, 0, -1, hotStr)
    if idx <> -1 then
        GetSysTextSize(w,h,xo,yo,font,0,ptsize,drawstr,FONT_NORMAL)
        yd := yp + ((maxLineHeight+1)/2)+((h+1)/2) +1
        'Get xleft underline position
        GetSysTextSize(w,h,xo,yo,font,0,ptsize,left(drawstr,idx+1),FONT_NORMAL)
        xl := xp - xo + w
        'Get Size of the hotstr
        GetSysTextSize(w,h,xo,yo,font,0,ptsize,hotstr,FONT_NORMAL)
        xr := xl-w
    endif
    DrawLine(xl, yd, xr, yd)
endfunc

private func ScreenPress (xdown as integer, ydown as integer) returns boolean
    handles MSG_SCREEN_PRESS
    dim newSel as integer

    _keySetFocus(me, false)

    if dead then
        return true
    endif

    if (xdown < xpos) or (ydown < ypos) or (xdown >= xpos+width) or (ydown >= ypos+height) then
        if IsPointInStack(xdown, ydown) then
            return false
        else
            'Touch outside of menu = hide the thing
            DestroyMenu(true, true, false)
        endif
        return true
    endif

    newSel := (ydown - (yPos + 2*borderWidth+1 - (lineHeight-maxLineHeight))) / lineHeight
    if newSel >= 0 and newSel < count then
        if nextMenu <> empty then
            nextMenu.DestroyMenu(false, false, false)
        endif
        selected = newSel
        DoItemSelected()
    endif

    return true
endfunc

private func IsPointInStack (x as integer, y as integer) returns boolean
    dim curMenu as objref G55PopUpMenu
    curMenu := me
    while curMenu.prevMenu <> empty do
        curMenu := curMenu.prevMenu
    loop

    while curMenu <> empty do
        if (x >= curMenu.xPos) and (y >= curMenu.yPos) and ->
           (x < curMenu.xPos+curMenu.width) and (y < curMenu.yPos+curMenu.height) then
            return true
        endif
        curMenu = curMenu.nextMenu
    loop

    return false
endfunc

private func Timetick ()
    handles MSG_TIMETICK

    UnregisterMsgHandler (me, msg_timetick, 0)
    enabled = false
    UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
    '_keySetRecentFocusObject()
    return
endfunc


private func KeyDown (keycode as unibyte) returns boolean
    handles MSG_KEY_DOWN
    if isFocus then
        _KT_Bid(me, myPriority, MsgType_KeyDown)
    endif
    return false
endfunc
private func KeyPress (keycode as unibyte) returns boolean
    handles MSG_KEY_PRESS
    if isFocus then
        _KT_Bid(me, myPriority, MsgType_KeyPress)
    endif
    return false
endfunc
private func KeyRelease (keycode as unibyte) returns boolean
    handles MSG_KEY_RELEASE
    if isFocus then
        _KT_Bid(me, myPriority, MsgType_KeyRelease)
    endif
    return false
endfunc

private func BidWon(ktype as integer) returns boolean
    handles MSG_KT_BIDWON
    dim selitem, i as integer
    dim hotstr as charstr
    if ktype <> 1 then
        return true
    endif
    ' check if direction to change focus
    if _kt_keyID == KEY_DOWNARROW then
        selected = selected + 1
        if selected > count-1 then
            selected = 0
        endif
    elseif _kt_keyID == KEY_UPARROW then
        selected = selected - 1
        if selected < 0 then
            selected = count-1
        endif
    elseif _kt_keyID == KEY_RIGHTARROW then
        if prevMenu <> empty then
            if prevMenu.xPos > xPos then
                _KeySetFocus(prevMenu, false)
                enabled = false
                return true
            endif
        endif
        if subMenus[selected] <> empty then
            DoItemSelected()
        else
            Cancel()
            UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
            '_keySetRecentFocusObject()
        endif
    elseif _kt_keyID == KEY_LEFTARROW then
        if prevMenu <> empty then
            if prevMenu.xPos <= xPos then
                _KeySetFocus(prevMenu, false)
                enabled = false
            endif
        else
            Cancel()
            UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
            '_keySetRecentFocusObject()
        endif
    elseif _kt_keyID == KEY_ESCAPE or _kt_keyID == KEY_DELETE or _kt_keyID == KEY_BACKSPACE then
        if prevMenu <> empty then
            _KeySetFocus(prevMenu, false)
            enabled = false
        else
            Cancel()
            UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
            '_keySetRecentFocusObject()
        endif
    else
        if _kt_keyID == KEY_ENTER or _kt_keyID == KEY_SPACE then
            selitem = selected
        else
            'check if hotkey pressed
            hotStr := " "
            for i = 0 to len(hotchars)-1
                hotStr[0] := hotChars[i]
                if hotStr == _kt_keyString then
                    selected = i
                    DoItemSelected()
                    return true
                endif
            next
            'check if number hotkey was pressed
            check error
                val(selitem, _charStrToStr(_kt_KeyString))
                selitem := selitem -1
            on error
                _clearException()
                return true
            enderr
        endif

        if selitem >= 0 and selitem < count then
            selected = selitem
            DoItemSelected()
        endif
    endif
    return true
endfunc

private func calcFocusChange(stat as integer) returns boolean
    handles MSG_CALCFOCUSCHANGE
    _KeyProcessFocusMessage(me)
    return false
endfunc

'Changes if put in focus
private dim myPriority as integer
init myPriority := _Low_Priority
private dim isFocus as boolean
init isFocus := false
private func isFocus(newval as boolean)
    isFocus := newval
    if isFocus then
        myPriority := _Focus_Priority
        _keyFocusXPos := xPos
        _keyFocusYPos := yPos
        _keyFocusWidth := Width
        _keyFocusHeight := Height
        _keyFocusParent := default
        enabled = true
    else
        myPriority := _Low_Priority
    endif
endfunc

private func gettingFocus(stat as integer) returns boolean
    handles MSG_GETOBJFOCUS
    isFocus = true
    focusOn()
    return true
endfunc

private func losingFocus(stat as integer) returns boolean
    handles MSG_LOSEOBJFOCUS

    isFocus = false
    focusOff()
    return true
endfunc

#doc override focusOn
~Event occurs when the focus is changed to this object.
func focusOn()
    return
endfunc

#doc override focusOff
~Event occurs when the focus is removed from this object.
func focusOff()
    return
endfunc

'The rest of these functions add functionality to the PC development tool.  The
'#if _TOOL line ensures that the code will not be compiled into a BFF that
'is loaded into the terminal

'These functions are called in response to actions taken in the PC development tool.
'If as a result of these actions you change one or more of the properties of
'this object that should be permanently recorded (for instance changing xPos in
'response to MSG_TOOL_MOVE) then you should call Tool_Persist to save the new
'value of the property in your source code of your object instance

#if _TOOL
'This function is called by the PC development tool, when you change the attachment
'of an object (i.e. in response to dragging it around the object tree).
'Note: the purpose of this function is to allow you to attach to another
'container, you should not change your parent property or call Tool_Persist
'until you receive a MSG_TOOL_ATTACHED.  A MSG_TOOL_ATTACHED will be sent
'in response to an Attach API function call.
func ToolAttach (attachTo as objref)
    handles MSG_TOOL_ATTACH
    Attach (me, default)
endfunc

'This function is called when the user drags an object instance with the
'mouse in the PC development tool.  dx and dy are relative offsets from the current
'location of the object
func ToolMove (dx as integer, dy as integer)
    handles MSG_TOOL_MOVE

    xPos := xPos + dx
    yPos := yPos + dy
    Relocate (me, xPos, yPos)

    'Save the changes we just made
    Tool_Persist (xPos)
    Tool_Persist (yPos)
endfunc

'This function is called by the PC development tool to obtain the coordinates of
'the resize grips.  The arrays xCoords, yCoords, and cursors all contain 0
'elements initially.  This means that you should either call redim on those
'arrays and set their values, or declare local arrays, set the values of
'the local arrays, and then assign xCoords, yCoords and cursors to those
'local arrays. Closed indicates whether the Foundry should connect the
'first and last grips to make a closed object.  xCoords, yCoords, and
'cursors should all contain the same number of elements when this function
'completes
func ToolGetHandles (xCoords[] as reference to integer, ->
                     yCoords[] as reference to integer, ->
                     cursors[] as reference to GuiCursors, ->
                     closed as reference to boolean)
    handles MSG_TOOL_GETHANDLES

    dim xhandle[8] as integer
    dim yhandle[8] as integer
    dim cursortype[8] as guicursors

    init cursortype := [csr_none, csr_none, csr_none, csr_none, ->
                        csr_none, csr_none, csr_none, csr_none]

    xhandle[0] = xpos
    yhandle[0] = ypos

    xhandle[1] = xpos + (width-1)/2
    yhandle[1] = ypos

    xhandle[2] = xpos + width-1
    yhandle[2] = ypos


    xhandle[3] = xpos + width-1
    yhandle[3] = ypos + (height-1)/2

    xhandle[4] = xpos + width-1
    yhandle[4] = ypos + height-1

    xhandle[5] = xpos + (width-1)/2
    yhandle[5] = ypos + height-1

    xhandle[6] = xpos
    yhandle[6] = ypos + height-1

    xhandle[7] = xpos
    yhandle[7] = ypos + (height-1)/2

    xcoords = xhandle
    ycoords = yhandle
    cursors = cursortype
    closed = true
endfunc

'This function is called in response to a user moving a resize grip within
'the PC development tool.  handleNum is the index into the arrays that were returned
'by the handler for MSG_TOOL_GETHANDLES.  You should return true from this
'function
func ToolMoveHandle (handleNum as reference to integer, dx as integer, dy as integer)
    handles MSG_TOOL_MOVEHANDLE

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolMoveHandle (handleNum, dx, dy, xPos, yPos, width, height, me)

endfunc

'This function is called when the user created an instance of this template by
'selecting it from the object palette and dragging it in the layout view.
'The handler for MSG_INIT is not called automatically, and if you want it
'called, you should call it manually.
'You should call Tool_Persist on all the properties that you set up in this
'message handler.  (x1, y1) are the coordinates that the user started his
'drag and (x2, y2) are the coordinates that the mouse was released
func ToolDragCreate (parentObj as objref, x1 as integer, y1 as integer, ->
                     x2 as integer, y2 as integer)
    handles MSG_TOOL_DRAGCREATE

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    '_ToolDragCreate (parentObj, x1, y1, x2, y2, xPos, yPos, width, height, parent)
    xPos := x1 + getPosInfo(parentObj, GET_XGLOBAL)
    yPos := y1 + getPosInfo(parentObj, GET_YGLOBAL)

    'Call our MSG_INIT handler
    StartUp()
endfunc

#endif
Enddef
Define Object type GalilCommV2 extends coreCommunication
#ToolImage "FFFFF00FC0038FF13FFD7C7F391F9C47CFF3E007F84FFF9FFF3FFE7FFFFF"
'***********************************************************
'Object:    GalilCommV2
'Version:   2.40
'Author:    Jeremy Richards, Ron Lloyd
'Date:  18 May 2006
'Description:   The core communication object for comm libraries
'
'Copyright 2005 QSI Corporation
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved.
'***********************************************************

'Template is derived from coreCommunication
Library Core source coreCommunication

#doc object GalilCommV2
~This object forms the core of the Galil library.  This object controls
~all interaction between the motion controller and the QTERM-G70.  It is
~capable of communicating with a motion controller either serially or via
~ethernet.  To communicate with a motion controller, create an instance of
~this object and set up its properties as appropriate.  Then create other
~GMC objects and set thier <u>commObject</u> property to refer to this object.
~You can communicate with multiple motion controllers by creating one
~GalilCommunication object per controller.  There is a limit of one controller
~per serial port on the G70 and a limit of 8 ethernet controllers that can be
~used at once.

#doc prop ConnectionType
#category Main
~The value of this property determines how this object will attempt communication
~with the controller.  You can select between Serial, TCP/IP, UDP/IP or no
~communication.  If you attempt to change communication methods while this object is
~attempting to open an ethernet channel to the controller, an error is generated and
~no change in communication is made.  In general, you should set this property
~when designing your workspace and not change it at runtime on the terminal.
dim ConnectionType as GMC_CommMethod
init ConnectionType := GMC_EthernetUDP
func ConnectionType (newVal as GMC_CommMethod)
    'set the inherited commmethod property
    if newval == GMC_UseSerial then
        commMethod = _cc_serial
    elseif newval == GMC_EthernetUDP then
        commMethod = _cc_UDP
    elseif newval == gmc_ethernettcp then
        commmethod = _cc_TCP
    endif
    'set the connectiontype as appriopriate making sure it matches commmethod
    if commmethod == _cc_serial then
        connectiontype := GMC_UseSerial
        VerifyCurPortSettings()
    elseif commmethod == _cc_TCP then
        connectiontype := GMC_EthernetTCP
    elseif commmethod == _cc_UDP then
        connectiontype := GMC_EthernetUDP
    endif
    if newval == GMC_None then
        connectiontype := GMC_None
    endif
    #IF _TOOL
    if newval <> connectionType then
        tool_persist(connectionType)
    endif
    #ENDIF
    ClearMessages()
endfunc

private func ClearMessages()
    StopMessage(1)
    StopMessage(2)
    StopMessage(3)
endfunc

#doc prop serialFormat
#category Main
~This property determines the serial format that is used for communication with the motion
~controller.  Select the format that the motion controller is using to ensure proper communcation.
~This property is ignored if <u>UseEthernet</u> is anything except GMC_UseSerial.
dim SerialFormat as GMC_SerialFormat
init SerialFormat := GMC_19200_RTS_CTS
func SerialFormat (newVal as GMC_SerialFormat)
    SerialFormat := newVAl
    if ConnectionType == GMC_UseSerial then
        VerifyCurPortSettings()
    endif
endfunc

#doc prop maxRetries
#category Main
~If the motion controller fails to respond to a command, the communications object can attempt
~to retry the command.  Generally the motion controller will only fail to respond if it
~is extremely busy or there is a communications problem.  As many commands tell the controller
~to perform some action and can cause problems if they are resent, the default number of retries
~is zero.  You may increase the number of retries if your application only uses query commands.
~<br><br>Note:  This property only applies if you are using GMC_UseSerial or GMC_EthernetUDP
~as your communication method.  This property is ignored for TCP communication as the
~TCP/IP protocol automatically retries.
dim MaxRetries as integer
init maxRetries := 0

#doc prop timeout
#category Main
~<u>timeout</u> defines how long (in milliseconds) this object will wait for a response from
~the controller before it decides that there has been a communications failure.  If the
~timeout elapses without receiving a response from the terminal, then the data is considered
~lost and is retried if <u>maxRetries</u> is non-zero.
~<br><br>Note:  This property takes on special meaning if you are using TCP communication.  TCP
~automatically retries dropped or corrupt packets.  Because of this, when using TCP, the minimum
~allowed TCP timeout is 15 seconds.  If the object 'times out' while wating for a response from
~the Galil controller while using TCP, it will close the connection and attempt to open a new one.
~(This is the only safe way of handling the issue).
dim timeout as integer
init timeout := 3000
func timeout (newVal as integer)
    if connectiontype == GMC_EthernetTCP then
        if newVal < 15000 then
            newVal := 15000
        endif
    endif

    timeout := newVal
    timeoutCounts := newVal / 500 '# of half second ticks
endfunc

#doc prop unsolicitedAware
#category Main
~This property determines whether this object will watch for unsolicited messages from the
~controller.  If this value is true, then all data returned from the controller is examined
~for unsolicited messages (i.e. data returned from the controller that was not requested by
~this terminal.  Examples include "MG" commands in the program executing on the controller).
~When unsolicited messages are detected, the <U>UnsolicitedMessageReceived</U> event is
~generated.  You can handle this event to examine incomming unsolicited messages.<BR><BR>
~If this property is false, then this object does not watch for unsolicited messages.  Setting
~this property to false will generally lead to improved performance on the terminal, however,
~if an unsolicited message is sent, then a communications error will occur.  Set this property
~to false if you want better performance on the terminal and know that the controller will not
~send unsolicited messages.
dim unsolicitedAware as boolean
init unsolicitedAware := true

private dim state as coreCommStates
init state := _cc_NotConnected

func GetStateString() returns string
    if state == _cc_Connected then
        return "Galil connected"
    else
        return "Galil Not connected"
    endif
endfunc

private dim noNegotiationPhase as boolean
init noNegotiationPhase := false

protected func Startup ()
    handles MSG_INIT

    VerifyCurPortSettings()
    connectionType(connectionType)
    default ()
    RegisterMsghandler (me, MSG_TIMETICK, 25) 'Timeout ticks every 1/2 second

    timeout(timeout)

    if GMC_DefaultGalilCommV2 == empty then
        GMC_DefaultGalilCommV2 := me
        #if _Tool Tool_Persist (GMC_DefaultGalilCommV2) #endif
    endif
endfunc

private dim port as integer
init port := 51987
private func port (newVal as integer)
    default (newVal)
endfunc

private func StateChanged ()
'debugEB.appendText = str(me) + ".StateChanged = " + str(state) + "\n"
    if state == _cc_negotiating then
        'if this was a reconnect start sending packets again.
        if awaitingResponse then
            ReleasePendingPackets()
            awaitingResponse := false
        endif

        'Clear any displaying message
        ClearMessages()

        RegisterMsgHandler(me, msg_comm_receive, commchannel)

        StartNegotiation()
    elseif state == _cc_NotConnected then
        comBuf := ""
        if connectionType == GMC_EthernetTCP then
            OpenChannel()
        endif
    endif

    default ()
endfunc

private func StartNegotiation()
    if connectionType == GMC_UseSerial then
        'Turn echo off.  Set the unsolicited bits high
        SendAsciiCommandStream("TC;CW1;EO0;", me, 0) 'TC is a spurious command to deal with the bad
                                                     'char that is transmitted upon bootup
    else
        'Turn echo off.  Set the unsolicited bits high
        SendAsciiCommandStream ("CW1;EO0;", me, 0)
    endif
endfunc

'this is sent when a response is sent from the galil on initial msg.
private func Success(parm as integer) returns boolean
    handles GMC_CommSuccess
'debugEB.appendText = str(me) + " command success\n"
    NegotiationComplete()
    return true
endfunc
private func Failure(parm as integer) returns boolean
    handles GMC_CommFailure
'debugEB.appendText = str(me) + " command failed\n"
    StartNegotiation()
    return true
endfunc

private func ReleasePendingPackets()
    dim i, loopterm as integer

    'release pending packets
    loopTerm := (pendingPktTail + 1) mod GMC_MaxPendingStreams
    i := tailIdx
    curFailureReason := GMC_FailCommunications
    curResponse := ""
    while i <> loopTerm do
        UserDirectMsg (notify[i], GMC_CommFailure, notifyCodes[i], true)
        i := (i+1) mod GMC_MaxPendingStreams
    loop
    xmitbuf := mid (xmitBuf, pendingPktLen, -1)
    tailIdx := (pendingPktTail + 1) mod GMC_MaxPendingStreams
endfunc

private func VerifyCurPortSettings ()
    dim baud as syscmd_baud
    dim flow as syscmd_flowcontrol

    if SerialFormat == GMC_19200_RTS_CTS then
        baud := baud_19200
        flow := flowcontrol_rts_cts
    elseif SerialFormat == GMC_9600_RTS_CTS then
        baud := baud_9600
        flow := flowcontrol_rts_cts
    elseif SerialFormat == GMC_1200_RTS_CTS then
        baud := baud_1200
        flow := flowcontrol_rts_cts
    elseif SerialFormat == GMC_19200_NOFLOW then
        baud := baud_19200
        flow := flowcontrol_none
    elseif SerialFormat == GMC_9600_NOFLOW then
        baud := baud_9600
        flow := flowcontrol_none
    elseif SerialFormat == GMC_1200_NOFLOW then
        baud := baud_1200
        flow := flowcontrol_none
    elseif SerialFormat <> GMC_USE_DEFAULT then
        throw (str(me), "Invalid serial format setting")
    endif

    if SerialFormat == GMC_USE_DEFAULT then
        'Set the timeout
        if (serialPort == com1) or (serialPort == com2) then
            SetSerialTimeout (serialPort, 1)
        endif
    else
        VerifyComSettings (serialPort, baud, flow)
    endif
endfunc

private func VerifyComSettings (port as comm, baud as syscmd_Baud, flow as syscmd_flowcontrol)
    dim dbits as syscmd_databits
    dim sbits as syscmd_stopbits
    dim parity as syscmd_parity
    dim baudCur as syscmd_baud
    dim flowCur as syscmd_flowcontrol

    dim bc, dbc, pc, sbc, fc as syscmd

    if port == com1 then
        bc := sys_com1baud
        dbc := sys_com1databits
        pc := sys_com1parity
        sbc := sys_com1stopbits
        fc := sys_com1flowcontrol
    elseif port == com2 then
        bc := sys_com2baud
        dbc := sys_com2databits
        pc := sys_com2parity
        sbc := sys_com2stopbits
        fc := sys_com2flowcontrol
    endif

    #ifnot _TOOL 'Don't set the settings in layout view
    'Check each serial port paramater and set as appropriate
    GetsystemSetting (bc, baudCur, sysread_current)
    if baudCur <> baud then
        SetSystemSetting (bc, baud, SYSACT_DONOW)
    endif

    GetSystemSetting (fc, flowCur, sysread_current)
    if flowCur <> flow then
        SetSystemSetting (fc, flow, SYSACT_DONOW)
    endif

    GetSystemSetting (dbc, dbits, sysread_current)
    if dbits <> databits_8 then
        SetSystemSetting (dbc, databits_8, SYSACT_DONOW)
    endif

    GetSystemSetting (pc, parity, sysread_current)
    if parity <> parity_none then
        SetSystemSetting (pc, parity_none, SYSACT_DONOW)
    endif

    GetSystemSetting (sbc, sbits, sysread_current)
    if sbits <> stopbits_1 then
        SetSystemSetting (sbc, stopbits_1, SYSACT_DONOW)
    endif

    'Set the timeout
    if (port == com1) or (port == com2) then
        SetSerialTimeout (port, 1)
    endif

    #endif
endfunc

private dim comBuf[] as byte
private func CommReceive (data[] as byte) returns boolean
    handles MSG_COMM_RECEIVE

    dim pos1, pos2 as integer


    'Special handling of suspended data
    if suspended then
        if not awaitingsuspense then
            suspendedRecv := data
            userDirectMsg (suspendNotify, GMC_SuspendCommReceive, suspendNotifyParm, true)
            return true
        endif
    endif

    if unsolicitedAware then
        ParseForUnsolicitedMessages (data)
    else
        comBuf := concat (comBuf, data)
    endif

    label top
    pos1 := find (comBuf, 0, -1, GMC_TermStr)
    if pos1 > 0 then
        pos2 := find (combuf, pos1, -1, ":")
        if pos2 > 0 then ' we found a complete response
            Parse (left (combuf, pos1))
            combuf := mid(combuf, pos2+1, -1)
            'goto top
        endif
    endif

    return true
endfunc

private dim commMethod as coreCommTypes
private func commMethod(newVal as coreCommTypes)
    default (newVal)
endfunc

#doc prop curResponse
~This property contains the most recent response from the controller.  It is guarenteed to be
~valid during a GMC_CommSuccess message.  At any other time the value of this property
~may not be valid.  It is the responsibility of the object that recieves the GMC_CommSuccess
~to parse the response appropriately
#hidden dim curResponse as string
private dim recvCmdBrks[GMC_MaxTxLen] as integer

#hidden dim curFailureReason as GMC_FailureReason

private func Parse(data[] as byte)
    dim cpos, qpos, oldPos as unibyte
    dim count as integer
    dim i, loopTerm, brkIdx, oldBrkIdx as integer
    dim errs[] as integer
    dim errorExists as boolean
    cpos := find (data, 0, -1, ":")
    qpos := find (data, 0, -1, "?")

    count = 1
    recvCmdBrks[0] := -1
    while (cPos < 65535) or (qPos < 65535) do
        if cPos < qPos then
            recvCmdBrks[count] := cPos
            count := count + 1
            oldPos := cPos+1
            cPos := find (data, oldPos, -1, ":") 'No need to find question
        else
            recvCmdBrks[count] := qPos

            'note that an error occured
            redim (errs, len(errs)+1)
            errs[len(errs)-1] := count
            errorExists := true

            count := count + 1
            oldPos := qPos+1
            qPos := find (data, oldPos, -1, "?") 'No need to find colon
        endif
    loop


    'Note the (count - 1) is because we started the count at one.  We started the
    'count at one because parsing the data for curResponse out is easier when we do
    if pendingCmdCount <> count - 1 then
        Retransmit("Unexpected controller response")
    else
        loopTerm := (pendingPktTail + 1) mod GMC_MaxPendingStreams
        i := tailIdx
        brkIdx := 0
        oldBrkIdx := 0
        if not errorExists then
            'slightly faster loop for the common case of no errors!
            while i <> loopTerm do
                brkIdx := brkIdx + cmdCount[i]
                curResponse := mid(data, recvCmdBrks[oldBrkIdx]+1, recvCmdBrks[brkIdx] - recvCmdBrks[oldBrkIdx]-1)
                UserDirectMsg (notify[i], GMC_CommSuccess, notifyCodes[i], true)
'debugEB.appendText = "Sending success message to " + str(notify[i]) + "\n"
                i := (i+1) mod GMC_MaxPendingStreams
                oldBrkIdx := brkIdx
            loop
        else
            'slower loop where we have to see what errors exist and what to do about it!
            cpos := 0 'reuse cpos as an array index
            redim (errs, len(errs)+1) 'give ourselves an extra padding index
            while i <> loopTerm do
                brkIdx := brkIdx + cmdCount[i]
                curResponse := mid(data, recvCmdBrks[oldBrkIdx]+1, recvCmdBrks[brkIdx] - recvCmdBrks[oldBrkIdx]-1)
                if (oldBrkIdx+1 <= errs[cPos]) and (brkIdx >= errs[cPos]) then 'this command stream contained the error
                    curFailureReason := GMC_FailBadCommand
                    UserDirectMsg (notify[i], GMC_CommFailure, notifyCodes[i], true)
                    cPos := cPos + 1
                    DisplayMessage(_cc_Protocol, 1, _strToCharstr(str(notify[i])+": Bad command"), 40000)
'debugEB.appendText = "Sending fail message to " + str(notify[i]) + "\n"
                else
                    UserDirectMsg (notify[i], GMC_CommSuccess, notifyCodes[i], true)
'debugEB.appendText = "Sending success message to " + str(notify[i]) + "\n"
                endif
                i := (i+1) mod GMC_MaxPendingStreams
                oldBrkIdx := brkIdx
            loop
        endif
        ClearPendingPktInfo()
    endif
endfunc

private func ReceiveFail()
    dim i, loopTerm as integer

    loopTerm := (pendingPktTail + 1) mod GMC_MaxPendingStreams
    i := tailIdx
    curFailureReason := GMC_FailCommunications
    curResponse := ""
    while i <> loopTerm do
        UserDirectMsg (notify[i], GMC_CommFailure, notifyCodes[i], true)
        i := (i+1) mod GMC_MaxPendingStreams
    loop
    ClearPendingPktInfo()
endfunc

private func ClearPendingPktInfo()
    if awaitingResponse then
        awaitingResponse := false
        xmitbuf := mid (xmitBuf, pendingPktLen, -1)
        tailIdx := (pendingPktTail + 1) mod GMC_MaxPendingStreams
    endif
    TransmitStream()
endfunc

private dim xmitBuf[] as byte
private dim lengths[GMC_MaxPendingStreams] as integer
private dim cmdCount[GMC_MaxPendingStreams] as integer
private dim notify[GMC_MaxPendingStreams] as objref
private dim notifyCodes[GMC_MaxPendingStreams] as integer
private dim headIdx as integer
private dim tailIdx as integer

#doc func SendAsciiCommandStream
~Use this command to send an arbitrary stream of commands to the controller.  When the
~controller has responed, this object will send a GMC_CommSuccess or a GMC_CommFailure
~message to the notifyObj with the notifyCode as the paramater.
#param stream: A semicolon separated list of commands to send to a Galil motion controller
#param notifyObj:The object that will receive notification once the controller has responeded to the commands
#param notifyCode:This value will be sent to the <u>notifyObj</u> in the notification message.  It is primarily useful for objects that may poll different values at different times so that it can differenciate to which query it is receiving a response.
func SendAsciiCommandStream(stream[] as byte, notifyObj as objref, notifyCode as integer) returns boolean
    return SendAsciiCommandStreamCounted (stream, notifyObj, notifyCode, GMC_CountCommands(stream))
endfunc

#doc func SendAsciiCommandStreamCounted
~Use this command to send an arbitrary stream of commands to the controller.  When the
~controller has responed, this object will send a GMC_CommSuccess or a GMC_CommFailure
~message to the notifyObj with the notifyCode as the paramater.  This function is
~faster than <u>SendAsciiCommandStream</u>.  Call this function if you know exactly
~how many commands are in <u>stream</u>.  You generally do that by calling the global function
~<u>GMC_CountCommands</u>.
#param stream: A semicolon separated list of commands to send to a Galil motion controller
#param notifyObj:The object that will receive notification once the controller has responeded to the commands
#param notifyCode:This value will be sent to the <u>notifyObj</u> in the notification message.  It is primarily useful for objects that may poll different values at different times so that it can differenciate to which query it is receiving a response.
#param count:The number of commands in the command stream.  This value must correctly identify the number of commands in the stream, or a communications failure will occur.  You can obtain the proper value by calling <u>GMC_CountCommands</u> on your stream of commands.
func SendAsciiCommandStreamCounted (stream[] as byte, notifyObj as objref, ->
                            notifyCode as integer, count as integer) returns boolean
    dim strLen as integer
    dim nextHeadIdx as integer

    'Cannot transmit if using no comm method
    if connectiontype == GMC_None then
        return false
    endif

    nextHeadIdx := (headIdx + 1) mod GMC_MaxPendingStreams
    strlen = len(stream)
    if len(stream) >= GMC_MaxTxLen then
        return false
    elseif (strlen <= 0) or (nextHeadIdx == tailIdx) then
        return false
    endif

    ' Add terminator if necessary
    if stream[strlen-1] <> ';' then
        stream := stream + ";"
        strLen := strLen + 1
    endif

    xmitBuf := concat(xMitBuf, stream)
    lengths[headIdx] := strLen
    cmdCount[headIdx] := count
    notify[headIdx] := notifyObj
    notifyCodes[headIdx] := notifyCode
    headIdx := nextHeadIdx

    TransmitStream()

    return true
endfunc

private dim awaitingResponse as boolean
private dim pendingPktTail as integer
private dim pendingPktLen as integer
private dim pendingPktTimeIdx as integer
private dim pendingRetries as integer
private dim pendingCmdCount as integer
private dim curTimeIdx as integer
private dim timeoutCounts as integer
private dim isVisible as boolean
init isVisible := false
private dim visMessage as string
private dim visTimeIdx as integer

private func TransmitStream ()
    dim sum, prevSum as integer
    dim prevTail as integer
    dim curTail as integer
    dim cmdSum, prevCmdSum as integer

    'Reasons why we might not be able to transmit
    if state <> _cc_Connected and state <> _cc_negotiating then
        return
    endif
    if awaitingResponse then
        return  'Currently waiting for a response.
    endif
    if suspended then
        'Are we suspended for special communications?
        if awaitingSuspense then
            awaitingSuspense := false
            UserDirectMsg (suspendNotify, GMC_SuspendSuccessNotify, suspendNotifyParm, false)
        endif
        return
    endif
    if headIdx == tailIdx then 'Nothing to transmit
        return
    endif

    curTail := tailIdx
    sum := lengths[curTail]
    cmdSum := cmdCount[curTail]
    do
        prevTail := curTail
        prevSum := sum
        prevCmdSum := cmdSum

        curTail := (curTail + 1) mod GMC_MaxPendingStreams
        sum := sum + lengths[curTail]
        cmdSum := cmdSum + cmdCount[curTail]

    loop while (curTail <> headIdx) and (sum < GMC_MaxTxLen)



    'Since the loop always takes us one iteration too far, use prevTail and prevSum
    awaitingResponse := true

    transmit (commChannel, left(xmitBuf, prevSum) + GMC_SpecialTerm, false)
    pendingPktTail := prevTail
    pendingPktLen := prevSum
    pendingRetries := 0
    pendingPktTimeIdx := curTimeIdx
    pendingCmdCount := prevCmdSum
endfunc

private func Retransmit (reason as string)
    if connectiontype == GMC_EthernetTCP then
        return 'No Retry on TCP
    endif

    pendingRetries := pendingRetries + 1

    if pendingRetries > maxRetries then
        DisplayMessage(_cc_Communication, 2, _strToCharstr(reason), 40000)
        ReceiveFail()
    else
        transmit (commChannel, left(xmitBuf, pendingPktLen) + GMC_SpecialTerm, false)
        pendingPkttimeIdx := curTimeIdx
        DisplayMessage(_cc_Communication, 2, _strToCharstr(reason + ":  Retry " + str(pendingRetries) + " / " + str(maxRetries)), 40000)
    endif
endfunc

private func Timetick ()
    handles MSG_TIMETICK

    curTimeIdx := curTimeIdx + 1
    if awaitingResponse then
'debugEB.appendText = str(me) + " timeout\n"
        if curTimeIdx >= pendingPktTimeIdx + timeoutCounts then
            if connectiontype <> GMC_EthernetTCP then
                Retransmit("Response Timeout")
            else
                'TCP only -- close the connection and reopen
                DisplayMessage(_cc_communication, 3, "TCP communication timeout: Reconnecting", 3 * 60 * 1000)
                ReceiveFail()
                CloseChannel()
                OpenChannel()
            endif
        endif
    endif
endfunc

private func ParseForUnsolicitedMessages(data[] as byte)
    'This function will update comBuf with the solicited portion of the message.
    'Unsolicited portions will be added to unsolicitedBuf.  The UnsolicitedMessageReceived
    'event will be called if a complete message is received

    dim i, max as integer
    dim oldPos as integer
    dim state, oldState as boolean

    max = len(data)-1

    for i = 0 to max
        state := ( (data[i] and byte(0x80)) <> 0)
        if state <> oldState then
            if oldState then
                AddUnsolicited (mid (data, oldPos, i-oldPos), i-oldPos-1)
            else
                comBuf := comBuf+ mid(data, oldPos, i-oldPos)
            endif
            oldState := state
            oldPos := i
        endif
    next

    'Now add remainder
    if state then
        AddUnsolicited (mid (data, oldPos, i-oldPos), i-oldPos-1)
    else
        comBuf := comBuf+ mid(data, oldPos, i-oldPos)
    endif
endfunc

private func AddUnsolicited (data[] as byte, leng as integer)
    dim i as integer
    dim p1, p2, oldPos as unibyte

    for i = 0 to leng
        data[i] := data[i] and byte(0x7F)
    next
    UnsolicitedMessageReceived(data)
endfunc

#doc override UnsolicitedMessageReceived
#param msg:This is the text of the unsolicited message.
~This event is called whenever unsolicited messages are received from the controller.  The
~<u>msg</u> paramater contains the actual message.  Unsolicited messages are NOT parsed
~for content, but rather are given immediately to this funciton.  This means that the user
~is responsible for parsing the message.  It is possible that two unsolicited messages may
~be passed to this event at once.  It is also possible that a single unsolicited message may
~be split in to two calls to this event.
func UnsolicitedMessageReceived(msg as string)
    return
endfunc

private dim suspended, awaitingSuspense as boolean
private dim suspendNotify as objref
private dim suspendNotifyParm as integer

#doc prop suspendedRecv
~This property holds the most recent bit of data received by this object once it has been
~suspended.
#hidden dim suspendedRecv[] as byte

#doc func SuspendCommunications
~This function is intended for internal use by advanced GMC objects.  Do not use it, unless
~you are implementing a special object that has special communication needs.<BR><BR>
~This function breaks off normal communication with the motion controller.  Communication
~requests are queued, until communications are resumed.  This function returns true if
~the request has been successfully processed, however, you <B>MUST NOT</b> assume that the
~communications have actually been suspended until the object indicated by the <u>notify</u>
~paramater has received the GMC_SuspendSuccessNotify message.<BR><BR>
~Once this object has been suspended, any incomming serial data will be stored in the property
~<u>suspendedRecv</u> and <u>notify</u> will be informed of the data reception via a
~GMC_SuspendCommReceive message.
#param notify:Indicates the object that requested the suspension.  This object will receive the GMC_SuspendSuccessNotify message once the suspension has taken effect
#param parm:This value will be passed to <u>notify</u> as the paramater to the GMC_SuspendSuccessNotify message.
func SuspendCommunications(notify as objref, parm as integer) returns boolean
    if state <> _cc_Connected then
        return false
    endif
    suspended := true
    awaitingSuspense := true
    suspendNotify := notify
    suspendNotifyParm := parm
    TransmitStream()
    return true
endfunc

#doc func ResumeCommunications
~This function is intended for internal use by advanced GMC objects.  Do not use it, unless
~you are implementing a special object that has special communication needs.<BR><BR>
~This function resumes normal communications after the communications had been suspended
func ResumeCommunications()
    suspended := false
    awaitingSuspense := false
    suspendNotify := empty
    suspendNotifyParm := 0
    TransmitStream()
endfunc

#doc func IsSuspended
~This function is intended for internal use by advanced GMC objects.  Do not use it, unless
~you are implementing a special object that has special communication needs.<BR><BR>
~This function returns true if communications are currently suspended, false otherwise.
func IsSuspended() returns boolean
    return (suspended) and (not awaitingSuspense)
endfunc

#doc func SuspendTransmit
~This function is intended for internal use by advanced GMC objects.  Do not use it, unless
~you are implementing a special object that has special communication needs.<BR><BR>
~This function is used to perform a special transmission when communications are suspended with
~the motion controller.  This can only be used when communication is suspended.  It will return
~false if communication is not suspended.  Otherwise it transmits the data and returns true.
#param data:This data will be transmitted to the controller without respect of formatting.  As the communications object does not examine this data, it will not expect a response of any sort from the controller.
func SuspendTransmit (data[] as byte) returns boolean
    if (not suspended) or (awaitingSuspense) then
        return false
    endif

    if state <> _cc_Connected then
        return false
    endif

    transmit (commChannel, data, false)

    return true
endfunc
Enddef
Define Area Object type GMCPollV2 extends coreLabel
#ToolImage "80013FFC40025FFA58FA577A577A577A587A5FBA5FDA5FFA40023FFC8001"
'*******************************************************************
'Object:        GMCPollV2
'Author:        Ron Lloyd
'Date:          23 Dec 2008
'
'Description:   Display simple text strings, with style, multiline options
'
'Version:       2.40
'Version History:
'
'Copyright 2005 QSI Corporation
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved
'*******************************************************************

#doc object GMCPollV2
#defaultitem prop command
#defaultitem func responsereceived
~This object polls the controller with an arbitrary command at regular
~intervals.  It then displays the controller's response.  It is useful
~for displaying values that will change over time, such as the motor
~position.  Many properties are provided which contorol the appearance
~of this object, the polling frequency and what is being polled.
~<BR><BR>Note:  To enhance performance, this object will only
~poll the controller when it is visible (enabled).

'Template is derived from coreLabel
Library Core source coreLabel
Library Galil_mcV2 source GalilCommV2

dim enabled as boolean
func enabled(newval as boolean)
    default (newval)
    zenabled(GetEnableInfo(me, GET_ZENABLED))
endfunc
protected func ZEnabled(status as boolean)
    handles MSG_ZENABLED
    if GetEnableInfo(me, GET_ENABLED) and status then
        timetick()
    endif
endfunc

#doc prop commObject
~<u>commObject</u> defines which GalilCommV2 object will be used to communicate with
~the controller.  You should create one GalilCommV2 object for each motion controller
~you wish to communicate with.  By setting the commObject property, you can control wich
~motion controller this object communicates with.<br><br>Most projects will require only
~one GalilCommV2 object, and this property will automatically be set to refer to that
~communication object.
dim commObject as objref GalilCommV2
init commObject := empty

#doc prop command
~<u>command</u> defines the command (or series of commands) to execute on the controller
~when this button is pressed.  This property can be set to any valid command, or any
~semicolon delimited series of commands.  Refer to the Command Reference Manual for your
~controller for a list of valid commands.
dim command as string
init command := "TPX"
func command (newVal as string)
    command := newVal
    commandCount := GMC_CountCommands (command)
endfunc
private dim commandCount as integer

#doc prop updatePeriod
#category Main
~<u>UpdatePeriod</u> defines, in milliseconds, then amount of time that will elapse between
~polls to the controller.  The minimum supported value is 40 ms.  It is recommended that you
~use the highest possible value for this property as excessive polling will reduce the
~responsiveness of the terminal.  Also, you may want to limit the total number of polling
~objects that can be visible (enabled) at once in order to enhance performance.<BR><BR>
~In order to maximize performance, if this object, or the screen on which it resides is
~disabled, then it will cease polling.  Once the object (or parent screen) is re-enabled,
~it will immediately poll the controller once to refresh its value, then resume normal polling.
dim updatePeriod as integer
init updatePeriod := 1000
func updatePeriod (newval as integer)
    updatePeriod := newval
    _ProcessGMCUpdatePeriod(updatePeriod, me)
    if updatePeriod > 0 and enabled then
        timetick()
    endif
endfunc

func StartUp()
    handles MSG_INIT
    Command(command)
    _ProcessGMCUpdatePeriod(updatePeriod, me)
    GMC_VerifyGalilCommV2(commObject)
    default ()
endfunc


'queryPending will be true when waiting for a reply from the controller
'with the new query information
private dim queryPending as boolean

private func Timetick ()
    handles MSG_TIMETICK
    dim isFail as boolean

    if commObject == empty then
        unregisterMsgHandler(me, MSG_TIMETICK, 0)
        throw(str(me), "Failed query; commObject property is empty.")
        return
    endif
    if queryPending then
        return
    endif

    isFail := !commObject.SendAsciiCommandStreamCounted(command, me, 0, 1)

    if isFail then
        return
    endif
    queryPending := true
    return
endfunc

private func Success(parm as integer) returns boolean
    handles GMC_CommSuccess
    queryPending := false
'    value = _strToCharstr(trim(commobject.curResponse))
    ResponseReceived(commobject.curResponse)
    return true
endfunc

private func Failure(parm as integer) returns boolean
    handles GMC_CommFailure
    queryPending := false
    FailureReceived(commObject.curResponse, commObject.curFailureReason)
    return true
endfunc

#IF _TOOL
func ToolDragCreate (parentObj as objref, x1 as integer, y1 as integer, ->
                     x2 as integer, y2 as integer)
    handles MSG_TOOL_DRAGCREATE

    GMC_VerifyGalilCommV2(commObject)
    default (parentObj, x1, y1, x2, y2)
endfunc
#ENDIF

#doc override ResponseReceived
#param response:The data returned from the controller.  You may modify this paramater for formatting reasons.  Any changes to this paramater will be reflected in the final display.
~This event called whenever this object receives receives a response from the controller as a
~result of a poll.  The paramater <u>response</u> contains the string that was returned from
~the controller.  You may modify <u>response</u> in order to change the final string which
~will be displayed in this object.
func ResponseReceived (response as reference to string)
    return
endfunc

#doc override FailureReceived
#param response:The response returned by the controller minus the final colon terminator.  If you modify this paramater, the final display will reflect the results of the modifications
#param failReason:The reason why this event is generated.   Either GMC_FailCommunications or GMC_FailBadCommand
~This event is triggered when a command has been sent to the controller, but the controller
~failed to respond, responded incorrectly, or returned an error response.
func FailureReceived(response as reference to string, failReason as GMC_FailureReason)
    return
endfunc

func Draw()
    handles MSG_DRAW
    return
endfunc
Enddef
Define Area Object type LabelV2
#ToolImage "FFFFFFFFFFFFFFFFFFFCFFFFFFF4BFFFFFF07FFFFFD92FFFFFCE1FFFFFCF4BFFFF6F87FFFF0002FFFF3FD1FFFDBFE0BFF03FC03FFFFFFFFFFFFFFFFF"
'*******************************************************************
'Object:        LabelV2
'Author:        Jeremy Richards
'Date:          01 Oct 2009
'
'Description:   Display simple text strings
'
'Version:       2.30.1
'Version History:
'2.30.1 In the ToolDragCreate function I changed the ArrayOperation(..) call
'to a _strToCharstr for initializing value to avoid calling value's validation
'function unnecessarily.
'
'Copyright 2004 QSI Corporation
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved
'*******************************************************************
#doc object LabelV2
#defaultitem prop value
#defaultitem func
~This is the standard object for displaying text.  It displays a text value in the colors
~and format specified by the properties of this object.  It is often used to describe objects
~that otherwise do not display text or whose meanings may need clarification.

library standard source _3DColors
library basic source TextConstants
library basic source StandardStyles
library standard source formatfunctions
library standard source ToolMessages
library basic source ColorStyleMapSupport

dim enabled as boolean
init enabled := true
func enabled(newval as boolean)
    enabled := newval
    Enable (me, enabled)
endfunc

dim parent as objref
init parent := default
func parent(newval as objref)
    parent := newval
    Attach(me, parent)
endfunc

dim xPos as integer
init xPos := 0
func xPos(newval as integer)
    xPos := newVal
    Relocate (me, xPos, yPos)
    Recalc()
endfunc

dim yPos as integer
init yPos := 0
func yPos(newval as integer)
    yPos := newval
    Relocate (me, xPos, yPos)
    Recalc()
endfunc

dim width as integer
init width := 25
func width(newval as integer)
    width := newval
    ValidRange()
    Resize (me, width, height)
    Recalc()
endfunc

dim height as integer
init height := 25
func height(newval as integer)
    height := newval
    ValidRange()
    Resize (me, width, height)
    Recalc()
endfunc

#doc prop value
#category Main
~The text value to be displayed in the label.
dim value as charstr
init value := "value"
func value (newVal as charstr)
    if value == newVal then
        return
    endif
    value := newVal
    Recalc()
endfunc

dim font as sysfont
init font := default
func font(newVal as sysfont)
    font := newVal
    Recalc()
endfunc

dim ptSize as integer
init ptSize := 10
func ptSize (newVal as integer)
    ptSize := newVal
    Recalc()
endfunc

dim borderStyle as stylemap%
init borderStyle := Bdr_LabelBorder
func borderStyle (newVal as stylemap%)
    borderStyle := newVal
    Recalc()
endfunc

dim xJustify as HJustifyFlags
init xJustify := HJustify_Center
func xJustify (newVal as HJustifyFlags)
    xJustify := newVal
    Recalc()
endfunc

dim yJustify as VJustifyFlags
init yJustify := VJustify_Center
func yJustify (newVal as VJustifyFlags)
    yJustify := newVal
    Recalc()
endfunc

#doc prop xInset
#category Text Settings
~This property defines how close the text may approach the left and right borders of this
~object.  If it is often undesirable to have text that is flush with the borders of the object,
~then set this property to be > 0.
dim xInset as integer
init xInset := 1
func xInset(newVal as integer)
    xInset := newVal
    Recalc()
endfunc

#doc prop yInset
#category Text Settings
~This property defines how close the text may approach the top and bottom borders of this
~object.  If it is often undesirable to have text that is flush with the borders of the object,
~then set this property to be > 0.
dim yInset as integer
init yInset := 0
func yInset(newVal as integer)
    yInset := newVal
    Recalc()
endfunc

dim fgColor as colormap%
init fgColor := Clr_LabelForeground
func fgColor (newVal as colormap%)
    fgColor := newVal
    Rerender(me)
endfunc

dim bgColor as colormap%
init bgColor := Clr_LabelBackground
func bgColor (newVal as colormap%)
    if bgcolor == newVal then
        return
    endif
    bgColor := newVal
    Rerender(me)
endfunc

dim transparent as boolean
init transparent := false
func transparent (newVal as boolean)
    transparent := newVal
    Rerender(me)
endfunc

dim inactive as boolean
init inactive := false
func inactive (newVal as boolean)
    inactive := newVal
    Rerender(me)
endfunc

#doc prop dropShadowDistance
#category Text Settings
~If zero, no drop shadow is displayed.  Otherwise, this value determines how far down and to
~to the right of the main text caption a drop shadow of the text is shown.
dim dropShadowDistance as integer
init dropShadowDistance := 0
func dropShadowDistance (newVal as integer)
    dropShadowDistance := newVal
    Rerender(me)
endfunc

#doc prop BlinkPeriod
~This determines the rate at which this label will blink.  The value is the number of
~milliseconds to complete an entire cycle, so setting this value to 1000 will cause
~the label to blink on and off once each second.
~<BR><BR>Set this property to zero (0) to disable blinking.
dim BlinkPeriod as integer
init blinkPeriod := 0
func blinkPeriod (newVal as integer)
    blinkPeriod := newVal
    if blinkPeriod <= 0 then
        UnregisterMsgHandler (me, msg_timetick, 0)
        blinkOff := false
        Rerender(me)
    else
        RegisterMsgHandler (me, msg_timetick, newval/40)
    endif
endfunc

private func colorMapChanged(stat as integer) returns boolean
    handles _MsgThemeChange
    Recalc()
    return false
endfunc

private dim mf[1] as multiline_flags
private dim xp[1] as integer
private dim yp[1] as integer
private dim widths[1] as integer
private dim heights[1] as integer
private dim xo[1] as integer
private dim yo[1] as integer
private dim indices[1] as integer
private dim lengs[1] as integer
private dim bdrWidth as integer
private dim flags as font_flags

#undoc func Recalc
protected func Recalc()
    dim rd as char
    init rd := 'p'

    dim wb as charstr
    init wb := " "
    dim lb as charstr
    init lb := "\n"

    bdrWidth := _GetBorderWidth(_StyleMap[borderStyle])
    widths[0] = width - 2*xInset-2*bdrWidth
    heights[0] = height - 2*yInset-2*bdrWidth
    lengs[0] = -1
    indices[0] = 0
    val(flags, str(xJustify and yJustify))

    check error
        getsystextfit (mf, xp, yp, widths, heights, xo, yo, indices, lengs, font, 0, ptSize, value, wb, lb, flags)
    on error
        ClearException()
    enderr

    Rerender(me)
endfunc

private func ClearException()
    dim errstr[] as byte
    dim errTyp, errLev as unibyte

    GetException(errStr, errTyp, errLev)
endfunc

func StartUp()
    handles MSG_INIT

    Relocate (me, xPos, yPos)
    Resize (me, width, height)
    Enable (me, enabled)
    Attach (me, parent)
    blinkPeriod(blinkPeriod)
    Recalc()
endfunc

func Draw()
    handles MSG_DRAW

    dim x2, y2 as integer
    dim bg, fg as color

    if blinkOff then
        return
    endif

    bg := _colorMap[bgColor]
    fg := _colorMap[fgColor]

    x2 := xPos+width-1
    y2 := yPos+height-1

    SetBgColor(bg)
    if not transparent then
        SetFgColor(bg)
        DrawBox (xpos, ypos, x2, y2)
    endif

    SetTransparent(bg)
    UseTransparent(true)

    if dropShadowDistance > 0 then
        SetFgColor(_Shadow3DColors[bg])
        xp[0] = xpos+xinset+bdrWidth+dropShadowDistance
        yp[0] = ypos+yinset+bdrWidth+dropShadowDistance
        DrawsystextFit(mf, xp, yp, widths, heights, xo, yo, indices, lengs, font, 0, ptSize, value, font_normal and FONT_DRAW_VPARTIAL)
    endif

    if inactive then
        xp[0] = xpos+xinset+bdrWidth+1
        yp[0] = ypos+yinset+bdrWidth+1
        SetFgColor(_highlight3dcolors[bg])
        DrawsystextFit(mf, xp, yp, widths, heights, xo, yo, indices, lengs, font, 0, ptsize, value, font_normal and FONT_DRAW_VPARTIAL)
        xp[0] = xpos+xinset+bdrWidth
        yp[0] = ypos+yinset+bdrWidth
        SetFgColor(_Shadow3DColors[bg])
        DrawsystextFit(mf, xp, yp, widths, heights, xo, yo, indices, lengs, font, 0, ptSize, value, font_normal and FONT_DRAW_VPARTIAL)
    else
        SetFGColor (fg)
        xp[0] = xpos+xinset+bdrWidth
        yp[0] = ypos+yinset+bdrWidth
        DrawsystextFit(mf, xp, yp, widths, heights, xo, yo, indices, lengs, font, 0, ptSize, value, font_normal and FONT_DRAW_VPARTIAL)
    endif

    DrawBorder (xPos, yPos, x2, y2, _styleMap[borderStyle], 0x04)
endfunc

private dim blinkOff as boolean
init blinkOff := false
private func TimeTick()
    handles MSG_TIMETICK

    blinkOff := not blinkOff
    Rerender(me)
endfunc

private func ValidRange()
    if height > 3000 then
        height := 3000
        #IF _TOOL tool_persist(height) #endif
    endif
    if width > 3000 then
        width := 3000
        #if _TOOL tool_persist(width) #endif
    endif
endfunc

'The rest of these functions add functionality to the PC development tool.  The
'#if _TOOL line ensures that the code will not be compiled into a BFF that
'is loaded into the terminal

'These functions are called in response to actions taken in the PC development tool.
'If as a result of these actions you change one or more of the properties of
'this object that should be permanently recorded (for instance changing xPos in
'response to MSG_TOOL_MOVE) then you should call Tool_Persist to save the new
'value of the property in your source code of your object instance

#if _TOOL
'This function is called by the PC development tool, when you change the attachment
'of an object (i.e. in response to dragging it around the object tree).
'Note: the purpose of this function is to allow you to attach to another
'container, you should not change your parent property or call Tool_Persist
'until you receive a MSG_TOOL_ATTACHED.  A MSG_TOOL_ATTACHED will be sent
'in response to an Attach API function call.
func ToolAttach (attachTo as objref)
    handles MSG_TOOL_ATTACH

    Attach (me, attachTo)
endfunc

'This function is called in response to calling Attach (primarily in a
'handler for MSG_TOOL_ATTACH, but possibly in other places as well_.
func ToolAttached (newParent as objref)
    handles MSG_TOOL_ATTACHED

    'Set our parent property to reflect who we are attached to and save
    parent := newParent
    Tool_Persist (parent) 'Save parent
endfunc

'This function is called when the user drags an object instance with the
'mouse in the PC development tool.  dx and dy are relative offsets from the current
'location of the object
func ToolMove (dx as integer, dy as integer)
    handles MSG_TOOL_MOVE

    xPos := xPos + dx
    yPos := yPos + dy
    Relocate (me, xPos, yPos)

    'Save the changes we just made
    Tool_Persist (xPos)
    Tool_Persist (yPos)
endfunc

'This function is called by the PC development tool to obtain the coordinates of
'the resize grips.  The arrays xCoords, yCoords, and cursors all contain 0
'elements initially.  This means that you should either call redim on those
'arrays and set their values, or declare local arrays, set the values of
'the local arrays, and then assign xCoords, yCoords and cursors to those
'local arrays. Closed indicates whether the Foundry should connect the
'first and last grips to make a closed object.  xCoords, yCoords, and
'cursors should all contain the same number of elements when this function
'completes
func ToolGetHandles (xCoords[] as reference to integer, ->
                     yCoords[] as reference to integer, ->
                     cursors[] as reference to GuiCursors, ->
                     closed as reference to boolean)
    handles MSG_TOOL_GETHANDLES

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolGetHandles (xCoords, yCoords, cursors, closed, xPos, yPos, width, height)

endfunc

'This function is called in response to a user moving a resize grip within
'the PC development tool.  handleNum is the index into the arrays that were returned
'by the handler for MSG_TOOL_GETHANDLES.  You should return true from this
'function
func ToolMoveHandle (handleNum as reference to integer, dx as integer, dy as integer)
    handles MSG_TOOL_MOVEHANDLE

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolMoveHandle (handleNum, dx, dy, xPos, yPos, width, height, me)

    Recalc()
endfunc

'This function is called when the user created an instance of this template by
'selecting it from the object palette and dragging it in the layout view.
'The handler for MSG_INIT is not called automatically, and if you want it
'called, you should call it manually.
'You should call Tool_Persist on all the properties that you set up in this
'message handler.  (x1, y1) are the coordinates that the user started his
'drag and (x2, y2) are the coordinates that the mouse was released
func ToolDragCreate (parentObj as objref, x1 as integer, y1 as integer, ->
                     x2 as integer, y2 as integer)
    handles MSG_TOOL_DRAGCREATE

    Value := _StrToCharStr(Str(me))
    Tool_Persist (Value)
    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolDragCreate (parentObj, x1, y1, x2, y2, xPos, yPos, width, height, parent)

    'Call our MSG_INIT handler
    StartUp()
endfunc

#endif
Enddef
Define Area Object type SoftKeyBarV2
#ToolImage "FFFFFFFFFFFFFFFFC000FFFF3FFF3FFF33032FFF33FF2FFF3FFF2FFF33032FFF33FF2FFF3FFF2FFF000000003FF2FFCB3FF2FFCB00000000EAAAAAAA"
'*******************************************************************
'Object:        SoftKeyBarV2
'Author:        Ron Lloyd
'Date:          21 Jun 2011
'
'Description:   Manages SoftKeys
'
'Version:       2.40
'Version History:
'2.40 fixed bug where keypress where getting duplicated when using both
'touchscreen and keypad, RLL, 27-OCT-2005
'
'Copyright 2011 Beijer Electronics Inc
'Permission is granted to copy, distribute and modify this code,
'provided that this copyright statement is preserved
'*******************************************************************
#doc object SoftKeyBarV2
~The SoftKeyBar is an object meant to be located at the bottom of the display
~above the top row on a keypad.  The columns are to represent the actions
~occuring when a key is pressed on the top row of a keypad.  Each softkey and action
~is programmable using the <b>softKeyList</b> property in Layout View.
~Keys F1-F12 on a keyboard can also be used with the softkeybar.
#defaultitem func
#defaultitem prop SoftKeyList

library standard source ToolMessages
library Basic source KeypadTranslatorV2
library basic source textSupport
Library Standard Native API_Defs
Library Basic Source ColorStyleMapSupport
library standard source Notes

dim enabled as boolean
init enabled := true
func enabled(newval as boolean)
    Enable (me, newval)
    if newval then
        enabled := newval
        UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
        '_keySetRecentFocusObject()
        #IFNOT _TOOL_ANY
        disableSoftKey()
        #ENDIF
    else
        unregisterMsgHandler(me, MSG_TIMETICK, 0)
        'display next group and hide menus
        if G_55_PopupMenu_1.enabled and (enabled <> newval) then
            enabled := newval
            G_55_PopupMenu_1.Cancel()
        endif
    endif
    enabled := newval
endfunc

#IFNOT _TOOL_ANY
private func disableSoftKey()
    if _sk_currLed == -1 or G_55_PopupMenu_1.enabled then
        return
    endif
    if !changeLED then
        check error
            'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
        on error
            _clearException()
        enderr
        _sk_currLed := -1
        return
    endif

    if _sk_currLed+currCol < len(sklist) then
        if sklist[_sk_currLed+currCol] <> empty then
            if sklist[_sk_currLed+currCol].enabled == true then
                return
            endif
        endif
    endif
    check error
        'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
    on error
        _clearException()
    enderr
    _sk_currLed := -1
endfunc
#ENDIF

#doc func zenabled
#param status:This will be true if the parent object was enabled.
~Function is called when the parent of the object is enabled
~or disabled.
protected func zenabled(status as boolean)
    Handles MSG_ZENABLED
    if status then
        UserDirectMsg(default, MSG_SELECT_RECENT_FOCUSOBJ, 0, false)
        '_keySetRecentFocusObject()
        #IFNOT _TOOL_ANY
        disableSoftKey()
        #ENDIF
    else
        removeCapture(me)
        unregisterMsgHandler(me, MSG_TIMETICK, 0)
        G_55_PopupMenu_1.Cancel()
    endif
endfunc

dim parent as objref
init parent := default
func parent(newval as objref)
    parent := newval
    Attach(me, parent)
endfunc

dim xPos as integer
init xPos := 0
func xPos(newval as integer)
    xPos := newVal
    Relocate (me, xPos, yPos)
endfunc

dim yPos as integer
init yPos := 0
func yPos(newval as integer)
    yPos := newval
    Relocate (me, xPos, yPos)
endfunc

dim width as integer
init width := 25
func width(newval as integer)
    width := newval
    Resize (me, width, height)
    RecalcSoftKeys()
endfunc

dim height as integer
init height := 25
func height(newval as integer)
    height := newval
    Resize (me, width, height)
    RecalcSoftKeys()
endfunc

#doc prop buttonBorderStyle
#category Border and Color
~This is the border drawn around the buttons.
dim buttonBorderStyle as stylemap%
init buttonBorderStyle := Bdr_Softkey
func buttonBorderStyle (newVal as stylemap%)
    buttonBorderStyle := newVal
    Rerender(me)
endfunc

#doc prop menuborderStyle
#category Border and Color
~Borderstyle to be used for popup menus.
dim menuborderStyle as stylemap%
init menuborderStyle := bdr_softKey
func menuborderStyle (newVal as stylemap%)
    menuborderStyle := newVal
    InitPopupMenus()
endfunc

#doc prop barBgColor
#category Border and Color
~This is the background color behind the soft keys.  If transparent this
~color is not drawn.
dim barBgColor as colormap%
init barBgColor := Clr_SoftkeybarBackground
func barBgColor(newval as colormap%)
    barBgColor := newval
    Rerender(me)
endfunc

#doc prop buttonFgColor
#category Border and Color
~This is the foreground color of the text on the buttons.
dim buttonFgColor as colormap%
init buttonFgColor := Clr_SoftkeybarButtonFg
func buttonFgColor (newVal as colormap%)
    buttonFgColor := newVal
    Rerender(me)
endfunc

#doc prop buttonBgColor
#category Border and Color
~This is the background color of the buttons.
dim buttonBgColor as colormap%
init buttonBgColor := Clr_SoftkeybarButtonBg
func buttonBgColor (newVal as colormap%)
    buttonBgColor := newVal
    Rerender(me)
endfunc

#doc prop MenuFgColor
#category Border and Color
~Foreground color to be used in PopupMenus.
dim menufgColor as colormap%
init menufgColor := Clr_ButtonForeground
func menufgColor (newVal as colormap%)
    menufgColor := newVal
    InitPopupMenus()
endfunc

#doc prop MenuBgColor
#category Border and Color
~Background color to be used in PopupMenus.
dim menubgColor as colormap%
init menubgColor := Clr_ButtonBackground
func menubgColor (newVal as colormap%)
    menubgColor := newVal
    InitPopupMenus()
endfunc

dim transparent as boolean
init transparent := false
func transparent(newval as boolean)
    transparent := newval
    Rerender(me)
endfunc

#doc prop softKeyList
#category Main
~This is an list of SoftKeys that coincide with slots in the SoftKeyBar.
~This softkeys can be edited by a popup interface using this property in Layout
~View of Qlarity Foundry.  Click on the [...] box to bring up the softkeylist
~editor.
dim softKeyList[] as SoftKeyV2
func softKeyList(newval[] as softKeyV2)
    softKeyList := newval
    RecalcInfoList()
    Rerender(me)
endfunc

dim font as sysfont
init font := default
func font(newVal as sysfont)
    font := newVal
    Rerender(me)
endfunc

dim ptSize as integer
init ptSize := 10
func ptSize (newVal as integer)
    ptSize := newVal
    Rerender(me)
endfunc

#doc prop menuFont
~Font to be used for PopupMenus.
dim menuFont as sysfont
init menuFont := default
func menuFont(newVal as sysfont)
    menuFont := newVal
    InitPopupMenus()
endfunc

#doc prop menuPtSize
~PtSize to be used for PopupMenus.
dim menuPtSize as integer
init menuPtSize := 10
func menuPtSize (newVal as integer)
    menuPtSize := newVal
    InitPopupMenus()
endfunc

dim xJustify as HJustifyFlags
init xJustify := HJustify_Center
func xJustify (newVal as HJustifyFlags)
    xJustify := newVal
    Rerender(me)
endfunc

dim yJustify as VJustifyFlags
init yJustify := VJustify_Center
func yJustify (newVal as VJustifyFlags)
    yJustify := newVal
    Rerender(me)
endfunc

#doc prop nextxjustify
#category Text Settings
~X justification for the nextCaption text.
dim nextxJustify as HJustifyFlags
init nextxJustify := HJustify_Center
func nextxJustify (newVal as HJustifyFlags)
    nextxJustify := newVal
    Rerender(me)
endfunc
#doc prop nextyjustify
#category Text Settings
~Y justification for the nextCaption text.
dim nextyJustify as VJustifyFlags
init nextyJustify := VJustify_Center
func nextyJustify (newVal as VJustifyFlags)
    nextyJustify := newVal
    Rerender(me)
endfunc

#doc prop menuInset
#category Text Settings
~This is the space separating the menus from the outside of the container.
dim menuInset as integer
init menuInset := 1
func menuInset(newval as integer)
    menuInset := newval
    RecalcSoftKeys()
    Rerender(me)
endfunc
#doc prop colInset
#category Text Settings
~This is the space in between each softkey drawn on the softkeybar.
dim colInset as integer
init colInset := 1
func colInset(newval as integer)
    colInset := newval
    RecalcSoftKeys()
    Rerender(me)
endfunc

dim inactive as boolean
init inactive := false
func inactive (newVal as boolean)
    inactive := newVal
    Rerender(me)
endfunc

#doc prop dropShadowDistance
#category Text Settings
~If this property is zero, then no drop shadow will be drawn.  If this property is > 0, then
~a shadow of the caption will be shown below and to the right of the caption.
dim dropShadowDistance as integer
init dropShadowDistance := 0
func dropShadowDistance (newVal as integer)
    dropShadowDistance := newVal
    Rerender(me)
endfunc

#doc prop nextCaption
#category Main
~This is the caption appearing on the button used to scroll through softkeys if more
~softkeys are used than keys on the top row of the keypad.
dim nextCaption as charstr
init nextCaption := "MORE"
func nextCaption(newval as charstr)
    nextCaption := newval
    rerender(me)
endfunc

#doc prop showFKeys
#category Main
~Set this property to true to display the F1-F12 key characters that the
~soft keys are mapped to at the bottom left corner of each
~soft key.
dim showFKeys as boolean
init showFKeys := false
func showFKeys(newval as boolean)
    showFKeys := newval
    rerender(me)
endfunc
#doc prop fkeyFont
#category Main
~If the showFKeys property is try then this is the
~font that will be used to display the F1-F12 key
~characters.
dim fkeyFont as sysfont
func fkeyFont(newval as sysfont)
    fkeyFont := newval
    rerender(me)
endfunc
#doc prop fkeyPtSize
#category Main
~If the showFKeys property is try then this is the
~point size that will be used to display the F1-F12 key
~characters.
dim fkeyPtSize as integer
func fkeyPtSize(newval as integer)
    fkeyPtSize := newval
    rerender(me)
endfunc
#doc prop fkeyColor
#category Border and Color
~If the showFKeys property is try then this is the
~color that will be used to display the F1-F12 key
~characters.
dim fkeyColor as colormap%
init fkeycolor := 146
func fkeyColor(newval as colormap%)
    fkeyColor := newval
    rerender(me)
endfunc
#doc prop fkeyInset
#category Main
~If the showFKeys property is try then this is the
~space between the characters and the border of the
~displayed F1-F12 key
~characters.
dim fkeyInset as integer
init fkeyInset := 1
func fkeyInset(newval as integer)
    fkeyInset := newval
    rerender(me)
endfunc

#doc prop showItemNumbers
~If true, then items in a popup menu will be numbered.  These numbers can be used
~on terminals with a keypad or keyboard for quick selection of items 1-9 in the menu.
~Popup menus are created using the menudata property of a softKey.
dim showItemNumbers as boolean
init showItemNumbers := true
func showItemNumbers(newval as boolean)
    showItemNumbers := newval
    if G_55_PopupMenu_1.enabled then
        G_55_PopupMenu_1.Cancel()
        DisplayPopupMenu()
    endif
endfunc

#IF _TOOL_KEYINPUT
#doc prop changeLED
~If true, the Leds will turn on and off during each soft key click.
dim changeLED as boolean
#ELSE
#hidden dim changeLED as boolean
#ENDIF
init changeLED := false

dim Tone as _Note
init Tone := Note_UseDefault

#IF _TOOL_TOUCHSCREEN
#doc prop RepeatRate
#category Main
~This property sets how fast(ms) the click event will be repeatedly called after a screen press and the repeatWait.
dim repeatrate as integer
#ELSE
#hidden dim repeatrate as integer
#ENDIF
init repeatrate := 500
#IF _TOOL_TOUCHSCREEN
#doc prop RepeatWait
#category Main
~This property sets the time period(ms) that the Button will wait after a screen press
~before the click eveny is repeatedly called.
dim repeatwait as integer
#ELSE
#hidden dim repeatwait as integer
#ENDIF
init repeatwait := 250

func StartUp()
    handles MSG_INIT
    myPriority := _HotKey_Priority
    Relocate(me, xPos, yPos)
    Resize(me, width, height)
    Enable (me, enabled)
    Attach (me, parent)

    RegisterKey(me, KEY_ANY)
    UserDirectMsg(me, MSG_POPUP_MENU_POSTINIT, 0, false)
endfunc

private func PostStartUp(stat as integer) returns boolean
    handles MSG_POPUP_MENU_POSTINIT

    RecalcSoftKeys()
    RecalcInfoList()
    Rerender(me)
    return true
endfunc

private dim touchPress as boolean
#IF _TOOL_TOUCHSCREEN
private dim touchCol as integer
private func ScreenPress (xdown as integer, ydown as integer) returns boolean
    handles MSG_SCREEN_PRESS
    dim rwait as integer

    if inactive then
        return true
    endif
    setCapture(me)
    touchCol := (xdown-xpos)/(width/_keypadNumColumns)
    _kt_keyID := KEY_F1 + touchCol
    check error
        BidWon(0)
    on error
        goto bwe
        label bwe
    enderr
    touchPress := true
    check error
        BidWon(1)
    on error
        goto bwe2
        label bwe2
    enderr
    touchPress := false
    'if keypad use keypad settings to set timer click
    if repeatwait == 0 or repeatrate == 0 then
        return true
    endif
    rwait := repeatwait

    #IF _TOOL_SIM
        rwait := 400
    #ENDIF
    if Enabled then
        registerMsgHandler(me, MSG_TIMETICK, rwait/20)
    endif
    return true
endfunc

private func ScreenRelease (xup as integer, yup as integer) returns boolean
    handles MSG_SCREEN_RELEASE
    removeCapture(me)
    if inactive then
        return true
    endif
    unregisterMsgHandler(me, MSG_TIMETICK, 0)
    _kt_keyID := KEY_F1 + touchCol
    BidWon(2)
    return true
endfunc
#ENDIF

private func RelocResize()
    xPos := 0
    yPos := GetPosInfo(parent, GET_HEIGHT)-height
    Relocate(me, xPos, yPos)
    width := GetPosInfo(parent, GET_WIDTH)
    Resize(me, width, height)
endfunc

'**** PRIVATE VARIABLES
'set width for each draw soft key box
private dim softKeyW as integer
'current column for handling top row key presses
private dim currCol as integer
'This is the starting index on the SoftKey. array
'this will be useful for scroll throught sections of softkeys.

private dim myPriority as integer

private dim colIndex as integer
private func colIndex(newval as integer)
    colIndex := newval

    if colIndex > len(skList)-1 then
        colIndex := 0
    endif

    'Draw Each softKeyBorder and Caption.
    endIndex := colIndex+_keypadNumColumns-1
    if !scrollMode then
        endIndex := endIndex + 1
    endif
    if endIndex > len(skList) then
        endIndex := len(skList)
    endif
endfunc
'Current last index on softkey. array
private dim endIndex as integer
'If this is true then we have a large softkey array that
'requires scrolling
private dim scrollMode as boolean

private func InitPopupMenus()
    dim i as integer
    dim pmenu as G55PopupMenu
    if enabled then
        for i = 1 to 8
            val(pmenu, "G_55_PopupMenu_"+str(i))
            pmenu.font = menuFont
            pmenu.ptsize = menuptsize
            pmenu.fgColor = menufgcolor
            pmenu.bgColor = menubgcolor
            pmenu.borderStyle = menuborderstyle
            pmenu.showItemNumbers = showItemNumbers
            if pmenu.enabled then
                rerender(pmenu)
            endif
        next
    endif
endfunc

private func RecalcSoftKeys()
    softKeyW := (width-(menuInset*2)-(colInset*(_keypadNumColumns-1))) / _keypadNumColumns
endfunc

'This is the processed list that will be used.
private dim skList[] as softKeyV2
private func RecalcInfoList()
    dim i,j as integer
    redim(skList, 0)
    j := 0
    for i = 0 to len(softKeyList)-1
        if softKeyList[i] <> empty then
            if softKeyList[i].enabled then
                redim(skList, j+1)
                skList[j] := softKeyList[i]
                j := j + 1
            endif
        else
            redim(skList, j+1)
            skList[j] := empty
            j := j + 1
        endif
    next
    if len(skList) > _keypadNumColumns then
        scrollMode := true
    else
        scrollMode := false
    endif
    colIndex(0)
endfunc

private func KeyDown (keycode as unibyte) returns boolean
    handles MSG_KEY_DOWN
    if inactive then
        return false
    endif
    if _kt_KeyIDDown >= KEY_F1 and _kt_KeyIDDown <= KEY_F12 then
        _KT_Bid(me, myPriority, MsgType_KeyDown)
    endif
    return false
endfunc

'Check for row 0 hot keys,.
private func KeyPress (keycode as unibyte) returns boolean
    handles MSG_KEY_PRESS
    if inactive then
        return false
    endif
    if _kt_KeyIDPress >= KEY_F1 and _kt_KeyIDPress <= KEY_F12 then
        _KT_Bid(me, myPriority, MsgType_KeyPress)
    endif
    return false
endfunc

private func KeyRelease (keycode as unibyte) returns boolean
    handles MSG_KEY_RELEASE
    if inactive then
        return false
    endif
    if _kt_KeyIDRelease >= KEY_F1 and _kt_KeyIDRelease <= KEY_F12 then
        _KT_Bid(me, myPriority, MsgType_KeyRelease)
    endif
    return false
endfunc
' if bid won then send message to appropriate hot key.
private func BidWon(ktype as integer) returns boolean
    handles MSG_KT_BIDWON
    dim maxCol, actColIndex as integer
    currCol := _kt_KeyID - KEY_F1
    maxCol := endIndex-colIndex
    'actual column index
    actColIndex := currCol+colIndex

    if ktype == 0 then
        if currCol < maxCol and currCol >= 0 then
            #IFNOT _TOOL_ANY
                if changeLED and _sk_currLed <> -1 and ->
                        skList[actColIndex] <> empty then
                    check error
                        'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
                    on error
                        _clearException()
                    enderr
                    _sk_currLed := -1
                endif
                if changeLED and skList[actColIndex] <> empty then
                    _sk_currLed := currCol
                    check error
                        SetLed(LED_ON, _sk_ledList[_sk_currLed+1])
                    on error
                        _clearException()
                    enderr
                endif
            #ENDIF

            if skList[actColIndex] <> empty then
                if !skList[actColIndex].inactive then
                    DisplayPopupMenu()
                    skList[actColIndex].HandleKeyDown()
                endif
            endif
        endif
        if scrollMode and currCol == _keypadNumColumns -1 then
            colIndex = colIndex + _keypadNumColumns -1
            #IFNOT _TOOL_ANY
                if changeLED and _sk_currLed <> -1 then
                    check error
                        'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
                    on error
                        _clearException()
                    enderr
                    _sk_currLed := -1
                endif
            #ENDIF

            'display next group and hide menus
            if G_55_PopupMenu_1.enabled then
                G_55_PopupMenu_1.Cancel()
            endif
            rerender(me)
            if actColIndex > len(skList)-1 then
                MorePressed(skList[0])
            else
                MorePressed(skList[actColIndex])
            endif
        endif
    elseif ktype == 1 then
        if currCol < maxCol and currCol >= 0 then
            if skList[actColIndex] <> empty then
                if !skList[actColIndex].inactive then
                    #IF _TOOL_TOUCHSCREEN
                    if tone <> note_none and touchPress then
                        _PlayTone(tone, 100, false)
                    endif
                    #ENDIF
                    skList[actColIndex].HandleKeyPress()
                endif
            endif
        endif
    elseif ktype == 2 then
        #IFNOT _TOOL_ANY
            turnOffCurrLed()
        #ENDIF
        if currCol < maxCol and currCol >= 0 then
            if skList[actColIndex] <> empty then
                if !skList[actColIndex].inactive then
                    skList[actColIndex].HandleKeyRelease()
                endif
            endif
        endif
    endif
    return true
endfunc

private func turnOffCurrLed()
    if changeLED and _sk_currLed <> -1 and !G_55_PopupMenu_1.enabled then
        #IFNOT _TOOL_ANY
        check error
            'SetLed(LED_OFF, _sk_ledList[_sk_currLed+1])
        on error
            _clearException()
        enderr
        #ENDIF
        _sk_currLed := -1
    endif
endfunc

private func DisplayPopupMenu()
    dim x, y, actColIndex as integer
    actColIndex := currCol+colIndex
    'when a softkey is pressed the Popupmenu G_55_PopupMenu_1 is given new data and
    'displayed.
    x := GetPosInfo(me, GET_XGLOBAL) + menuInset + (currCol*softKeyW) + (currCol*colInset)
    y := GetPosInfo(me, GET_YGLOBAL) - 1
    if skList[actColIndex] <> empty then
        InitPopupMenus()
        skList[actColIndex].DisplayPopupMenu(x, y)
    endif
    if (G_55_PopupMenu_1.ypos + G_55_PopupMenu_1.height) > (yPos+1) then
        G_55_PopupMenu_1.ypos = y + height + 1
    endif
endfunc

private func Draw ()
    handles MSG_DRAW
    dim i, x, y, x2, y2, hlen as integer
    dim text as charstr
    dim arrowH, bdrWidth, xpts[3], ypts[3] as integer
    dim fkeyW, h, xo, yo, fkind as integer
    if !transparent then
        x2 := xPos + width -1
        y2 := yPos + height -1
        SetBgColor(_colorMap[barBgColor])
        SetFgColor(_colorMap[barBgColor])
        DrawBox(xPos, yPos, x2 ,y2)
    endif

    if showFKeys then
        GetSysTextSize(fkeyW, h, xo, yo, fkeyFont, 0, fkeyPtSize, "FF", FONT_NORMAL)
    endif

    bdrWidth := _getBorderWidth(_styleMap[buttonBorderStyle])
    x := xPos + menuInset
    y := yPos + menuInset
    x2 := x + softKeyW - 1
    y2 := y + height - (menuInset*2) - 1
    SetBGColor(_colorMap[buttonBgColor])
    for i = colIndex to endIndex-1
        if skList[i] <> empty then
            UseTransparent(false)
            DrawBorder (x, y, x2, y2, _styleMap[buttonBorderStyle], Bdr_Fill)

            text := skList[i].value
            if showFKeys then
                x := x + fkeyW
            endif
            _DrawSysTextMultiLineStyle(x+bdrWidth, y+bdrWidth, x2-x+1-(bdrWidth*2), ->
            y2-y+1-(bdrWidth*2), font, ptSize, text, ->
            xjustify, yjustify, inactive or skList[i].inactive, dropShadowDistance, ->
            _colorMap[buttonFgColor], _colorMap[buttonBgColor])
            if showFKeys then
                x := x - fkeyW
            endif
        endif

        x := x + softKeyW + colInset
        x2 := x + softKeyW - 1
    next
    'if scrollMode then Draw right Arrow
    if scrollMode then
        i := endIndex-colIndex
        while i <> _keypadNumColumns-1 do
            i := i + 1
            x := x + softKeyW + colInset
            x2 := x + softKeyW - 1
        loop
        UseTransparent(false)
        DrawBorder (x, y, x2, y2, _styleMap[buttonBorderStyle], Bdr_Fill)
        arrowH := ((y2-y) - (bdrWidth*2) - (_softKey_arrow_spacing*2))/2
        xPts[0] := x2-bdrWidth-_softKey_arrow_spacing
        yPts[0] := y+bdrWidth+_softKey_arrow_spacing+arrowH
        xPts[1] := xPts[0]-arrowH
        yPts[1] := yPts[0]-arrowH
        xPts[2] := xPts[0]-arrowH
        yPts[2] := yPts[0]+arrowH

        if endIndex == len(skList) then
            xPts[0] := xPts[0]-arrowH
            xPts[1] := xPts[1]+arrowH
            xPts[2] := xPts[2]+arrowH
        endif

        SetBGColor(_colorMap[buttonFgColor])
        DrawPolygon(xpts, ypts, POLY_FILL)

        if nextCaption == charstr("") then
            xpts[0] := xpts[0]-arrowH-_softKey_arrow_spacing
            xpts[1] := xpts[1]-arrowH-_softKey_arrow_spacing
            xpts[2] := xpts[2]-arrowH-_softKey_arrow_spacing
            SetBGColor(_colorMap[buttonFgColor])
            DrawPolygon(xpts, ypts, POLY_FILL)
        else
            if endIndex == len(skList) then
                xPts[2] := xPts[2]-arrowH
            endif
            'draw next button caption
            _DrawSysTextMultiLineStyle(x+bdrWidth, y+bdrWidth, ->
                (xPts[2])-(x+bdrWidth), ->
                y2-y+1-(bdrWidth*2), font, ptSize, nextCaption, ->
                nextxJustify, nextyJustify, inactive, dropShadowDistance, ->
                _colorMap[buttonFgColor], _colorMap[buttonBgColor])
        endif
    endif

    if showFKeys then
        fkind := 1
        x := xPos + menuInset + bdrWidth + fkeyInset
        y := yPos + menuInset + bdrWidth - fkeyInset
        y2 := y + height - (menuInset*2) - 1
        SetBGColor(_colorMap[buttonBgColor])
        for i = colIndex to endIndex-1
            if skList[i] <> empty then
                _DrawSysTextLineStyle(x, y, fkeyW*2, y2-y+1-(bdrWidth*2), fkeyFont, ->
                    fkeyPtSize, _strToCharstr("F"+str(fkind)), HJustify_Left, VJustify_Bottom, false, 0, ->
                    _colormap[fkeyColor], _colorMap[buttonbgcolor])
            endif
            x := x + softKeyW + colInset
            x2 := x + softKeyW - 1
            fkind := fkind + 1
        next
        if scrollmode then
            i := endIndex-colIndex
            while i < _keypadNumColumns-1 do
                i := i + 1
                x := x + softKeyW + colInset
                x2 := x + softKeyW - 1
            loop
            _DrawSysTextLineStyle(x, y, fkeyW*2, y2-y+1-(bdrWidth*2), fkeyFont, ->
                fkeyPtSize, _strToCharstr("F"+str(i+1)), HJustify_Left, VJustify_Bottom, false, 0, ->
                _colormap[fkeyColor], _colorMap[buttonbgcolor])
        endif
    endif
    return
endfunc

private func updateCaption(stat as integer) returns boolean
    handles MSG_UPDATE_SOFTKEYBARCAPTIONS
    rerender(me)
    return true
endfunc

private func Timetick ()
    handles MSG_TIMETICK
    dim rrate as integer

    unregisterMsgHandler(me, MSG_TIMETICK, 0)
    #IF _TOOL_TOUCHSCREEN
        if repeatwait == 0 or repeatrate == 0 then
            return
        endif
        rrate := repeatrate
    #ELSE
        GetSystemSetting(SYS_KBDRPTRATE, rrate, SYSREAD_CURRENT)
    #IF _TOOL_SIM
        rrate := 200
    #ENDIF
    #ENDIF
    registerMsgHandler(me, MSG_TIMETICK, rrate/20)

    touchPress := true
    check error
        BidWon(1)
    on error
        goto bwe2
        label bwe2
    enderr
    touchPress := false
    return
endfunc

#doc override MorePressed
~Event occurs when more button is pressed.
#param firstSK: First SoftKey in new list.
func MorePressed(firstSK as SoftKeyV2)
    return
endfunc

'The rest of these functions add functionality to the PC development tool.  The
'#if _TOOL line ensures that the code will not be compiled into a BFF that
'is loaded into the terminal

'These functions are called in response to actions taken in the PC development tool.
'If as a result of these actions you change one or more of the properties of
'this object that should be permanently recorded (for instance changing xPos in
'response to MSG_TOOL_MOVE) then you should call Tool_Persist to save the new
'value of the property in your source code of your object instance

#if _TOOL
'This function is called by the PC development tool, when you change the attachment
'of an object (i.e. in response to dragging it around the object tree).
'Note: the purpose of this function is to allow you to attach to another
'container, you should not change your parent property or call Tool_Persist
'until you receive a MSG_TOOL_ATTACHED.  A MSG_TOOL_ATTACHED will be sent
'in response to an Attach API function call.
func ToolAttach (attachTo as objref)
    handles MSG_TOOL_ATTACH

    Attach (me, attachTo)
endfunc

'This function is called in response to calling Attach (primarily in a
'handler for MSG_TOOL_ATTACH, but possibly in other places as well_.
func ToolAttached (newParent as objref)
    handles MSG_TOOL_ATTACHED

    'Set our parent property to reflect who we are attached to and save
    parent := newParent
    Tool_Persist (parent) 'Save parent
endfunc

'This function is called by the PC development tool to obtain the coordinates of
'the resize grips.  The arrays xCoords, yCoords, and cursors all contain 0
'elements initially.  This means that you should either call redim on those
'arrays and set their values, or declare local arrays, set the values of
'the local arrays, and then assign xCoords, yCoords and cursors to those
'local arrays. Closed indicates whether the Foundry should connect the
'first and last grips to make a closed object.  xCoords, yCoords, and
'cursors should all contain the same number of elements when this function
'completes
func ToolGetHandles (xCoords[] as reference to integer, ->
                     yCoords[] as reference to integer, ->
                     cursors[] as reference to GuiCursors, ->
                     closed as reference to boolean)
    handles MSG_TOOL_GETHANDLES

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolGetHandles (xCoords, yCoords, cursors, closed, xPos, yPos, width, height)
endfunc

private func ToolMove (dx as integer, dy as integer)
    handles MSG_TOOL_MOVE
    xPos := xPos + dx
    yPos := yPos + dy
    Relocate (me, xPos, yPos)

    'Save the changes we just made
    Tool_Persist (xPos)
    Tool_Persist (yPos)
    return
endfunc

'This function is called in response to a user moving a resize grip within
'the PC development tool.  handleNum is the index into the arrays that were returned
'by the handler for MSG_TOOL_GETHANDLES.  You should return true from this
'function
func ToolMoveHandle (handleNum as reference to integer, dx as integer, dy as integer)
    handles MSG_TOOL_MOVEHANDLE

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolMoveHandle (handleNum, dx, dy, xPos, yPos, width, height, me)
    RecalcSoftKeys()
endfunc

'This function is called when the user created an instance of this template by
'selecting it from the object palette and dragging it in the layout view.
'The handler for MSG_INIT is not called automatically, and if you want it
'called, you should call it manually.
'You should call Tool_Persist on all the properties that you set up in this
'message handler.  (x1, y1) are the coordinates that the user started his
'drag and (x2, y2) are the coordinates that the mouse was released
func ToolDragCreate (parentObj as objref, x1 as integer, y1 as integer, ->
                     x2 as integer, y2 as integer)
    handles MSG_TOOL_DRAGCREATE

    'Call a standard function to handle common functionality.
    'You can omit this function call and implement your own custom functionality
    'if desired
    _ToolDragCreate (parentObj, x1, y1, x2, y2, xPos, yPos, width, height, parent)

    height := 25
    if _mainKeypadSettings <> empty then
        height := _mainKeypadSettings.barheight
        font := _mainKeypadSettings.barfont
        tool_persist(font)
        ptsize := _mainKeypadSettings.barptsize
        tool_persist(ptsize)
        buttonborderstyle := _mainKeypadSettings.buttonborderstyle
        tool_persist(buttonborderstyle)
        buttonfgcolor := _mainKeypadSettings.buttonfgcolor
        tool_persist(buttonfgcolor)
        buttonbgcolor := _mainKeypadSettings.buttonbgcolor
        tool_persist(buttonbgcolor)
        barbgcolor := _mainKeypadSettings.barbgcolor
        tool_persist(barbgcolor)
        xjustify := _mainKeypadSettings.barxjustify
        tool_persist(xjustify)
        yjustify := _mainKeypadSettings.baryjustify
        tool_persist(yjustify)
    endif

    tool_persist(height)

    RelocResize()
    tool_persist(xpos)
    tool_persist(ypos)
    tool_persist(width)

    'Call our MSG_INIT handler
    StartUp()
endfunc

#endif
Enddef
Declare but__Exit_Sys_Setup as ButtonV2
Level 249472
#Visible True
#Lock False
init value := "EXIT SYSTEM SETUP"
init parent := sys_setup_screen
init xpos := 200
init ypos := 615
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Exit_Sys_Setup_Screen()
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but__FactorySettings as ButtonV2
Level 249471
#Visible True
#Lock False
init value := "FACTORY SETTINGS"
init parent := sys_setup_screen
init xpos := 100
init ypos := 287
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Fact_Set_Warning_screen.enabled=true
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but__Maintenance as ButtonV2
Level 249475
#Visible True
#Lock False
init value := "MAINTENANCE"
init parent := sys_setup_screen
init xpos := 100
init ypos := 394
init width := 250
init height := 50
init font := helvb18_bdf

init xjustify := hjustify_leftalign

func click()
    System_Maintenance_Screen.Enabled = True
endfunc
Enddec
Declare but__Valve_Control as ButtonV2
Level 249474
#Visible True
#Lock False
init value := "VALVE CONTROL"
init parent := sys_setup_screen
init xpos := 100
init ypos := 341
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Init_Valve_Screen()
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but_Accept_Current as ButtonV2
Level 249845
#Visible True
#Lock False
init value := "ACCEPT CURRENT VALUES"
init parent := power_up_screen
init xpos := 15
init ypos := 720
init width := 120
init height := 70
init font := helvb18_bdf

func click()
     MLcurA=MLlastA
    MLcurB=MLlastB
    Reset(MLcurA,MLcurB)
    exit_Power_Up_screen()
    Close_All()
    IF MLcurA<1.00 and MLcurB<1.00 then
        CycleComplete=false
    else
        CycleComplete=true
    endif
    InitComplete=True
    Init_Title_screen()
    Cancel_PowerUp()

endfunc
Enddec
Declare But_Accept_Pres_Calc as ButtonV2
Level 249648
#Visible True
#Lock False
init value := "ACCEPT"
init parent := p_cal_screen
init xpos := 370
init ypos := 580
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    if lbl_fs_volts_new.Value<>"" then
        check error
            Val(Full_Scale_volts,lbl_fs_volts_New.Value)
        on error
            _ClearException()
        enderr
    else
        warning_sound()
        return
    endif
    If But_Transducer_Select.Value=="A" then
        Transducer = "A"
    Else
        Transducer = "B"
    Endif
    But_Transducer_Select.inactive=false
    Send_PfsV(Full_Scale_volts,Transducer)
    Exit_P_Cal_Screen()
    Init_Setup_screen()
endfunc
Enddec
Declare But_Accept_Vol_Calc as ButtonV2
Level 249673
#Visible True
#Lock False
init value := "ACCEPT"
init parent := vol_cal_screen
init xpos := 365
init ypos := 585
init width := 100
init height := 49
init font := helvb18_bdf

func click()
    If But_Cylinder_Select.Value=="CYL A" then
        check error
            val(MLpermmA,lbl_ml_per_mm_calc.value)
        on error
            _ClearException()
        enderr
        Send_MLPmm(MLpermmA,"A")
        lbl_ml_per_mm_calc.BlinkPeriod=0
    else
        check error
            val(MLpermmB,lbl_ml_per_mm_calc.value)
        on error
            _ClearException()
        enderr
        Send_MLPmm(MLpermmB,"B")
        lbl_ml_per_mm_calc.BlinkPeriod=0
    endif
    but_Calculate_Volume.enabled=false
    But_Cylinder_Select.inactive=false
    But_Valve_Select.inactive=false
    But_Start_Flow_Cal.enabled=false
    eb_ml_measured.enabled=false
    But_Accept_Vol_Calc.enabled=false
endfunc
Enddec
Declare but_AIn as ButtonV2
Level 249912
#Visible True
#Lock False
init value := "CLOSED"
init parent := manual_control_screen
init xpos := 40
init ypos := 525
init width := 85
init height := 50
init font := helvb18_bdf

func click()
    If value=="CLOSED" then
        value="OPEN"
        but_OpnAin.click()
    else
        value="CLOSED"
        but_ClsAin.click()
    endif

endfunc
Enddec
Declare but_AOut as ButtonV2
Level 249911
#Visible True
#Lock False
init value := "CLOSED"
init parent := manual_control_screen
init xpos := 135
init ypos := 525
init width := 85
init height := 50
init font := helvb18_bdf

func click()
    If value=="CLOSED" then
        value="OPEN"
        but_OpnAOut.click()
    else
        value="CLOSED"
        but_ClsAOut.click()
    endif

endfunc
Enddec
Declare but_BIn as ButtonV2
Level 249913
#Visible True
#Lock False
init value := "CLOSED"
init parent := manual_control_screen
init xpos := 260
init ypos := 525
init width := 85
init height := 50
init font := helvb18_bdf

func click()
    If value=="CLOSED" then
        value="OPEN"
        but_OpnBin.click()
    else
        value="CLOSED"
        but_ClsBin.click()
    endif

endfunc
Enddec
Declare but_BOut as ButtonV2
Level 249914
#Visible True
#Lock False
init value := "CLOSED"
init parent := manual_control_screen
init xpos := 355
init ypos := 525
init width := 85
init height := 50
init font := helvb18_bdf

func click()
    If value=="CLOSED" then
        value="OPEN"
        but_OpnBOut.click()
    else
        value="CLOSED"
        but_ClsBOut.click()
    endif

endfunc
Enddec
Declare But_Calculate_Constant as ButtonV2
Level 249647
#Visible True
#Lock False
init value := "CALCULATE NEW CONSTANT"
init parent := p_cal_screen
init xpos := 10
init ypos := 580
init width := 172
init height := 50
init font := helvb18_bdf

func click()
    dim psiActual as float
    dim psiIndicated as float
    dim newVoltsperPSI as float
    dim newFSvolts as float

            'Read eb_psi_actual
            check error
                Val(psiActual,eb_psi_actual.Value)
            on error
                _ClearException()
            enderr
            If psiActual==0 then
                warning_sound()
                lbl_P_Cal_msg.value="Enter non-zero value for actual pressure."
            else
                'Read lbl_psi_indicated

                check error
                    val(psiIndicated,lbl_psi_indicated.value)
                on error
                    _ClearException()
                enderr

                'Calculate new values
                NewVoltsperPSI=VoltsperPSIA*(psiIndicated/psiActual)
                newFSvolts=NewVoltsperPSI*Prange
                'Display new values
                lbl_volts_per_psi_new.value=_formatfloat(NewVoltsperPSI,6,4,_FLOAT_NORMAL)
                lbl_volts_per_psi_new.enabled=true
                lbl_FS_volts_new.Value=_formatfloat(NewFSvolts,6,3,_FLOAT_NORMAL)
                lbl_FS_volts_new.enabled=true
                lbl_p_cal_msg.value="If new value of volts/psi is correct, press Accept."
                but_Accept_Pres_Calc.enabled=true
            endif


endfunc
Enddec
Declare But_Calculate_Volume as ButtonV2
Level 249672
#Visible True
#Lock False
init value := "CALCULATE NEW CONSTANT"
init parent := vol_cal_screen
init xpos := 10
init ypos := 585
init width := 172
init height := 49
init font := helvb18_bdf

func click()
    dim mlmeasured as float
    dim mlcalculated as float
    dim newMLPmm as float


        If eb_ml_measured.Value == "" or  eb_ml_measured.Value == "." then
            warning_sound()
        else
            'read eb_ml_measured.value and lbl_ml_flowed

                check error
                    val(mlmeasured,eb_ml_measured.Value)
                    val(mlcalculated,lbl_ml_flowed.value)
                on error
                    _ClearException()
                enderr
            if mlmeasured==0 then
                warning_sound()
            else
               'calculate new value
               if but_Cylinder_Select.Value=="CYL A"  then
                    newMLPmm=MLpermmA*(mlmeasured/mlcalculated)
                else
                    newMLPmm=MLpermmB*(mlmeasured/mlcalculated)
                endif
                'Display new value
                lbl_ml_per_mm_calc.value=_Formatfloat(newMLPmm,6,4,_FLOAT_NORMAL)
                lbl_ml_per_mm_calc.BlinkPeriod=2000
                but_Accept_Vol_Calc.enabled=true
                lbl_vol_cal_msg_b.value="Press ACCEPT to save the new value, or enter a new measured volume."
                _Keysetfocus(eb_ml_measured,true)

            endif
        endif

endfunc
Enddec
Declare But_Calibrate_Press as ButtonV2
Level 249653
#Visible True
#Lock False
init value := "CALIBRATE"
init parent := p_cal_screen
init xpos := 300
init ypos := 365
init width := 170
init height := 50
init font := helvb18_bdf

func click()
    but_zero.enabled=true
    but_accept_Pres_Calc.enabled=false
    but_calculate_constant.enabled=false
    lbl_Calibrate_1.enabled= true
    lbl_Calibrate_2.enabled= true
    lbl_Calibrate_3.enabled= true
    lbl_psi_indicated.enabled=true
    eb_psi_actual.enabled= false
    CalMode=True
    lbl_New_Constant_1.enabled=false
    lbl_New_Constant_2.enabled=false
    eb_fs_volts.enabled=false
    But_Transducer_Select.inactive=true

    lbl_p_cal_msg.value="Make sure current pressure is zero, then press SET ZERO."
endfunc
Enddec
Declare But_Cancel_FactSet as ButtonV2
Level 249786
#Visible True
#Lock False
init value := "CANCEL"
init parent := fact_set_warning_screen
init xpos := 16
init ypos := 741
init width := 92
init height := 49
init font := helvb18_bdf

func click()
    Fact_Set_Warning_screen.enabled = false
endfunc
Enddec
Declare But_Cancel_Init as ButtonV2
Level 249588
#Visible True
#Lock False
init value := "CANCEL"
init parent := initialize_screen
init xpos := 20
init ypos := 741
init width := 100
init height := 49
init font := helvb18_bdf

func click()
    Exit_Initialize_Screen()
endfunc
Enddec
Declare but_Cancel_Init_1 as ButtonV2
Level 249999
#Visible True
#Lock False
init value := "CANCEL"
init parent := init_popup_screen
init xpos := 25
init ypos := 249
init width := 250
init height := 80
init font := helvb18_bdf

func click()
    If GMCPoll_Finding_RS.enabled then
        GMCPoll_Finding_RS.enabled=false
        GMCCommand.command = "XQ#STPCYCL,5"
        GMCCommand.executeCommand = true
    endif
    Init_Popup_Screen.enabled=false
    Init_Setup_screen()
endfunc

init xjustify := hjustify_centeralign
Enddec
Declare but_Cancel_IP_Address as ButtonV2
Level 249961
#Visible True
#Lock False
init value := "CANCEL"
init parent := ip_address_screen
init xpos := 15
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    IP_Address_Screen.enabled=false

endfunc
Enddec
Declare but_Cancel_Limits_Screen as ButtonV2
Level 249941
#Visible True
#Lock False
init value := "CANCEL"
init parent := limits_screen
init xpos := 30
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    Exit_Limits_screen()

endfunc
Enddec
Declare But_Cancel_Pres_Cal as ButtonV2
Level 249646
#Visible True
#Lock False
init value := "CANCEL"
init parent := p_cal_screen
init xpos := 16
init ypos := 741
init width := 92
init height := 49
init font := helvb18_bdf

func click()
    P_Cal_screen.enabled=false
    gmcpoll_pcura.enabled=false
    gmcpoll_pcurb.enabled=false
    Init_Setup_screen()
endfunc
Enddec
Declare but_Close_Debug as ButtonV2
Level 249778
#Visible True
#Lock False
init value := "CLOSE"
init parent := debugscrn
init xpos := 94
init ypos := 499
init width := 189
init height := 58
init font := helvb18_bdf

func click()
    DebugScrn.enabled=false
endfunc
Enddec
Declare but_ClsAIn as ButtonV2
Level 249800
#Visible True
#Lock False
init value := "CLOSE"
init parent := valve_screen
init xpos := 350
init ypos := 195
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#ClsAin,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_ClsAll as ButtonV2
Level 249806
#Visible True
#Lock False
init value := "CLOSE ALL"
init parent := valve_screen
init xpos := 270
init ypos := 480
init width := 160
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#ClsAll,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_ClsAOut as ButtonV2
Level 249797
#Visible True
#Lock False
init value := "CLOSE"
init parent := valve_screen
init xpos := 350
init ypos := 95
init width := 80
init height := 50
init font := helvb18_bdf

func click()

    GMCCommand.command = "XQ#ClsAout,1"
    GMCCommand.executeCommand = true

endfunc
Enddec
Declare but_ClsBIn as ButtonV2
Level 249804
#Visible True
#Lock False
init value := "CLOSE"
init parent := valve_screen
init xpos := 350
init ypos := 395
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#ClsBin,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_ClsBout as ButtonV2
Level 249802
#Visible True
#Lock False
init value := "CLOSE"
init parent := valve_screen
init xpos := 350
init ypos := 295
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#ClsBout,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_Configure as ButtonV2
Level 249468
#Visible True
#Lock False
init value := "CONFIGURE"
init parent := sys_setup_screen
init xpos := 100
init ypos := 126
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Sys_Setup_Screen.enabled=false
    Init_Config_Screen()
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare But_Confirm_Init as ButtonV2
Level 249587
#Visible True
#Lock False
init value := "CONFIRM"
init parent := initialize_screen
init xpos := 360
init ypos := 741
init width := 100
init height := 49
init font := helvb18_bdf

func click()
     'send "XQ#FNDLMTS
    GMCCommand.command = "XQ#FNDLMTS,1"
    GMCCommand.executeCommand = true
    Disabled = true
    lbl_Setup_Msg.value="Finding VPA Stroke Limits"
    GMCPoll_Finding.enabled=true
    but_Confirm_init.enabled= false
    initcomplete=false
endfunc
Enddec
Declare but_CycToStart as ButtonV2
Level 249577
#Visible True
#Lock False
init value := "CYCLE TO START"
init parent := flow_mode_screen
init xpos := 50
init ypos := 305
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    Cycle_To_Start()

endfunc
Enddec
Declare but_CycToStart_1 as ButtonV2
Level 249536
#Visible True
#Lock False
init value := "CYCLE TO START"
init parent := pressure_mode_screen
init xpos := 45
init ypos := 305
init width := 110
init height := 49
init font := helvb18_bdf

func click()
   Cycle_To_Start()
endfunc
Enddec
Declare but_CycToStart_2 as ButtonV2
Level 249417
#Visible True
#Lock False
init value := "CYCLE TO START"
init parent := profile_screen
init xpos := 15
init ypos := 680
init width := 100
init height := 49
init font := helvb18_bdf

func click()
   Cycle_To_Start()
endfunc
Enddec
Declare But_Cylinder_Select as ButtonV2
Level 249676
#Visible True
#Lock False
init value := "CYL A"
init parent := vol_cal_screen
init xpos := 328
init ypos := 97
init width := 92
init height := 43
init font := helvb18_bdf

func click()
    If value=="CYL A" then
        value="CYL B"
        gmcpoll_mlcurb.enabled=true
        gmcpoll_mlcura.enabled=false
        lbl_ml_per_mm.value=_formatfloat(MLpermmB,6,4,_FLOAT_NORMAL)
    else
        value="CYL A"
        gmcpoll_mlcura.enabled=true
        gmcpoll_mlcurb.enabled=false
        lbl_ml_per_mm.value=_formatfloat(MLpermmA,6,4,_FLOAT_NORMAL)
    endif
endfunc
init inactive := false
Enddec
Declare but_Debug as ButtonV2
Level 249473
#Visible True
#Lock False
init value := "DEBUG"
init parent := sys_setup_screen
init xpos := 32
init ypos := 612
init width := 100
init height := 49
init font := helvb18_bdf


func click()
    DebugScrn.enabled=true
    IF WriteErrorToPortTwo then
        but_Error_Port.Value="Error Port On"
    else
        but_Error_Port.Value="Error Port Off"
    endif



endfunc
init enabled := false
Enddec
Declare but_Debug_1 as ButtonV2
Level 249538
#Visible False
#Lock False
init value := "DEBUG"
init parent := pressure_mode_screen
init xpos := 193
init ypos := 690
init width := 82
init height := 49
init font := helvb18_bdf

func click()
    DebugScrn.enabled=true
endfunc
init enabled := false
Enddec
Declare but_Disable_Warnings as ButtonV2
Level 249985
#Visible True
#Lock False
init value := "DISABLE WARNINGS"
init parent := error_popup_screen
init xpos := 15
init ypos := 350
init width := 139
init height := 60
init font := helvb18_bdf

func click()
    If value=="DISABLE WARNINGS" then
        value ="ENABLE WARNINGS"
        ErrorDisplayDisabled=true
    else
        value="DISABLE WARNINGS"
        ErrorDisplayDisabled=false
    endif
endfunc
Enddec
Declare but_Enable_Open_Valves as ButtonV2
Level 249953
#Visible True
#Lock False
init value := "DISABLED"
init parent := limits_screen
init xpos := 300
init ypos := 457
init width := 127
init height := 40
init font := helvb18_bdf


func click()
    If value=="DISABLED" then
        value="ENABLED"
        lbl_Open_Valves_On_OP.bgColor=clr_softkeybarbackground

    Else
        value="DISABLED"
        lbl_Open_Valves_On_OP.bgColor=196

    endif

endfunc
Enddec
Declare but_Enable_Shutdown as ButtonV2
Level 249955
#Visible True
#Lock False
init value := "ENABLED"
init parent := limits_screen
init xpos := 300
init ypos := 530
init width := 127
init height := 40
init font := helvb18_bdf

func click()
    if but_Enable_Shutdown.value=="DISABLED" then
            but_Enable_Shutdown.value="ENABLED"
            lbl_Flow_Shutdown.bgColor=clr_softkeybarbackground
            flow_limit_disabled=false
        else
            but_Enable_Shutdown.value="DISABLED"
            lbl_Flow_Shutdown.bgColor=196
            flow_limit_disabled=true
        endif
endfunc
Enddec
Declare but_Enable_Warnings as ButtonV2
Level 249951
#Visible True
#Lock False
init value := "ENABLED"
init parent := limits_screen
init xpos := 300
init ypos := 385
init width := 127
init height := 40
init font := helvb18_bdf

func click()
    if but_Enable_warnings.value=="DISABLED" then
            but_Enable_warnings.value="ENABLED"
            lbl_Warnings_Enabled.bgColor=clr_softkeybarbackground
        else
            but_Enable_warnings.value="DISABLED"
            lbl_Warnings_Enabled.bgColor=196
        endif
endfunc
Enddec
Declare But_End_Profile_Def as ButtonV2
Level 249423
#Visible True
#Lock False
init value := "END DEFINITION"
init parent := profile_screen
init xpos := 345
init ypos := 745
init width := 120
init height := 49
init font := helvb18_bdf

func click()
    but_Limits_3.enabled=true
    but_OpenValves_1.enabled=true
    but_ZeroXdcrs_1.enabled=true
    but_CycToStart_2.enabled=true
    If cyclecomplete then
        but_Profile.Value="START PROFILE"
        but_Profile.enabled=true
    endif
    Profile_Definition_Complete=true
    End_Profile()
    but_End_Profile_Def.enabled=false
    'Make it so there can be no more editing of the boxes that are set
endfunc
Enddec
Declare but_Error_Log as ButtonV2
Level 249478
#Visible True
#Lock False
init value := "ERROR LOG"
init parent := sys_setup_screen
init xpos := 100
init ypos := 553
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    error_log_screen.enabled=true

endfunc
init xjustify := hjustify_leftalign
Enddec
Declare but_Error_Port as ButtonV2
Level 249779
#Visible True
#Lock False
init value := "Error Port On"
init parent := debugscrn
init xpos := 94
init ypos := 567
init width := 189
init height := 54
init font := helvb18_bdf

func click()
    If value=="Error Port On" then
        value="Error Port Off"
        WriteErrorToPortTwo=false
    else
        value="Error Port On"
        WriteErrorToPortTwo=true
        transmit(COM2, "Error Port Writing active.",false)
    endif

endfunc
Enddec
Declare but_Estop as ButtonV2
Level 249978
#Visible True
#Lock False
init value := "E-STOP"
init parent := cycle_popup_screen
init xpos := 25
init ypos := 249
init width := 250
init height := 80
init font := helvb18_bdf

func click()
    'STOP MOTION
    Estop = true
    GMCCommand.command = "XQ#STPCYCL,5"
    GMCCommand.executeCommand = true

    If Vol_Cal_screen.enabled then
        but_Start_Flow_Cal.enabled=false
    endif
    Cycle_Popup_Screen.enabled=false
    CycleComplete=false
endfunc

init xjustify := hjustify_centeralign
Enddec
Declare but_Estop_1 as ButtonV2
Level 249929
#Visible True
#Lock Me
init value := "E-STOP"
init parent := manual_control_screen
init xpos := 295
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    'STOP MOTION
    GMCCommand.command = "XQ#ESTOP,1"
    GMCCommand.executeCommand = true

endfunc

init xjustify := hjustify_centeralign
Enddec
Declare but_Exit_Config as ButtonV2
Level 249591
#Visible True
#Lock False
init value := " EXIT"
init parent := config_screen
init xpos := 15
init ypos := 743
init width := 139
init height := 49
init font := helvb18_bdf

func click()
    Exit_Config_screen()
endfunc
Enddec
Declare but_Exit_Error_Log as ButtonV2
Level 249480
#Visible True
#Lock False
init value := "EXIT ERROR LOG"
init parent := error_log_screen
init xpos := 114
init ypos := 731
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Error_Log_Screen.enabled=false
endfunc

init xjustify := hjustify_center
Enddec
Declare but_Exit_Manual_Control as ButtonV2
Level 249906
#Visible True
#Lock False
init value := "EXIT MANUAL CONTROL"
init parent := manual_control_screen
init xpos := 15
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    IF RefillingA or RefillingB then
        lbl_Manual_Control_Msg.value= "Wait for refilling to complete before exiting this screen."
        warning_sound()
    else
        Exit_Manual_Control_Screen()
    endif
endfunc
Enddec
Declare But_Exit_Vol_Cal as ButtonV2
Level 249686
#Visible True
#Lock False
init value := "EXIT"
init parent := vol_cal_screen
init xpos := 380
init ypos := 741
init width := 92
init height := 49
init font := helvb18_bdf

func click()
    If CalFlowing then
        Warning_Sound()
        lbl_vol_cal_msg_B.value="Stop Flow before exiting screen."
        return
    endif
    Exit_Vol_Cal_screen()
endfunc
Enddec
Declare But_Fill_to_Start as ButtonV2
Level 249683
#Visible True
#Lock False
init value := "FILL TO START VOL"
init parent := vol_cal_screen
init xpos := 35
init ypos := 415
init width := 150
init height := 49
init font := helvb18_bdf

func click()
    GMCCommand.command = "Cycle=1"
    GMCCommand.executeCommand = true
    If But_Cylinder_Select.Value=="CYL A" then
        GMCPoll_PcurA.enabled=true
        GMCPoll_PcurB.enabled=false
        GMCCommand.command = "XQ#ClsAll,1"
        GMCCommand.executeCommand = true
        GMCCommand.command = "CalStrtA=" + eb_Cal_Start.value
        GMCCommand.executeCommand = true
        If But_Valve_Select.value=="INLET" then
            GMCCommand.command = "XQ#OpnAin,2"
            GMCCommand.executeCommand = true
        else
            GMCCommand.command = "XQ#OpnAout,2"
            GMCCommand.executeCommand = true
        endif
        GMCCommand.command = "XQ#RCYCA,4"
        GMCCommand.executeCommand = true
        Cycle_Popup_Screen.enabled=true
        GMCPoll_RCycle.enabled=true
        gmcpoll_mlcura.enabled=true
        gmcpoll_mlcurb.enabled=false
    Else
        GMCPoll_PcurB.enabled=true
        GMCPoll_PcurA.enabled=false
        GMCCommand.command = "XQ#ClsAll,1"
        GMCCommand.executeCommand = true
        GMCCommand.command = "CalStrtB=" + eb_Cal_Start.value
        GMCCommand.executeCommand = true
        If But_Valve_Select.value=="INLET" then
            GMCCommand.command = "XQ#OpnBin,2"
            GMCCommand.executeCommand = true
        else
            GMCCommand.command = "XQ#OpnBout,2"
            GMCCommand.executeCommand = true
        endif
        GMCCommand.command = "XQ#RCYCB,4"
        GMCCommand.executeCommand = true
       Cycle_Popup_Screen.enabled=true
        GMCPoll_RCycle.enabled=true
        gmcpoll_mlcurb.enabled=true
        gmcpoll_mlcura.enabled=false
        lbl_Cycle_Msg_2.value="Cylinders moving to Calibration start position"
    endif
    But_Cylinder_Select.inactive=true
    But_Valve_Select.inactive=true
endfunc
Enddec
Declare but_FlowCalibration as ButtonV2
Level 249469
#Visible True
#Lock False
init value := "VOLUME CALIBRATION"
init parent := sys_setup_screen
init xpos := 100
init ypos := 180
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Sys_Setup_Screen.enabled=false
    Init_Vol_Cal_Screen ()

endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but_FlowMode as ButtonV2
Level 249825
#Visible True
#Lock False
init value := "CONSTANT FLOW RATE MODE"
init parent := title_screen
init xpos := 300
init ypos := 280
init width := 153
init height := 80
init font := helvb18_bdf

func click()
    If PmpMode==1 then
        If Remote==0 then
            lbl_msg_Title.enabled=false
            Exit_Title_Screen()
            Init_Flow_Mode_screen()
        endif
    else
        lbl_Receive_Mode_Warning.enabled=true
        tmr_Receive_Warning.enabled=true
    endif

endfunc
init enabled := false
Enddec
Declare but_Hide_15_Sec as ButtonV2
Level 249983
#Visible True
#Lock False
init value := "HIDE ERROR FOR 15 SECS"
init parent := error_popup_screen
init xpos := 15
init ypos := 420
init width := 139
init height := 60
init font := helvb18_bdf

func click()
   Error_Popup_Screen.enabled=false
   tmr_hide_error_display.enabled=true
endfunc
Enddec
Declare but_Ignore_Error as ButtonV2
Level 249996
#Visible True
#Lock False
init value := "IGNORE ERROR"
init parent := error_popup_screen
init xpos := 186
init ypos := 350
init width := 139
init height := 60
init font := helvb18_bdf

func click()
    Error_Popup_Screen.enabled=false
    Hold_This_Error=false
    AlreadyWarnedMaxFlow=false
    AlreadyWarned=false

endfunc
Enddec
Declare but_Initialize as ButtonV2
Level 249467
#Visible True
#Lock False
init value := "INITIALIZE"
init parent := sys_setup_screen
init xpos := 40
init ypos := 71
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Initialize_screen.enabled=true
    Sys_Setup_screen.enabled=false
    But_confirm_Init.enabled=true
    lbl_Setup_Msg.value="Verify valves are open, then press CONFIRM"
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but_Initialize_1 as ButtonV2
Level 249850
#Visible True
#Lock False
init value := "INITIALIZE"
init parent := power_up_screen
init xpos := 180
init ypos := 720
init width := 120
init height := 70
init font := helvb18_bdf

func click()
    Initialize_screen.enabled=true
    But_confirm_Init.enabled=true
    lbl_Setup_Msg.value="Verify valves are open, then press CONFIRM"
    If Power_Up_screen.enabled then
        Title_Screen.enabled=false
        Exit_Power_Up_Screen()
        Cancel_PowerUp()
        Send_GMCcommand("Local=1")
    endif
endfunc
Enddec
Declare but_IP_Address as ButtonV2
Level 249477
#Visible True
#Lock False
init value := "IP ADDRESS"
init parent := sys_setup_screen
init xpos := 100
init ypos := 500
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    Init_IP_Address_screen()

endfunc
init xjustify := hjustify_leftalign
Enddec
Declare but_Limits as ButtonV2
Level 249579
#Visible True
#Lock False
init value := "SET LIMITS"
init parent := flow_mode_screen
init xpos := 370
init ypos := 680
init width := 100
init height := 49
init font := helvb18_bdf

func click()
    If Pressure_Mode_screen.enabled then
        LastScreen="Pressure_mode_screen"
        Pressure_Mode_screen.enabled = false
    endif
    If Flow_mode_screen.enabled then
        LastScreen="Flow_mode_screen"
        Flow_mode_screen.enabled = false
    endif
    If Sys_Setup_screen.enabled then
        LastScreen="Sys_Setup_screen"
        Sys_Setup_screen.enabled=false
    endif
    Init_Limits_screen()
endfunc
Enddec
Declare but_Limits_1 as ButtonV2
Level 249542
#Visible True
#Lock False
init value := "SET LIMITS"
init parent := pressure_mode_screen
init xpos := 130
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    If Pressure_Mode_screen.enabled then
        LastScreen="Pressure_mode_screen"
        Pressure_Mode_screen.enabled = false
    endif
    If Flow_mode_screen.enabled then
        LastScreen="Flow_mode_screen"
        Flow_mode_screen.enabled = false
    endif
    If Sys_Setup_screen.enabled then
        LastScreen="Sys_Setup_screen"
        Sys_Setup_screen.enabled=false
    endif
    Init_Limits_screen()
endfunc
Enddec
Declare but_Limits_2 as ButtonV2
Level 249476
#Visible True
#Lock False
init value := "SET LIMITS"
init parent := sys_setup_screen
init xpos := 100
init ypos := 448
init width := 250
init height := 50
init font := helvb18_bdf

func click()
     If Pressure_Mode_screen.enabled then
        LastScreen="Pressure_mode_screen"
        Pressure_Mode_screen.enabled = false
    endif
    If Flow_mode_screen.enabled then
        LastScreen="Flow_mode_screen"
        Flow_mode_screen.enabled = false
    endif
    If Sys_Setup_screen.enabled then
        LastScreen="Sys_Setup_screen"
        Sys_Setup_screen.enabled=false
    endif
    Init_Limits_screen()
endfunc
init xjustify := hjustify_leftalign
Enddec
Declare but_Limits_3 as ButtonV2
Level 249421
#Visible True
#Lock False
init value := "SET LIMITS"
init parent := profile_screen
init xpos := 130
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    If Pressure_Mode_screen.enabled then
        LastScreen="Pressure_mode_screen"
        Pressure_Mode_screen.enabled = false
    endif
    If Flow_mode_screen.enabled then
        LastScreen="Flow_mode_screen"
        Flow_mode_screen.enabled = false
    endif
    If Sys_Setup_screen.enabled then
        LastScreen="Sys_Setup_screen"
        Sys_Setup_screen.enabled=false
    endif
    If Profile_screen.enabled then
        LastScreen="Profile_screen"
        Profile_screen.enabled=false
    endif

    Init_Limits_screen()
endfunc
Enddec
Declare but_Man_Control as ButtonV2
Level 249827
#Visible True
#Lock False
init value := "MANUAL CONTROL"
init parent := title_screen
init xpos := 300
init ypos := 480
init width := 153
init height := 80
init font := helvb18_bdf

func click()
    If Remote==0 then
        lbl_msg_Title.enabled=false
        Exit_Title_Screen()
        Init_Manual_Control_screen()
    endif
endfunc
Enddec
Declare But_New_Const as ButtonV2
Level 249652
#Visible True
#Lock False
init value := "NEW CONSTANT"
init parent := p_cal_screen
init xpos := 10
init ypos := 365
init width := 170
init height := 50
init font := helvb18_bdf

func click()
    but_zero.enabled=false
    but_accept_Pres_Calc.enabled=false
    but_calculate_constant.enabled=false
    lbl_Calibrate_1.enabled= false
    lbl_Calibrate_2.enabled= false
    lbl_Calibrate_3.enabled= false
    lbl_psi_indicated.enabled=false
    eb_psi_actual.enabled= false
    CalMode=False
    lbl_New_Constant_1.enabled=true
    lbl_New_Constant_2.enabled=true
    eb_fs_volts.enabled=true
    But_Transducer_Select.inactive=false

    lbl_p_cal_msg.value="Enter new value for volts output at full scale."
endfunc
Enddec
Declare but_OK as ButtonV2
Level 249593
#Visible True
#Lock False
init value := "OK"
init parent := config_screen
init xpos := 190
init ypos := 743
init width := 100
init height := 49
init font := helvb18_bdf

func click()
    but_OK.enabled= false
    lbl_Sys_Config_Instructions.value=defaultConfigMsg
endfunc
Enddec
Declare but_OK_Error as ButtonV2
Level 249981
#Visible True
#Lock False
init value := "OK"
init parent := error_popup_screen
init xpos := 186
init ypos := 280
init width := 139
init height := 60
init font := helvb18_bdf

func click()
    AlreadyWarned=false
    AlreadyWarnedMaxFlow=false

    Exit_Error_Popup_Screen()
endfunc
Enddec
Declare But_OK_FactSet as ButtonV2
Level 249785
#Visible True
#Lock False
init value := "OK"
init parent := fact_set_warning_screen
init xpos := 200
init ypos := 325
init width := 80
init height := 49
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#FACTSET,1"
    GMCCommand.executeCommand = true
    Fact_Set_Warning_screen.enabled=false
    lbl_sys_setup_msg.enabled=true
    tmr_Fact_Set.enabled=true
endfunc
Enddec
Declare but_OpenValves as ButtonV2
Level 249540
#Visible True
#Lock False
init value := "OPEN VALVES"
init parent := pressure_mode_screen
init xpos := 370
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        'CODE HERE TO SEND XQ#OpnAll,1
        GMCCommand.command = "XQ#OpnAll,1"
        GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpenValves_1 as ButtonV2
Level 249420
#Visible True
#Lock False
init value := "OPEN VALVES"
init parent := profile_screen
init xpos := 370
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        'CODE HERE TO SEND XQ#OpnAll,1
        GMCCommand.command = "XQ#OpnAll,1"
        GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpenValves_2 as ButtonV2
Level 249582
#Visible False
#Lock False
init value := "OPEN VALVES"
init parent := flow_mode_screen
init xpos := 250
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        'CODE HERE TO SEND XQ#OpnAll,1
        GMCCommand.command = "XQ#OpnAll,1"
        GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpnAIn as ButtonV2
Level 249799
#Visible True
#Lock False
init value := "OPEN"
init parent := valve_screen
init xpos := 230
init ypos := 195
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#OpnAin,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpnAll as ButtonV2
Level 249805
#Visible True
#Lock False
init value := "OPEN ALL"
init parent := valve_screen
init xpos := 50
init ypos := 480
init width := 160
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#OpnAll,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpnAOut as ButtonV2
Level 249796
#Visible True
#Lock False
init value := "OPEN"
init parent := valve_screen
init xpos := 230
init ypos := 95
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#OpnAout,1"
    GMCCommand.executeCommand = true

endfunc
Enddec
Declare but_OpnBIn as ButtonV2
Level 249803
#Visible True
#Lock False
init value := "OPEN"
init parent := valve_screen
init xpos := 230
init ypos := 395
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#OpnBin,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_OpnBout as ButtonV2
Level 249801
#Visible True
#Lock False
init value := "OPEN"
init parent := valve_screen
init xpos := 230
init ypos := 295
init width := 80
init height := 50
init font := helvb18_bdf

func click()
    GMCCommand.command = "XQ#OpnBout,1"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_PCont as ButtonV2
Level 249535
#Visible True
#Lock False
init value := "STOP P CONTROL"
init parent := pressure_mode_screen
init xpos := 320
init ypos := 305
init width := 110
init height := 49
init font := helvb18_bdf

func click()
    If value == "START P CONTROL" then
            'this put in to prevent an immediate push of another button
            'may be set differently later
            but_ZeroXdcrs.enabled=false
            but_CycToStart_1.enabled = false
            but_OpenValves.enabled=false
            but_Set_Mode.enabled=false
            but_Limits_1.enabled=false
        value="STOP P CONTROL"
        P_Stop_Pressed = False
        Start_P_Mode()
    else
        P_Stop_Pressed = true
        Stop_P_Mode()
        lbl_RampStatus.Value = "Pressure Control Mode Stopped"

    endif
endfunc
Enddec
Declare but_PressureCalibration as ButtonV2
Level 249470
#Visible True
#Lock False
init value := "PRESSURE CALIBRATION"
init parent := sys_setup_screen
init xpos := 100
init ypos := 234
init width := 250
init height := 50
init font := helvb18_bdf

func click()
    init_P_Cal_screen()
    Sys_Setup_screen.enabled=false
endfunc

init xjustify := hjustify_leftalign
Enddec
Declare but_PressureMode as ButtonV2
Level 249826
#Visible True
#Lock False
' Enter Pressure Mode screen.
' gmccom_prane.executeCommand=true added to init max range on pressure
init value := "CONSTANT PRESSURE MODE"
init parent := title_screen
init xpos := 300
init ypos := 380
init width := 153
init height := 80
init font := helvb18_bdf

func click()
    If Remote==0 then
        Exit_Title_Screen()
        lbl_msg_Title.enabled=false
        Ptarget=0
        Init_Const_P_Screen()

    endif
endfunc
init enabled := false
Enddec
Declare but_Prev_Error as ButtonV2
Level 249982
#Visible True
#Lock False
init value := "PREVIOUS  ERROR"
init parent := error_popup_screen
init xpos := 15
init ypos := 280
init width := 139
init height := 60
init font := helvb18_bdf

func click()
         ErrorIndex = ErrorIndex + 1
    If ErrorIndex >4 then
        ErrorIndex = 0
    endif
    lbl_ErrNo.value=_FormatFloat(ErrorNoArray[ErrorIndex],3,0,_float_normal)
    Display_Error_Message_Detected(ErrorNoArray[ErrorIndex])
    If ErrorIndex==0 then
        lbl_ErrTime.value= ErrorTime0
    endif
    If ErrorIndex==1 then
        lbl_ErrTime.value= ErrorTime1
    endif
    If ErrorIndex==2 then
        lbl_ErrTime.value= ErrorTime2
    endif
    If ErrorIndex==3 then
        lbl_ErrTime.value= ErrorTime3
    endif
    If ErrorIndex==4 then
        lbl_ErrTime.value= ErrorTime4
    endif
endfunc
Enddec
Declare But_Profile as ButtonV2
Level 249422
#Visible True
#Lock False
init value := "STOP PROFILE"
init parent := profile_screen
init xpos := 15
init ypos := 745
init width := 100
init height := 49
init font := helvb18_bdf

func click()
    if value=="STOP PROFILE" then
        value="START PROFILE"
        lbl_Profile_Msg.value="Stopping Profile"
        tmr_Segment.enabled=false
        tmr_Profile_Times.enabled=false
        NumberofSegments=Current_Segment
        Exit_Segment(Current_Segment)
    else
        value="STOP PROFILE"
        but_Limits_3.enabled=false
        but_OpenValves_1.enabled=false
        but_ZeroXdcrs_1.enabled=false
        but_CycToStart_2.enabled=false
        'put stuff here to start profile
        Start_Profile()
    endif
endfunc
Enddec
Declare but_ProfileMode as ButtonV2
Level 249828
#Visible True
#Lock False
init value := "PROFILE    MODE"
init parent := title_screen
init xpos := 300
init ypos := 580
init width := 153
init height := 80
init font := helvb18_bdf

func click()
    If Remote==0 then
        lbl_msg_Title.enabled=false
        Exit_Title_Screen()
        Init_Profile_Screen()
    endif
endfunc
Enddec
Declare but_psi_per_sec_min as ButtonV2
Level 249544
#Visible True
#Lock False
init value := "psi/sec"
init parent := pressure_mode_screen
init xpos := 355
init ypos := 466
init width := 70
init height := 38
init font := helvb18_bdf
init ptsize := 8

func click()

    dim tempprate as Float

    If value=="psi/sec" then
        value="psi/min"
        eb_PressR.max=12000
        val(tempprate,eb_PressR.Value)
        tempprate=tempprate*60
        eb_PressR.Value=str(tempprate)
        psi_per_sec=false


    Else
        value="psi/sec"
        val(tempprate,eb_PressR.Value)
        tempprate=tempprate/60
        If tempprate < 1 then
            tempprate=1
        endif
        eb_PressR.Value=str(tempprate)
        eb_PressR.max=200
        psi_per_sec=true

    endif
    pv_limits.Save()
endfunc
Enddec
Declare but_QuitFlow as ButtonV2
Level 249574
#Visible True
#Lock False
init value := "   QUIT   FLOW MODE"
init parent := flow_mode_screen
init xpos := 160
init ypos := 745
init width := 160
init height := 49
init font := helvb18_bdf

func click()
 '   Stop_Flow()
    If NOT FlowStopped then
        lbl_Flow_Instructions.value="Stop flow before quiting flow mode."
        Warning_Sound()
        return
    endif
    Exit_Flow_Mode_screen()
endfunc
Enddec
Declare but_QuitPressure as ButtonV2
Level 249537
#Visible True
#Lock False
init value := " QUIT  PRESSURE MODE"
init parent := pressure_mode_screen
init xpos := 150
init ypos := 745
init width := 180
init height := 49
init font := helvb18_bdf

func click()
    If P_Cont_On then
        lbl_Pressure_Msg.value="Please stop pressure control before quitting Pressure Mode."
        Warning_Sound()
        return
    endif
    Exit_Press_Mode_screen()
endfunc
Enddec
Declare but_QuitProfile as ButtonV2
Level 249419
#Visible True
#Lock False
init value := " QUIT  PROFILE MODE"
init parent := profile_screen
init xpos := 140
init ypos := 745
init width := 180
init height := 49
init font := helvb18_bdf

func click()

'Make sure profile is not running
    If but_profile.enabled and but_profile.Value=="STOP PROFILE" then
            lbl_Profile_Msg.value="Stop profile before exiting screen"
            Warning_Sound()

    else
        Exit_Profile_screen()
        Init_Title_screen()
    endif



endfunc
Enddec
Declare but_QuitValveControl as ButtonV2
Level 249795
#Visible True
#Lock False
init value := " QUIT  VALVE CONTROL"
init parent := valve_screen
init xpos := 15
init ypos := 743
init width := 169
init height := 49
init font := helvb18_bdf

func click()
    Valve_Screen.enabled=false
endfunc
Enddec
Declare but_QuitValveControl_1 as ButtonV2
Level 249837
#Visible True
#Lock False
init value := " QUIT  SYSTEM MAINTENANCE"
init parent := system_maintenance_screen
init xpos := 15
init ypos := 743
init width := 169
init height := 49
init font := helvb18_bdf

func click()
    System_Maintenance_Screen.Enabled = False
endfunc
Enddec
Declare But_Ramp as ButtonV2
Level 249541
#Visible True
#Lock False
init value := "START RAMP"
init parent := pressure_mode_screen
init xpos := 200
init ypos := 305
init width := 80
init height := 49
init font := helvb18_bdf

func click()
    dim strCommand as string

    If eb_Target_Press.value =="" then
    lbl_RampStatus.value = "You must set a valid target pressure before you can start."
    warning_sound()
    return
    endif


    If but_ramp.value == "START RAMP" then

    but_CycToStart_1.Enabled = False
    If NOT P_Cont_On then
    return
    else
    Init_Press_Ramp()
    endif
    Set_Press_Buttons()


    elseif but_ramp.value == "PAUSE RAMP" then
    hold_press_ramp()
    Set_Press_Buttons()
    lbl_RampStatus.Value = "Ramp on Hold - Controlling Pressure"

    elseif but_ramp.value == "CONT RAMP" then
    Init_Press_Ramp()
    Set_Press_Buttons()
    lbl_RampStatus.Value = "Ramping to Target Pressure"

    elseif but_ramp.value == "UPDATE RAMP" then
    hold_press_ramp()
    lbl_RampStatus.Value = "Updating Ramp Parameters"
    tmr_Delay_Init_Ramp.enabled=true

    endif

endfunc
Enddec
Declare but_Refill_A as ButtonV2
Level 249908
#Visible True
#Lock False
init value := "REFILL A"
init parent := manual_control_screen
init xpos := 53
init ypos := 218
init width := 169
init height := 50
init font := helvb18_bdf

func click()
    dim strCommand as string
    send_GMCcommand("StReflA=1")
    send_GMCcommand("CONTA=1")
'    strCommand="RefillRA=" + str(RefillRA)
'    send_GMCcommand(strCommand)
'    GMCCommand.command = "XQ#DEFSPD,5"
'    GMCCommand.executeCommand = true
'    send_GMCcommand("RevSpdA=JgSpRA")
    send_GMCcommand("RevSpdA=(RefillRA*CntsPMLA)/60")
    send_GMCcommand("XQ#REFILLA,2")
    lbl_Manual_Control_Msg.value="Cylinder A refilling."
    GMCPoll_StReflA.enabled=true
    but_Refill_A.enabled=false
    but_Aout.enabled=false
    but_AIn.enabled=false
    but_Start_Flow_Man_A.enabled=false
    but_Estop_1.enabled=true
    RefillingA=true
endfunc
Enddec
Declare but_Refill_B as ButtonV2
Level 249907
#Visible True
#Lock False
init value := "REFILL B"
init parent := manual_control_screen
init xpos := 276
init ypos := 218
init width := 169
init height := 50
init font := helvb18_bdf

func click()
    dim strCommand as string
    send_GMCcommand("StReflB=1")
    send_GMCcommand("CONTB=1")
'    strCommand="RefillRB=" + str(RefillRB)
'    send_GMCcommand(strCommand)
'    GMCCommand.command = "XQ#DEFSPD,5"
'    GMCCommand.executeCommand = true
'    send_GMCcommand("RevSpdB=JgSpRB")
    send_GMCcommand("RevSpdB=(RefillRB*CntsPMLA)/60")
    send_GMCcommand("XQ#REFILLB,6")
    lbl_Manual_Control_Msg.value="Cylinder B refilling."
    GMCPoll_StReflB.enabled=true
    but_Refill_B.enabled=false
    but_Bout.enabled=false
    but_BIn.enabled=false
    but_Start_Flow_Man_B.enabled=false
    but_Estop_1.enabled=true
    RefillingB=true
endfunc
Enddec
Declare but_Reset_Maint as ButtonV2
Level 249835
#Visible True
#Lock False
init value := "RESET"
init parent := system_maintenance_screen
init xpos := 254
init ypos := 261
init width := 80
init height := 50
init font := helvb18_bdf

func click()

    CurrentTime=DateTimeFunctions_Maintenance.GetCurrentTime()
    CurrentDate=DateTimeFunctions_Maintenance.GetDateString("dd MMM, yyyy", CurrentTime)
    lbl_Maint_hrs.value = "0.00"
    lbl_date_of_Maint.value = CurrentDate
    MaintHours = 0
    pv_maintenance.Save()

endfunc
Enddec
Declare but_Restart as ButtonV2
Level 249877
#Visible True
#Lock False
init value := "RESTART"
init parent := power_up_screen
init xpos := 345
init ypos := 720
init width := 120
init height := 70
init font := helvb18_bdf

func click()
    Exit_Power_Up_Screen()
        Cancel_PowerUp()
        Send_GMCcommand("Finding=1")
        Send_GMCcommand("XQ#RESTART,1")
        'need to get screen displays correct - show we are intializing and cycling - polling objects set right?
        GMCPoll_Finding_RS.enabled=true
        Init_Popup_Screen.enabled=true

    initcomplete=false
endfunc
Enddec
Declare but_Restart_VPA as ButtonV2
Level 249984
#Visible True
#Lock False
init value := "RESTART PUMP"
init parent := error_popup_screen
init xpos := 186
init ypos := 420
init width := 139
init height := 60
init font := helvb18_bdf

func click()
    I_sent_Restart=true
    Close_All()
    tmr_Profile_Times.enabled=false
    tmr_Segment.enabled=false
    Hold_This_Error=false
    AlreadyWarnedMaxFlow=false
    AlreadyWarned=false
    If P_Cont_On then

        If GMCPoll_Ramping.enabled then
            hold_press_ramp()
        endif
         'Stop P Mode
        Stop_P_Mode()
        P_Cont_On=false
        but_PCont.value="START"
        InitComplete=false
        CycleComplete=false
    endif
    If But_StartFlow.value=="STOP" then
    'Stop motion
        Stop_Flow()
        But_StartFlow.value="START"
'        FlowStopped=true
 '       skb_Flow_Mode.softKeyList=skl_F_Mode_4
     endif
     If not InitComplete then
        GMCPoll_Finding.enabled=false
    endif
    tmr_restart_delay.enabled=true

    tmr_check_connection.enabled=true 'this will initialize the check for powerup etc




endfunc
Enddec
Declare but_Save_Config as ButtonV2
Level 249592
#Visible True
#Lock False
init value := "SAVE NEW CONFIG"
init parent := config_screen
init xpos := 325
init ypos := 743
init width := 139
init height := 49
init font := helvb18_bdf

func click()
    dim TempRevA as float
    dim TempFwdA as float
    dim TempRevB as float
    dim TempFwdB as float
    dim TempAmin as float
    dim TempAmax as float
    dim TempBmin as float
    dim TempBmax as float
    dim TempPmax as float
    dim TempVPC as float
    dim TempRcvStart as Float
    dim TempPmpStart as Float
    dim TempReflPc as Float
    dim TempReflRate as Float
    dim TempInitRate as Float
    check error

        Val(TempAmin,eb_Amin.Value)
        Val(TempAmax,eb_Amax.Value)
        Val(TempBmin,eb_Bmin.Value)
        Val(TempBmax,eb_Bmax.Value)
        Val(TempPmax,eb_Pmax.Value)
        Val(TempVPC,eb_VolPCyl.Value)
        Val(TempPmpStart,eb_start_vol_pump.Value)
        Val(TempRcvStart,eb_start_receive.Value)
        Val(TempReflPc,eb_FillR.Value)
        Val(TempReflRate,eb_ReflRate.Value)
        Val(TempInitRate,eb_InitRate.Value)
    on error
        _ClearException()
    enderr
    If rb_PumpMode.isChecked then
        PmpMode = 1
    else
        PmpMode = 0
    endif

'    If (TempRevA >= TempFwdA) OR (TempRevB >= TempFwdB) then
'        Warning_Sound()
'        'maybe show a message here
'        but_OK.enabled= true
'        lbl_Sys_Config_Instructions.value="Forward Alarm values must be greater than Reverse Alarm Values."
    If (TempAmin >= TempAmax) OR (TempBmin >= TempBmax) then
        Warning_Sound()
        lbl_Sys_Config_Instructions.value="Forward Max values must be greater than Reverse Min values"
        but_OK.enabled= true
    elseif (TempPmax>(1.1*PRange)) then
        Warning_Sound()
        lbl_Sys_Config_Instructions.value="Maximum pressure must be lesss than 1.1 * The pressure trasnducer range"
        but_OK.enabled= true
    elseif (TempVPC>VolumeA) then
        Warning_Sound()
        lbl_Sys_Config_Instructions.value="Volume per Cydle must be less than cylinder volume."
        but_OK.enabled= true
    elseif (TempPmpStart >= (.98*TempAmax)) OR (TempRcvStart >= (.98*TempBmax)) then
        Warning_Sound()
        lbl_Sys_Config_Instructions.value="Start Volume values must be less than .98*Forward Max values"
        but_OK.enabled= true
    elseif (TempPmpStart <= (1.02*TempAmin)) OR (TempRcvStart <= (1.02*TempBmin)) then
        Warning_Sound()
        lbl_Sys_Config_Instructions.value="Start Volume values must be greater than 1.02*Reverse Min values"
        but_OK.enabled= true
    else
        Send_Config()
'        Exit_Config_screen()
    endif
endfunc
Enddec
Declare but_save_n_exit as ButtonV2
Level 249940
#Visible True
#Lock False
init value := "SAVE & EXIT"
init parent := limits_screen
init xpos := 281
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    'Read Values
    check error
        val(PMax,eb_PMax_1.Value)
        val(PMaxWarn,eb_PMax_warn.Value)
        val(FlowRLim,eb_flowrlim_1.Value)
        val(FlowRLimWarn,eb_FlowRLim_Warn.Value)
    on error
        _ClearException()
    enderr
    eb_FlowRLim.Value=_formatfloat(FlowRLim,6,2,_FLOAT_NORMAL)
    if PMaxWarn>Pmax or FlowRLimWarn>FlowRLim then
        lbl_Limits_Msg.value="Warning limits must be lower than shut-down limits."
        return
    endif
    If FlowRLim==0 or FlowRLimWarn==0 then
        lbl_Limits_Msg.value="Flow rate limits must be greater than 0.  The error is triggered when the abolute value of the reported speed exceeds the limit entered."
        Warning_Sound()
        return
    endif
    if but_Enable_warnings.value=="DISABLED" then
       ErrorDisplayDisabled=true
    else
        ErrorDisplayDisabled=false
    endif
    If but_Enable_Open_Valves.value=="ENABLED" then
        Open_Valves_at_Over_Pressure=true
        'send DontOpn=0
        GMCCommand.command = "DontOpn=0"
        GMCCommand.executeCommand = true
        GMCCommand.command = "BV"
        GMCCommand.executeCommand = true

    Else
        Open_Valves_at_Over_Pressure=false
        'send DontOpn=1
        GMCCommand.command = "DontOpn=1"
        GMCCommand.executeCommand = true
        GMCCommand.command = "BV"
        GMCCommand.executeCommand = true
    endif
    'send PMax
    GMCCommand.command = "PMax=" + str(PMax)+";BV"
    GMCCommand.executeCommand = true
    pv_limits.Save()
    Exit_Limits_screen()
endfunc
Enddec
Declare but_Save_Valve_Config as ButtonV2
Level 249816
#Visible True
#Lock False
init value := "SAVE VALVE CONFIG"
init parent := valve_screen
init xpos := 300
init ypos := 743
init width := 169
init height := 49
init font := helvb18_bdf

func click()
    'ADD CODE TO SAVE InVopn value
    dim commandstr as string
    if InVopn then
        commandstr= "InVopn=1"
    else
        commandstr= "InVopn=0"
    endif

    gmccommand.command=commandstr
    gmccommand.executeCommand=true
    'burn value BV
    GMCCommand.command = "BV"
    GMCCommand.executeCommand = true
endfunc
Enddec
Declare but_Set_IP as ButtonV2
Level 249962
#Visible True
#Lock False
init value := "SET"
init parent := ip_address_screen
init xpos := 255
init ypos := 720
init width := 169
init height := 70
init font := helvb18_bdf

func click()
    If rb_DHCP_Enabled.isChecked then
        GMCCommand.command = "DH1;BN"
        GMCCommand.executeCommand = true
    else
        'send IA
        GMCCommand.command = "DH0;IA " + eb_IP_1.value +","+ eb_IP_2.value +","+ eb_IP_3.value +","+eb_IP_4.value +";BN"
        GMCCommand.executeCommand = true
    endif
    IP_Address_Screen.enabled=false
endfunc
Enddec
Declare but_Set_Mode as ButtonV2
Level 249543
#Visible True
#Lock False
init value := "PUMP MODE"
init parent := pressure_mode_screen
init xpos := 10
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    if value=="PUMP MODE" then
        Set_Mode(0)
    Else
        Set_Mode(1)
    endif
endfunc
Enddec
Declare but_Set_Mode_1 as ButtonV2
Level 249580
#Visible True
#Lock False
init value := "PUMP MODE"
init parent := flow_mode_screen
init xpos := 10
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    if value=="PUMP MODE" then
        Set_Mode(0)
    Else
        Set_Mode(1)
    endif
endfunc
Enddec
Declare but_Setup as ButtonV2
Level 249824
#Visible True
#Lock False
init value := "INITIAL SETUP"
init parent := title_screen
init xpos := 300
init ypos := 180
init width := 153
init height := 80
init font := helvb18_bdf

func click()
    If Remote==0 then
        lbl_msg_Title.enabled=false
        Exit_Title_Screen()
        Init_Setup_screen()
        GMCCom_Debug.executeCommand=true
        Setup = True
    endif
endfunc
Enddec
Declare But_Start_Flow_Cal as ButtonV2
Level 249671
#Visible True
#Lock False
init value := "START FLOW"
init parent := vol_cal_screen
init xpos := 304
init ypos := 415
init width := 150
init height := 49
init font := helvb18_bdf

func click()
        InStartPos=false
        If but_start_flow_cal.value=="START FLOW" then
            CalFlowing=True
            GMCCommand.command="FState=1"
            GMCCommand.executeCommand=true
            GMCPoll_FState_Cal.enabled=true
            but_start_flow_cal.value="STOP FLOW"
            GMCCommand.command="Rate=20"
            GMCCommand.executeCommand=true
            but_fill_to_start.enabled=false


            If but_Cylinder_Select.Value=="CYL A" then
                MLstartCal=MLcurA
'                Send MLnewA,XQ#NEWPOSA
                GMCCommand.command="MLnewA="+str(NewML)
                GMCCommand.executeCommand=true

                GMCCommand.command="XQ#NEWPOSA,1"
                GMCCommand.executeCommand=true
            else
                MLstartCal=MLcurB
'                Send MLnewB,XQ#NEWPOSB
                GMCCommand.command="MLnewB="+str(NewML)
                GMCCommand.executeCommand=true

                GMCCommand.command="XQ#NEWPOSB,1"
                GMCCommand.executeCommand=true
            endif

        else
            'Stop motion
            GMCCommand.command="STA;STB;FState=0;HX1"
            GMCCommand.executeCommand=true
            CalFlowing=false
            lbl_vol_cal_msg_b.value="Stopping VPA short of entered target invalidates volume calibration process."
            but_start_flow_cal.value="START FLOW"
            but_start_flow_cal.enabled=false
            but_fill_to_Start.enabled=true
        endif

    but_Accept_Vol_Calc.enabled=false
endfunc
Enddec
Declare but_Start_Flow_Man_A as ButtonV2
Level 249910
#Visible True
#Lock False
init value := "START FLOW - A"
init parent := manual_control_screen
init xpos := 45
init ypos := 585
init width := 175
init height := 60
init font := helvb18_bdf

func click()
    dim strCommand as string

    If value=="START FLOW - A" then
        if but_AOut.Value=="CLOSED" and but_AIn.Value=="CLOSED" then
            lbl_Manual_Control_Msg.value="Either Outlet or Inlet valve must be open"
            Warning_Sound()
            return
        endif
        but_Refill_A.enabled=false
        but_Aout.enabled=false
        but_AIn.enabled=false
        value="STOP FLOW - A"
        send_GMCcommand("FlowingA=1")
        GMCPoll_FlowingA.enabled=true
        check error
            val(FloVolA,eb_tar_vol_a.Value)
        on error
            _ClearException()
        enderr
        If FloVolA>0 then
            FloVolA=-FloVolA
        endif
        strCommand="FloVolA=" + str(FloVolA)
        Send_GMCcommand(strCommand)
        strCommand="FlowRA=" + str(FlowRA)
        send_GMCcommand(strCommand)
        send_GMCcommand("XQ#FLOWA,3")
        lbl_Manual_Control_Msg.value="Cylinder A Flowing"
     else
        but_Refill_A.enabled=true
        but_Aout.enabled=true
        but_AIn.enabled=true
        value="START FLOW - A"
        send_GMCcommand("STA;FlowingA=0;HX3")
        lbl_Manual_Control_Msg.value="Cylinder A Stopped"
        ReadytoFlowA=false
        Set_Manual_Flow_Buttons()
    endif
endfunc
Enddec
Declare but_Start_Flow_Man_B as ButtonV2
Level 249909
#Visible True
#Lock False
init value := "START FLOW - B"
init parent := manual_control_screen
init xpos := 262
init ypos := 585
init width := 175
init height := 60
init font := helvb18_bdf

func click()
     dim strCommand as string

    If value=="START FLOW - B" then
        if but_BOut.Value=="CLOSED" and but_BIn.Value=="CLOSED" then
            lbl_Manual_Control_Msg.value="Either Outlet or Inlet valve must be open"
            Warning_Sound()
            return
        endif
        but_Refill_B.enabled=false
        but_Bout.enabled=false
        but_BIn.enabled=false
        value="STOP FLOW - B"
        send_GMCcommand("FlowingB=1")
        GMCPoll_FlowingB.enabled=true
        check error
            val(FloVolB,eb_tar_vol_b.Value)
        on error
            _ClearException()
        enderr
        If FloVolB>0 then
            FloVolB=-FloVolB
        endif
        strCommand="FloVolB=" + str(FloVolB)
        Send_GMCcommand(strCommand)
        strCommand="FlowRB=" + str(FlowRB)
        send_GMCcommand(strCommand)
        send_GMCcommand("XQ#FLOWB,6")
        lbl_Manual_Control_Msg.value="Cylinder B Flowing"
     else
        but_Refill_B.enabled=true
        but_Bout.enabled=true
        but_BIn.enabled=true
        value="START FLOW - B"
        send_GMCcommand("STB;FlowingB=0;HX6")
        lbl_Manual_Control_Msg.value="Cylinder B Stopped"
        ReadytoFlowB=false
        Set_Manual_Flow_Buttons()
    endif
endfunc
Enddec
Declare But_StartFlow as ButtonV2
Level 249575
#Visible True
#Lock False
init value := "START FLOW"
init parent := flow_mode_screen
init xpos := 190
init ypos := 305
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    IF PcurA<-10 or PcurB<-10 then
        lbl_Flow_Instructions.value = "Pressure values are less than -10, rezero transducers"
'       return
    endif
    If But_StartFlow.value=="STOP" then
        'Stop motion
        Stop_Flow()
        tmr_update_but_delay.enabled=true
        return
    else
        Send_FlowR(mlmax,mlpermin)
        Start_Flow()
        '            Tar_Vol_Reached=false
        Set_Flow_Buttons()
    endif

endfunc
init bgcolor := Clr_ButtonBackground
Enddec
Declare But_Transducer_Select as ButtonV2
Level 249645
#Visible True
#Lock False
init value := "A"
init parent := p_cal_screen
init xpos := 340
init ypos := 97
init width := 90
init height := 43
init font := helvb18_bdf

func click()
    If value=="A" then
        value="B"
        gmccom_vppsib.executeCommand=true
        gmccom_pfsvb.executeCommand=true
        gmcpoll_pcura.enabled=false
        gmcpoll_pcurb.enabled=true
    else
        value="A"
        gmccom_vppsia.executeCommand=true
        gmccom_pfsva.executeCommand=true
        gmcpoll_pcurb.enabled=false
        gmcpoll_pcura.enabled=true
    endif
endfunc
Enddec
Declare but_UpdateFlow as ButtonV2
Level 249576
#Visible True
#Lock False
init value := "UPDATE TO CURRENT SETTINGS"
init parent := flow_mode_screen
init xpos := 141
init ypos := 550
init width := 200
init height := 49


func click()
    Send_FlowR(mlmax,mlpermin)
    Send_GMCcommand("RateChng=1")
    but_UpdateFlow.enabled=false
endfunc
init font := helvb18_bdf
Enddec
Declare But_Valve_Select as ButtonV2
Level 249678
#Visible True
#Lock False
init value := "OUTLET"
init parent := vol_cal_screen
init xpos := 329
init ypos := 146
init width := 92
init height := 43
init font := helvb18_bdf

func click()
    If value=="OUTLET" then
        value="INLET"
    else
        value="OUTLET"
    endif
endfunc
Enddec
Declare But_Zero as ButtonV2
Level 249657
#Visible True
#Lock False
init value := "SET ZERO"
init parent := p_cal_screen
init xpos := 230
init ypos := 580
init width := 100
init height := 50
init font := helvb18_bdf

func click()
    'send "XQ#ZEROV"
    If but_transducer_select.value=="A" then
        GMCCommand.command = "XQ#ZEROVA,1"
        GMCCommand.executeCommand = true
        lbl_p_cal_msg.value="Increase pressure then enter the pressure indicated by the calibration standard."
    endif
    If but_transducer_select.value=="B" then
        GMCCommand.command = "XQ#ZEROVB,1"
        GMCCommand.executeCommand = true
        lbl_p_cal_msg.value="Increase pressure then enter the pressure indicated by the calibration standard."
    endif
    eb_psi_actual.enabled= true
endfunc
Enddec
Declare but_zero_no as ButtonV2
Level 249975
#Visible True
#Lock False
init value := "NO"
init parent := zero_pressure_popup_screen
init xpos := 25
init ypos := 249
init width := 100
init height := 50
init font := helvb18_bdf

func click()

    Zero_Pressure_Popup_Screen.enabled=false

endfunc

init xjustify := hjustify_centeralign
Enddec
Declare but_zero_yes as ButtonV2
Level 249976
#Visible True
#Lock False
init value := "YES"
init parent := zero_pressure_popup_screen
init xpos := 175
init ypos := 249
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        'CODE HERE TO SEND XQ#ZEROBTH,1
        GMCCommand.command = "XQ#ZEROBTH,1"
        GMCCommand.executeCommand = true
        'disable all buttons
    If Flow_Mode_screen.enabled then
        but_Set_Mode_1.inactive=true
        but_limits.inactive=true
        but_zeroVol.inactive=true
        but_cycToStart.inactive=true
        but_updateFlow.inactive=true
        but_StartFlow.inactive=true
        but_QuitFlow.inactive=true
        But_OpenValves_2.inactive=true
    endif
    If Pressure_Mode_screen.enabled then
        but_Set_Mode.inactive=true
        but_limits_1.inactive=true
        but_Ramp.inactive=true
        but_cycToStart_1.inactive=true
        But_OpenValves.inactive=true
        but_Pcont.inactive=true
        but_QuitPressure.inactive=true
    endif
    If Profile_Screen.enabled then
        but_End_Profile_Def.inactive=true
        but_Profile.inactive=true
        but_QuitProfile.inactive=true
        but_limits_3.inactive=true
        but_cycToStart_2.inactive=true
        But_OpenValves_1.inactive=true
    endif
        'start timer to reenable
        tmr_delay_Start.enabled=true
        Zero_Pressure_Popup_Screen.enabled=false
endfunc

init xjustify := hjustify_centeralign
Enddec
Declare but_ZeroVol as ButtonV2
Level 249578
#Visible True
#Lock False
init value := "ZERO VOLUME"
init parent := flow_mode_screen
init xpos := 330
init ypos := 305
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        If NOT GMCPoll_Flowing.enabled then
            GMCCommand.command = "XQ#ZEROML,1"
            GMCCommand.executeCommand = true
        else
            Warning_Sound()
        endif

endfunc
Enddec
Declare but_ZeroXdcrs as ButtonV2
Level 249539
#Visible True
#Lock False
init value := "ZERO P XDCRS"
init parent := pressure_mode_screen
init xpos := 250
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        If PcurA>30 or PcurB>30 then
            Zero_Pressure_Popup_Screen.enabled=true
            return
        endif
        'CODE HERE TO SEND XQ#ZEROBTH,1
        GMCCommand.command = "XQ#ZEROBTH,1"
        GMCCommand.executeCommand = true
        'disable all buttons
        but_Set_Mode.inactive=true
        but_limits_1.inactive=true
        but_Ramp.inactive=true
        but_cycToStart_1.inactive=true
        But_OpenValves.inactive=true
        but_Pcont.inactive=true
        but_QuitPressure.inactive=true
        'start timer to reenable
        tmr_delay_Start.enabled=true
endfunc
Enddec
Declare but_ZeroXdcrs_1 as ButtonV2
Level 249418
#Visible True
#Lock False
init value := "ZERO P XDCRS"
init parent := profile_screen
init xpos := 250
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        If PcurA>30 or PcurB>30 then
            Zero_Pressure_Popup_Screen.enabled=true
            return
        endif
        'CODE HERE TO SEND XQ#ZEROBTH,1
        GMCCommand.command = "XQ#ZEROBTH,1"
        GMCCommand.executeCommand = true
        'disable all buttons
        but_End_Profile_Def.inactive=true
        but_Profile.inactive=true
        but_QuitProfile.inactive=true
        but_limits_3.inactive=true
        but_cycToStart_2.inactive=true
        But_OpenValves_1.inactive=true
        'start timer to reenable
        tmr_delay_Start.enabled=true
endfunc
Enddec
Declare but_ZeroXdcrs_2 as ButtonV2
Level 249581
#Visible True
#Lock False
init value := "ZERO P XDCRS"
init parent := flow_mode_screen
init xpos := 130
init ypos := 680
init width := 100
init height := 50
init font := helvb18_bdf

func click()
        If PcurA>30 or PcurB>30 then
            Zero_Pressure_Popup_Screen.enabled=true
            return
        endif
        'CODE HERE TO SEND XQ#ZEROBTH,1
        GMCCommand.command = "XQ#ZEROBTH,1"
        GMCCommand.executeCommand = true
        'disable all buttons
        but_Set_Mode_1.inactive=true
        but_limits.inactive=true
        but_zeroVol.inactive=true
        but_cycToStart.inactive=true
        but_updateFlow.inactive=true
        but_StartFlow.inactive=true
        but_QuitFlow.inactive=true
        But_OpenValves_2.inactive=true
        'start timer to reenable
        tmr_delay_Start.enabled=true
endfunc
Enddec
Declare cdpl_Current_date as ClockDisplayV2
Level 249843
#Visible True
#Lock False
init parent := system_maintenance_screen
init xpos := 185
init ypos := 385
init fgcolor := clr_screenbackground
init bgcolor := clr_buttonforeground
init font := helvr18_bdf
init showdate := true
init width := 140
init height := 30
init showtime := false
Enddec
Declare Config_screen as ScreenV2
Level 249628
#Visible False
#Lock False
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init borderstyle := bdr_compositeobject
init enabled := false
Enddec
Declare Cycle_Popup_Screen as PopupScreenV2
Level 249980
#Visible False
#Lock False
init xpos := 80
init ypos := 200
init width := 300
init height := 350
init dragmode := _ps_nodrag
init cancelbutton := false
init value := "CYLINDER STROKING"
init font := helvb18_bdf
init xjustify := hjustify_centeralign
init enabled := false
Enddec
Declare DAQ_Objects as ScreenV2
Level 249776
#Visible False
#Lock Me
init parent := default
init xpos := 680
init ypos := 40
init width := 59
init height := 46
init borderstyle := bdr_compositeobject

func screenEnabled()

endfunc
Enddec
Declare DateTimeFunctions_Maintenance as DateTimeFunctions
Level 249842
#Visible True
#Lock False
init parent := system_maintenance_screen
Enddec
Declare ddl_Profile_1 as DropDownListV2
Level 249424
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 319
init width := 139
init height := 34
init selectonpress := true
init selected := 1
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Flow-Time"
init font := helvr18_bdf
init numdropdownrows := 5

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=1
    eb_Rate_Profile_1.enabled=true
    eb_Rate_Profile_1.Value=""
    lbl_Rate_Seg_1.enabled=true
    lbl_Profile_Msg.value="Enter Rate for this segment in units indicated."
    eb_Limit_Profile_1.DecimalPlaces=2
    If Selected==1 then
        lbl_Rate_Seg_1.value="ml/min"
        lbl_Lim_Seg_1.value="min"
        SegTypeArray[1]=1
        eb_Rate_Profile_1.max=frmax
        eb_Limit_Profile_1.max=10000

    endif
    If Selected==2 then
        lbl_Rate_Seg_1.value="ml/min"
        lbl_Lim_Seg_1.value="ml"
        SegTypeArray[1]=2

        eb_Rate_Profile_1.max=frmax
        eb_Limit_Profile_1.max=2000000000

    endif
    If Selected==3 then
        lbl_Rate_Seg_1.value="psi/sec"
        lbl_Lim_Seg_1.value="psi"
        eb_Rate_Profile_1.enabled=true
        SegTypeArray[1]=3

'        eb_Limit_Profile_1.DecimalPlaces=0
        eb_Rate_Profile_1.max=200
        eb_Limit_Profile_1.max=prange
    endif
    If Selected==4 then
        lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
        Selected=3
        SegTypeArray[1]=3
        lbl_Rate_Seg_1.value="psi/sec"
        eb_Rate_Profile_1.enabled=true

'        eb_Limit_Profile_1.DecimalPlaces=0
        eb_Limit_Profile_1.max=200
        eb_Limit_Profile_1.max=prange
    endif

endfunc
Enddec
Declare ddl_Profile_2 as DropDownListV2
Level 249425
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 367
init width := 139
init height := 34
init selectonpress := true
init selected := 2
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Flow-Vol"
init font := helvr18_bdf
init numdropdownrows := 5
init inactive := true

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=2
    eb_Rate_Profile_2.enabled=true
    eb_Rate_Profile_2.Value=""
    lbl_Rate_Seg_2.enabled=true

    eb_Limit_Profile_2.DecimalPlaces=2
    If SegTypeArray[1]== 3 then
            Selected=4
            SegTypeArray[2]=4
            lbl_Rate_Seg_2.enabled=false
            lbl_Lim_Seg_2.enabled=true
            lbl_Lim_Seg_2.value="min"
            eb_Limit_Profile_2.enabled=true
            eb_Rate_Profile_2.enabled=false
            eb_Limit_Profile_2.DecimalPlaces=2
            lbl_Profile_Msg.value="Only a contstant pressure segment can follow a pressure ramp"
            eb_Limit_Profile_2.max=10000
        else
            If Selected==1 then
                lbl_Rate_Seg_2.value="ml/min"
                lbl_Lim_Seg_2.value="min"
                SegTypeArray[2]=1
                eb_Rate_Profile_2.max=frmax
                eb_Rate_Profile_2.DecimalPlaces=3
                eb_Limit_Profile_2.max=10000
            endif
            If Selected==2 then
                lbl_Rate_Seg_2.value="ml/min"
                lbl_Lim_Seg_2.value="ml"
                SegTypeArray[2]=2
                eb_Rate_Profile_2.max=frmax
                eb_Rate_Profile_2.DecimalPlaces=3
                eb_Limit_Profile_2.max=2000000000
            endif
            If Selected==3 then
                lbl_Rate_Seg_2.value="psi/sec"
                lbl_Lim_Seg_2.value="psi"
                SegTypeArray[2]=3
                eb_Rate_Profile_2.enabled=true
               eb_Rate_Profile_2.DecimalPlaces=2
'                eb_Limit_Profile_2.DecimalPlaces=0
                eb_Rate_Profile_2.max=200
                eb_Limit_Profile_2.max=prange
            endif
            If Selected==4 then
                If SegTypeArray[1]== 3 then
                    SegTypeArray[2]=4
                    lbl_Rate_Seg_2.enabled=false
                    lbl_Lim_Seg_2.enabled=true
                    lbl_Lim_Seg_2.value="min"
                    eb_Limit_Profile_2.enabled=true
                    eb_Rate_Profile_2.enabled=false
'                    eb_Limit_Profile_2.DecimalPlaces=0
                    eb_Rate_Profile_2.DecimalPlaces=2
                    eb_Limit_Profile_2.max=10000
                else
                    lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
                    Selected=3
                    lbl_Rate_Seg_2.value="psi/sec"
                    SegTypeArray[2]=3
'                    eb_Rate_Profile_2.DecimalPlaces=0
                    eb_Limit_Profile_2.DecimalPlaces=2
                    eb_Rate_Profile_2.max=200
                    eb_Limit_Profile_2.max=prange
                endif
            endif
        endif
endfunc
Enddec
Declare ddl_Profile_3 as DropDownListV2
Level 249426
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 415
init width := 139
init height := 34
init selectonpress := true
init selected := 3
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Press-Ramp"
init font := helvr18_bdf
init numdropdownrows := 5
init inactive := true

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=3
    eb_Rate_Profile_3.enabled=true
    eb_Rate_Profile_3.Value=""
    lbl_Rate_Seg_3.enabled=true
    eb_Rate_Profile_3.DecimalPlaces=2
    eb_Limit_Profile_3.DecimalPlaces=2
        If SegTypeArray[2]== 3 then
            Selected=4
            SegTypeArray[3]=4
            lbl_Rate_Seg_3.enabled=false
            lbl_Lim_Seg_3.enabled=true
            lbl_Lim_Seg_3.value="min"
            eb_Limit_Profile_3.enabled=true
            eb_Rate_Profile_3.enabled=false
'            eb_Limit_Profile_3.DecimalPlaces=0
            lbl_Profile_Msg.value="Only a contstant pressure segment can follow a pressure ramp"
            eb_Limit_Profile_3.max=10000
        else
            If Selected==1 then
                lbl_Rate_Seg_3.value="ml/min"
                lbl_Lim_Seg_3.value="min"
                SegTypeArray[3]=1
                eb_Rate_Profile_3.max=frmax
                eb_Limit_Profile_3.max=10000
            endif
            If Selected==2 then
                lbl_Rate_Seg_3.value="ml/min"
                lbl_Lim_Seg_3.value="ml"
                SegTypeArray[3]=2
                eb_Rate_Profile_3.max=frmax
                eb_Limit_Profile_3.max=2000000000
            endif
            If Selected==3 then
                lbl_Rate_Seg_3.value="psi/sec"
                lbl_Lim_Seg_3.value="psi"
                SegTypeArray[3]=3
                eb_Rate_Profile_3.enabled=true
'                eb_Rate_Profile_3.DecimalPlaces=0
'                eb_Limit_Profile_3.DecimalPlaces=0
                eb_Rate_Profile_3.max=200
                eb_Limit_Profile_3.max=prange
            endif
            If Selected==4 then
                If SegTypeArray[2]== 3 then
                    SegTypeArray[3]=4
                    lbl_Rate_Seg_3.enabled=false
                    lbl_Lim_Seg_3.enabled=true
                    lbl_Lim_Seg_3.value="min"
                    eb_Limit_Profile_3.enabled=true
                    eb_Rate_Profile_3.enabled=false
'                   eb_Limit_Profile_3.DecimalPlaces=0
                    eb_Limit_Profile_3.max=10000
                else
                    lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
                    Selected=3
                    lbl_Rate_Seg_3.value="psi/sec"
                    SegTypeArray[3]=3
'                    eb_Rate_Profile_3.DecimalPlaces=0
'                    eb_Limit_Profile_3.DecimalPlaces=0
                    eb_Rate_Profile_3.max=200
                    eb_Limit_Profile_3.max=prange
                endif
            endif
        endif
endfunc
Enddec
Declare ddl_Profile_4 as DropDownListV2
Level 249427
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 465
init width := 139
init height := 34
init selectonpress := true
init selected := 4
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Press-Const"
init font := helvr18_bdf
init numdropdownrows := 5
init inactive := true

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=4
    eb_Rate_Profile_4.enabled=true
    eb_Rate_Profile_4.Value=""
    lbl_Rate_Seg_4.enabled=true
    eb_Rate_Profile_4.DecimalPlaces=2
    eb_Limit_Profile_4.DecimalPlaces=2
        If SegTypeArray[3]== 3 then
            Selected=4
            SegTypeArray[4]=4
            lbl_Rate_Seg_4.enabled=false
            lbl_Lim_Seg_4.enabled=true
            lbl_Lim_Seg_4.value="min"
            eb_Limit_Profile_4.enabled=true
            eb_Rate_Profile_4.enabled=false
'            eb_Limit_Profile_4.DecimalPlaces=0
            lbl_Profile_Msg.value="Only a contstant pressure segment can follow a pressure ramp"
            eb_Limit_Profile_4.max=10000
        else
            If Selected==1 then
                lbl_Rate_Seg_4.value="ml/min"
                lbl_Lim_Seg_4.value="min"
                SegTypeArray[4]=1
                eb_Rate_Profile_4.max=frmax
                eb_Limit_Profile_4.max=10000
            endif
            If Selected==2 then
                lbl_Rate_Seg_4.value="ml/min"
                lbl_Lim_Seg_4.value="ml"
                SegTypeArray[4]=2
                eb_Rate_Profile_4.max=frmax
                eb_Limit_Profile_4.max=2000000000
            endif
            If Selected==3 then
                lbl_Rate_Seg_4.value="psi/sec"
                lbl_Lim_Seg_4.value="psi"
                SegTypeArray[4]=3
                eb_Rate_Profile_4.enabled=true
'                eb_Rate_Profile_4.DecimalPlaces=0
'                eb_Limit_Profile_4.DecimalPlaces=0
                eb_Rate_Profile_4.max=200
                eb_Limit_Profile_4.max=prange
            endif
            If Selected==4 then
                If SegTypeArray[3]== 3 then
                    SegTypeArray[4]=4
                    lbl_Rate_Seg_4.enabled=false
                    lbl_Lim_Seg_4.enabled=true
                    lbl_Lim_Seg_4.value="min"
                    eb_Limit_Profile_4.enabled=true
                    eb_Rate_Profile_4.enabled=false
'                    eb_Limit_Profile_4.DecimalPlaces=0
                    eb_Limit_Profile_4.max=10000
                else
                    lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
                    Selected=3
                    lbl_Rate_Seg_4.value="psi/sec"
                    SegTypeArray[4]=3
'                    eb_Rate_Profile_4.DecimalPlaces=0
'                    eb_Limit_Profile_4.DecimalPlaces=0
                    eb_Rate_Profile_4.max=200
                    eb_Limit_Profile_4.max=prange
                endif
            endif
        endif
endfunc
Enddec
Declare ddl_Profile_5 as DropDownListV2
Level 249428
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 515
init width := 139
init height := 34
init selectonpress := true
init selected := 0
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Not Used"
init font := helvr18_bdf
init numdropdownrows := 5
init inactive := true

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=5
    eb_Rate_Profile_5.enabled=true
    eb_Rate_Profile_5.Value=""
    lbl_Rate_Seg_5.enabled=true
    eb_Rate_Profile_5.DecimalPlaces=2
    eb_Limit_Profile_5.DecimalPlaces=2
        If SegTypeArray[4]== 3 then
            Selected=4
            SegTypeArray[5]=4
            lbl_Rate_Seg_5.enabled=false
            lbl_Lim_Seg_5.enabled=true
            lbl_Lim_Seg_5.value="min"
            eb_Limit_Profile_5.enabled=true
            eb_Rate_Profile_5.enabled=false
'            eb_Limit_Profile_5.DecimalPlaces=0
            lbl_Profile_Msg.value="Only a contstant pressure segment can follow a pressure ramp"
            eb_Limit_Profile_5.max=10000
        else
            If Selected==1 then
                lbl_Rate_Seg_5.value="ml/min"
                lbl_Lim_Seg_5.value="min"
                SegTypeArray[5]=1
                eb_Rate_Profile_5.max=frmax
                eb_Limit_Profile_5.max=10000
            endif
            If Selected==2 then
                lbl_Rate_Seg_5.value="ml/min"
                lbl_Lim_Seg_5.value="ml"
                SegTypeArray[5]=2
                eb_Rate_Profile_5.max=frmax
                eb_Limit_Profile_5.max=2000000000
            endif
            If Selected==3 then
                lbl_Rate_Seg_5.value="psi/sec"
                lbl_Lim_Seg_5.value="psi"
                SegTypeArray[5]=3
                eb_Rate_Profile_5.enabled=true
'                eb_Rate_Profile_5.DecimalPlaces=0
'                eb_Limit_Profile_5.DecimalPlaces=0
                eb_Rate_Profile_5.max=200
                eb_Limit_Profile_5.max=prange
            endif
            If Selected==4 then
                If SegTypeArray[4]== 3 then
                    SegTypeArray[5]=4
                    lbl_Rate_Seg_5.enabled=false
                    lbl_Lim_Seg_5.enabled=true
                    lbl_Lim_Seg_5.value="min"
                    eb_Limit_Profile_5.enabled=true
                    eb_Rate_Profile_5.enabled=false
'                    eb_Limit_Profile_5.DecimalPlaces=0
                    eb_Limit_Profile_5.max=10000
                else
                    lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
                    Selected=3
                    lbl_Rate_Seg_5.value="psi/sec"
                    SegTypeArray[5]=3
'                    eb_Rate_Profile_5.DecimalPlaces=0
'                    eb_Limit_Profile_5.DecimalPlaces=0
                    eb_Rate_Profile_5.max=200
                    eb_Limit_Profile_5.max=prange
                endif
            endif
        endif
endfunc
Enddec
Declare ddl_Profile_6 as DropDownListV2
Level 249429
#Visible True
#Lock False
init parent := profile_screen
init xpos := 56
init ypos := 565
init width := 139
init height := 34
init selectonpress := true
init selected := 0
init initiallistcontent := "Not Used;Flow-Time;Flow-Vol;Press-Ramp;Press-Const;"
init curseltext := "Not Used"
init font := helvr18_bdf
init numdropdownrows := 5
init inactive := true

func ValueChanged()
    but_end_Profile_Def.enabled=false
    Segment_Selected=6
    eb_Rate_Profile_6.enabled=true
    eb_Rate_Profile_6.Value=""
    lbl_Rate_Seg_6.enabled=true
    eb_Rate_Profile_6.DecimalPlaces=2
    eb_Limit_Profile_6.DecimalPlaces=2
        If SegTypeArray[5]== 3 then
            Selected=4
            SegTypeArray[6]=4
            lbl_Rate_Seg_6.enabled=false
            lbl_Lim_Seg_6.enabled=true
            lbl_Lim_Seg_6.value="min"
            eb_Limit_Profile_6.enabled=true
            eb_Rate_Profile_6.enabled=false
'            eb_Limit_Profile_6.DecimalPlaces=0
            lbl_Profile_Msg.value="Only a contstant pressure segment can follow a pressure ramp"
            eb_Limit_Profile_6.max=10000
        else
            If Selected==1 then
                lbl_Rate_Seg_6.value="ml/min"
                lbl_Lim_Seg_6.value="min"
                SegTypeArray[6]=1
                eb_Rate_Profile_6.max=frmax
                eb_Limit_Profile_6.max=10000
            endif
            If Selected==2 then
                lbl_Rate_Seg_6.value="ml/min"
                lbl_Lim_Seg_6.value="ml"
                SegTypeArray[6]=2
                eb_Rate_Profile_6.max=frmax
                eb_Limit_Profile_6.max=2000000000
            endif
            If Selected==3 then
                lbl_Rate_Seg_6.value="psi/sec"
                lbl_Lim_Seg_6.value="psi"
                SegTypeArray[6]=3
                eb_Rate_Profile_6.enabled=true
'                eb_Rate_Profile_6.DecimalPlaces=0
'                eb_Limit_Profile_6.DecimalPlaces=0
                eb_Rate_Profile_6.max=200
                eb_Limit_Profile_6.max=prange
            endif
            If Selected==4 then
                If SegTypeArray[5]== 3 then
                    SegTypeArray[6]=4
                    lbl_Rate_Seg_6.enabled=false
                    lbl_Lim_Seg_6.enabled=true
                    lbl_Lim_Seg_6.value="min"
                    eb_Limit_Profile_6.enabled=true
                    eb_Rate_Profile_6.enabled=false
'                    eb_Limit_Profile_6.DecimalPlaces=0
                    eb_Limit_Profile_6.max=10000
                else
                    lbl_Profile_Msg.value="A pressure ramp profile must preceed a constant pressure profile"
                    Selected=3
                    lbl_Rate_Seg_6.value="psi/sec"
                    SegTypeArray[6]=3
'                    eb_Rate_Profile_6.DecimalPlaces=0
'                    eb_Limit_Profile_6.DecimalPlaces=0
                    eb_Rate_Profile_6.max=200
                    eb_Limit_Profile_6.max=prange
                endif
            endif
        endif
endfunc
Enddec
Declare DebugEB as EditBoxV2
Level 249777
#Visible True
#Lock False
init parent := debugscrn
init xpos := 8
init ypos := 8
init width := 464
init height := 312
init boxtype := eb_multilinescroll
init maxlines := 50

init font := helvr12_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init edittype := eb_readonly_scroll
Enddec
Declare DebugScrn as ScreenV2
Level 249780
#Visible False
#Lock False
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := False

func screenEnabled()

endfunc
Enddec
Declare DelimitedComm_1 as DelimitedCommV2
Level 249335
#Visible True
#Lock False

Enddec
Declare eb_Amax as EditBoxV2
Level 249618
#Visible True
#Lock False
init parent := config_screen
init xpos := 250
init ypos := 532
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Amin as EditBoxV2
Level 249619
#Visible True
#Lock False
init parent := config_screen
init xpos := 250
init ypos := 580
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Bmax as EditBoxV2
Level 249620
#Visible True
#Lock False
init parent := config_screen
init xpos := 356
init ypos := 532
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Bmin as EditBoxV2
Level 249621
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 580
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init decimalplaces := 2
init boxtype := eb_numericstrict

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Cal_Start as EditBoxV2
Level 249675
#Visible True
#Lock False
init parent := vol_cal_screen
init xpos := 330
init ypos := 195
init width := 92
init height := 43
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := "18.00"

init usesoftkeybar := false
init maxlines := 1
init min := .01
init max := 20
init charlimit := 4
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc

'
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_dummy as EditBoxV2
Level 249781
#Visible False
#Lock False
init parent := default
init xpos := 664
init ypos := 104
init width := 48
init height := 30
init usesoftkeybar := false

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12

func valueChanged()

endfunc
Enddec
Declare eb_FillR as EditBoxV2
Level 249616
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 158
init width := 75
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 1
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_Flow_Vol as EditBoxV2
Level 249670
#Visible True
#Lock False
init parent := vol_cal_screen
init xpos := 330
init ypos := 244
init width := 92
init height := 43
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := "10.00"

init usesoftkeybar := false
init maxlines := 1
init min := .01
init max := 40
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc

func finishEdit()
    _KeySetFocus(eb_dummy,true)
'    skb_Cal_Rod.softKeyList=skl_Cal_Rod_1
'    lbl_vol_cal_msg_a.value="Press START FLOW and measure volume of fluid expressed."
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_FlowR as EditBoxV2
Level 249573
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 258
init ypos := 428
init width := 96
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "100.00"

init usesoftkeybar := false
init maxlines := 1
init min := .001
init max := 400
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium


init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground

func valueChanged()

endfunc
Enddec
Declare eb_FlowR_A as EditBoxV2
Level 249917
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 66
init ypos := 300
init width := 100
init height := 40
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_FlowR_B as EditBoxV2
Level 249919
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 280
init ypos := 300
init width := 100
init height := 40
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_FlowRLim as EditBoxV2
Level 249534
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 255
init ypos := 515
init width := 96
init height := 48
init fgcolor := clr_screenbackground
init bgcolor := Clr_ButtonForeground
init value := "440"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0
init tone_error := note_medium

func focusOff()
    appendtext = ""
    bgcolor=clr_softkeybarbuttonbg
endfunc
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20

func beginEdit()
    bgcolor=clr_buttonbackground
endfunc

func focusOn()
    bgcolor=clr_buttonbackground
endfunc
init edittype := eb_readonly
Enddec
Declare eb_FlowRLim_1 as EditBoxV2
Level 249943
#Visible True
#Lock False
init parent := limits_screen
init xpos := 275
init ypos := 150
init width := 100
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "100.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_FlowRLim_Warn as EditBoxV2
Level 249942
#Visible True
#Lock False
init parent := limits_screen
init xpos := 275
init ypos := 90
init width := 100
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "100.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_FS_volts as EditBoxV2
Level 249644
#Visible True
#Lock False
init parent := p_cal_screen
init xpos := 266
init ypos := 480
init width := 100
init height := 35
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := "0.0000"
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 1000
init charlimit := 6
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 4

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_InitRate as EditBoxV2
Level 249627
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 306
init width := 75
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 1
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_IP_1 as EditBoxV2
Level 249963
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 95
init ypos := 110
init width := 60
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "192.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 255
init charlimit := 3
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_singleline
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground

init enabled := true
Enddec
Declare eb_IP_2 as EditBoxV2
Level 249964
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 165
init ypos := 110
init width := 60
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "192.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 255
init charlimit := 3
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_singleline
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_IP_3 as EditBoxV2
Level 249965
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 235
init ypos := 110
init width := 60
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "192.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 255
init charlimit := 3
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_singleline
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_IP_4 as EditBoxV2
Level 249966
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 305
init ypos := 110
init width := 60
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "192.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 255
init charlimit := 3
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_singleline
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_Limit_Profile_1 as EditBoxV2
Level 249456
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 319
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 2
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_1.DecimalPlaces=2
    endif
    If ddl_Profile_1.selected==1 then
        SegTimeArray[1]=temp
        TarVolArray[1]=SegRateArray[1]*SegTimeArray[1]
    endif
    If ddl_Profile_1.selected==2 then
        TarVolArray[1]=temp
        SegTimeArray[1]=TarVolArray[1]/SegRateArray[1]
    endif
    If ddl_Profile_1.selected==3 then
        TarPressArray[1]=temp
        SegTimeArray[1]=(TarPressArray[1]/SegRateArray[1])/60
    endif
    lbl_Profile_Segment_1.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_2.bgColor=clr_buttonbackgroundalt
    ddl_Profile_2.inactive=false
    ddl_Profile_1.inactive=true
    eb_Limit_Profile_1.editType=eb_ReadOnly
    lbl_Profile_Msg.value="Select type for Segment 2 or End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_1.Selected==2 then
        eb_Limit_Profile_1.DecimalPlaces=2
    else
        eb_Limit_Profile_1.DecimalPlaces=0
    Endif

    If NumberofSegments<1 then
        NumberofSegments=1
    endif
endfunc
init edittype := eb_readwrite
Enddec
Declare eb_Limit_Profile_2 as EditBoxV2
Level 249457
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 367
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 2
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_2.DecimalPlaces=2
    endif
    If ddl_Profile_2.selected==1 then
        SegTimeArray[2]=temp
        TarVolArray[2]=SegRateArray[2]*SegTimeArray[2]
    endif
    If ddl_Profile_2.selected==2 then
        TarVolArray[2]=temp
        SegTimeArray[2]=TarVolArray[2]/SegRateArray[2]
    endif
    If ddl_Profile_2.selected==3 then
        TarPressArray[2]=temp
        SegTimeArray[2]=(TarPressArray[2]/SegRateArray[2])/60
    endif
    If ddl_Profile_2.selected==4 then
        TarPressArray[2]=TarPressArray[1]
        SegTimeArray[2]=temp
    endif
    lbl_Profile_Segment_2.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_3.bgColor=clr_buttonbackgroundalt
    ddl_Profile_3.inactive=false
    ddl_Profile_2.inactive=true
    eb_Limit_Profile_2.editType=eb_ReadOnly
    lbl_Profile_Msg.value="Select type for Segment 3 or End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_2.Selected==2 then
        eb_Limit_Profile_2.DecimalPlaces=2
    else
        eb_Limit_Profile_2.DecimalPlaces=0
    Endif


    If NumberofSegments<2 then
        NumberofSegments=2
    endif
endfunc
Enddec
Declare eb_Limit_Profile_3 as EditBoxV2
Level 249458
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 415
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 0
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_3.DecimalPlaces=2
    endif
    If ddl_Profile_3.selected==1 then
        SegTimeArray[3]=temp
        TarVolArray[3]=SegRateArray[3]*SegTimeArray[3]
    endif
    If ddl_Profile_3.selected==2 then
        TarVolArray[3]=temp
        SegTimeArray[3]=TarVolArray[3]/SegRateArray[3]
    endif
    If ddl_Profile_3.selected==3 then
        TarPressArray[3]=temp
        SegTimeArray[3]=(TarPressArray[3]/SegRateArray[3])/60
    endif
    If ddl_Profile_3.selected==4 then
        TarPressArray[3]=TarPressArray[2]
        SegTimeArray[3]=temp
    endif
    lbl_Profile_Segment_3.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_4.bgColor=clr_buttonbackgroundalt
    ddl_Profile_4.inactive=false
    ddl_Profile_3.inactive=true
    eb_Limit_Profile_3.editType=eb_ReadOnly
    lbl_Profile_Msg.value="Select type for Segment 4 or End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_3.Selected==2 then
        eb_Limit_Profile_3.DecimalPlaces=2
    else
        eb_Limit_Profile_3.DecimalPlaces=0
    Endif


    If NumberofSegments<3 then
        NumberofSegments=3
    endif
endfunc
Enddec
Declare eb_Limit_Profile_4 as EditBoxV2
Level 249459
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 465
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 0
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_4.DecimalPlaces=2
    endif
    If ddl_Profile_4.selected==1 then
        SegTimeArray[4]=temp
        TarVolArray[4]=SegRateArray[4]*SegTimeArray[4]
    endif
    If ddl_Profile_4.selected==2 then
        TarVolArray[4]=temp
        SegTimeArray[4]=TarVolArray[4]/SegRateArray[4]
    endif
    If ddl_Profile_4.selected==3 then
        TarPressArray[4]=temp
        SegTimeArray[4]=(TarPressArray[4]/SegRateArray[4])/60
    endif
    If ddl_Profile_4.selected==4 then
        TarPressArray[4]=TarPressArray[3]
        SegTimeArray[4]=temp
    endif
    lbl_Profile_Segment_4.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_5.bgColor=clr_buttonbackgroundalt
    ddl_Profile_5.inactive=false
    ddl_Profile_4.inactive=true
    eb_Limit_Profile_4.editType=eb_ReadOnly
    lbl_Profile_Msg.value="Select type for Segment 5 or End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_4.Selected==2 then
        eb_Limit_Profile_4.DecimalPlaces=2
    else
        eb_Limit_Profile_4.DecimalPlaces=0
    Endif

    If NumberofSegments<4 then
        NumberofSegments=4
    endif
endfunc
Enddec
Declare eb_Limit_Profile_5 as EditBoxV2
Level 249460
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 515
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 2
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_5.DecimalPlaces=2
    endif
    If ddl_Profile_5.selected==1 then
        SegTimeArray[5]=temp
        TarVolArray[5]=SegRateArray[5]*SegTimeArray[5]
    endif
    If ddl_Profile_5.selected==2 then
        TarVolArray[5]=temp
        SegTimeArray[5]=TarVolArray[5]/SegRateArray[5]
    endif
    If ddl_Profile_5.selected==3 then
        TarPressArray[5]=temp
        SegTimeArray[5]=(TarPressArray[5]/SegRateArray[5])/60
    endif
    If ddl_Profile_5.selected==4 then
        TarPressArray[5]=TarPressArray[4]
        SegTimeArray[5]=temp
    endif
    lbl_Profile_Segment_5.bgColor=clr_softkeybarbackground
    lbl_Profile_Segment_6.bgColor=clr_buttonbackgroundalt
    ddl_Profile_6.inactive=false
    ddl_Profile_5.inactive=true
    eb_Limit_Profile_5.editType=eb_ReadOnly
    lbl_Profile_Msg.value="Select type for Segment 6 or End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_5.Selected==2 then
        eb_Limit_Profile_5.DecimalPlaces=2
    else
        eb_Limit_Profile_5.DecimalPlaces=0
    Endif

    If NumberofSegments<5 then
        NumberofSegments=5
    endif
endfunc
Enddec
Declare eb_Limit_Profile_6 as EditBoxV2
Level 249461
#Visible True
#Lock False
init parent := profile_screen
init xpos := 326
init ypos := 565
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 2
init font := helvb24_bdf

func valueChanged()
    dim temp as float

    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero limit"
        Warning_Sound()
        return
    endif

    'Calculate segment time, enable the next segment, etc
    Check Error
        Val(temp,value)
    on error
        _ClearException()
    enderr
    if temp<=1000 then
        eb_Limit_Profile_6.DecimalPlaces=2
    endif
    If ddl_Profile_6.selected==1 then
        SegTimeArray[6]=temp
        TarVolArray[6]=SegRateArray[6]*SegTimeArray[6]
    endif
    If ddl_Profile_6.selected==2 then
        TarVolArray[6]=temp
        SegTimeArray[6]=TarVolArray[6]/SegRateArray[6]
    endif
    If ddl_Profile_6.selected==3 then
        TarPressArray[6]=temp
        SegTimeArray[6]=(TarPressArray[6]/SegRateArray[6])/60
    endif
    If ddl_Profile_6.selected==4 then
        TarPressArray[6]=TarPressArray[6]
        SegTimeArray[6]=temp
    endif
    lbl_Profile_Segment_6.bgColor=clr_softkeybarbackground

    ddl_Profile_6.inactive=true

    lbl_Profile_Msg.value="All 6 segments have been defined.End Definition"
    but_end_Profile_Def.enabled=true

    If temp < 100 and ddl_Profile_6.Selected==2 then
        eb_Limit_Profile_6.DecimalPlaces=2
    else
        eb_Limit_Profile_6.DecimalPlaces=0
    Endif

    If NumberofSegments<6 then
        NumberofSegments=6
    endif
endfunc
Enddec
Declare eb_Max_Error as EditBoxV2
Level 249496
#Visible True
#Lock False
init parent := kprop_screen
init xpos := 208
init ypos := 219
init width := 80
init height := 35
init value := ""

init xjustify := hjustify_center
init yjustify := vjustify_center
init usesoftkeybar := false
init min := 0
init max := 5000
init bgcolor := clr_screenbackground
init boxtype := eb_numericstrict
init charlimit := 6
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_ml_measured as EditBoxV2
Level 249669
#Visible True
#Lock False
init parent := vol_cal_screen
init xpos := 340
init ypos := 529
init width := 100
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 5000
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc




init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_New_Dgain as EditBoxV2
Level 249504
#Visible True
#Lock False
init parent := kprop_screen
init xpos := 192
init ypos := 118
init width := 96
init height := 35
init value := ""

init xjustify := hjustify_center
init yjustify := vjustify_center
init usesoftkeybar := false
init min := 0
init max := 100000
init bgcolor := clr_screenbackground
init boxtype := eb_numericstrict
init charlimit := 6
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_New_Igain as EditBoxV2
Level 249503
#Visible True
#Lock False
init parent := kprop_screen
init xpos := 192
init ypos := 166
init width := 96
init height := 35
init value := ""

init xjustify := hjustify_center
init yjustify := vjustify_center
init usesoftkeybar := false
init min := 0
init max := 100000
init bgcolor := clr_screenbackground
init boxtype := eb_numericstrict
init charlimit := 6
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_New_Kprop as EditBoxV2
Level 249495
#Visible True
#Lock False
init parent := kprop_screen
init xpos := 192
init ypos := 17
init width := 96
init height := 35
init value := ""

init xjustify := hjustify_center
init yjustify := vjustify_center
init usesoftkeybar := false
init min := 0
init max := 100000
init bgcolor := clr_screenbackground
init boxtype := eb_numericstrict
init charlimit := 6
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_New_Kx as EditBoxV2
Level 249498
#Visible True
#Lock False
init parent := kprop_screen
init xpos := 192
init ypos := 67
init width := 96
init height := 35
init value := ""

init xjustify := hjustify_center
init yjustify := vjustify_center
init usesoftkeybar := false
init min := 0
init max := 100000
init bgcolor := clr_screenbackground
init boxtype := eb_numericstrict
init charlimit := 6
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_Pmax as EditBoxV2
Level 249614
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 108
init width := 75
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := default
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_PMax_1 as EditBoxV2
Level 249944
#Visible True
#Lock False
init parent := limits_screen
init xpos := 276
init ypos := 303
init width := 100
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "10000.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_PMax_warn as EditBoxV2
Level 249945
#Visible True
#Lock False
init parent := limits_screen
init xpos := 276
init ypos := 243
init width := 100
init height := 48
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "5000"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_PressR as EditBoxV2
Level 249533
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 255
init ypos := 461
init width := 96
init height := 48
init fgcolor := 0
init bgcolor := clr_softkeybarbuttonbg
init value := "200"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 200
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0
init tone_error := note_medium

func focusOff()
    appendtext = ""
    bgcolor=clr_softkeybarbuttonbg
endfunc
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20

func beginEdit()
    bgcolor=clr_buttonbackground
endfunc

func focusOn()
    bgcolor=clr_buttonbackground
endfunc
Enddec
Declare eb_psi_actual as EditBoxV2
Level 249633
#Visible True
#Lock False
init parent := p_cal_screen
init xpos := 310
init ypos := 480
init width := 100
init height := 35
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := "0.00"
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 10000
init charlimit := 6
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Rate_Profile_1 as EditBoxV2
Level 249430
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 319
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := "25.000"
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_1.Value=""
    eb_Limit_Profile_1.enabled=true
    lbl_Lim_Seg_1.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_1.editType=eb_ReadOnly
    ddl_Profile_1.inactive=true

    Check Error
        Val(SegRateArray[1],value)
    on error
        _ClearException()
    enderr

    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_1.selected==1) or (ddl_Profile_1.selected==2) then
        if SegRateArray[1] < 1 then
            eb_Rate_Profile_1.DecimalPlaces=3
        else
            eb_Rate_Profile_1.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_1.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_Rate_Profile_2 as EditBoxV2
Level 249431
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 367
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := "20.000"
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_2.Value=""
    eb_Limit_Profile_2.enabled=true
    lbl_Lim_Seg_2.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_2.editType=eb_ReadOnly
    ddl_Profile_2.inactive=true

    Check Error
        Val(SegRateArray[2],value)
    on error
        _ClearException()
    enderr
    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_2.selected==1) or (ddl_Profile_2.selected==2) then
        if SegRateArray[2] < 1 then
            eb_Rate_Profile_2.DecimalPlaces=3
        else
            eb_Rate_Profile_2.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_2.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_Rate_Profile_3 as EditBoxV2
Level 249432
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 415
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := "0.980"
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_3.Value=""
    eb_Limit_Profile_3.enabled=true
    lbl_Lim_Seg_3.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_3.editType=eb_ReadOnly
    ddl_Profile_3.inactive=true

    Check Error
        Val(SegRateArray[3],value)
    on error
        _ClearException()
    enderr
    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_3.selected==1) or (ddl_Profile_3.selected==2) then
        if SegRateArray[3] < 1 then
            eb_Rate_Profile_3.DecimalPlaces=3
        else
            eb_Rate_Profile_3.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_3.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_Rate_Profile_4 as EditBoxV2
Level 249433
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 465
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := "2500.000"
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_4.Value=""
    eb_Limit_Profile_4.enabled=true
    lbl_Lim_Seg_4.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_4.editType=eb_ReadOnly
    ddl_Profile_4.inactive=true

    Check Error
        Val(SegRateArray[4],value)
    on error
        _ClearException()
    enderr
    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_4.selected==1) or (ddl_Profile_4.selected==2) then
        if SegRateArray[4] < 1 then
            eb_Rate_Profile_4.DecimalPlaces=3
        else
            eb_Rate_Profile_4.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_4.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_Rate_Profile_5 as EditBoxV2
Level 249434
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 515
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_5.Value=""
    eb_Limit_Profile_5.enabled=true
    lbl_Lim_Seg_5.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_5.editType=eb_ReadOnly
    ddl_Profile_5.inactive=true

    Check Error
        Val(SegRateArray[5],value)
    on error
        _ClearException()
    enderr
    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_5.selected==1) or (ddl_Profile_5.selected==2) then
        if SegRateArray[5] < 1 then
            eb_Rate_Profile_5.DecimalPlaces=3
        else
            eb_Rate_Profile_5.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_5.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_Rate_Profile_6 as EditBoxV2
Level 249435
#Visible True
#Lock False
init parent := profile_screen
init xpos := 204
init ypos := 565
init width := 80
init height := 34
init boxtype := eb_numericstrict
init value := ""
init min := 0
init max := default
init maxlines := 1
init autoedit := false
init xjustify := hjustify_centeralign
init decimalplaces := 3
init font := helvb24_bdf

func valueChanged()
    if Value=="0" then
        lbl_Profile_Msg.value="Enter non-zero rate"
        Warning_Sound()
        return
    endif
'    eb_Limit_Profile_6.Value=""
    eb_Limit_Profile_6.enabled=true
    lbl_Lim_Seg_6.enabled=true
    lbl_Profile_Msg.value="Enter Limit value for this segment in units indicated."
    eb_Rate_Profile_6.editType=eb_ReadOnly
    ddl_Profile_6.inactive=true

    Check Error
        Val(SegRateArray[6],value)
    on error
        _ClearException()
    enderr
    'allow 3 decimal places if rate is less than 1 in flow
    if (ddl_Profile_6.selected==1) or (ddl_Profile_6.selected==2) then
        if SegRateArray[6] < 1 then
            eb_Rate_Profile_6.DecimalPlaces=3
        else
            eb_Rate_Profile_6.DecimalPlaces=2
        endif
    else
        eb_Rate_Profile_6.DecimalPlaces=2
    endif
endfunc
Enddec
Declare eb_RefillR_A as EditBoxV2
Level 249925
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 66
init ypos := 450
init width := 100
init height := 40
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "100.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_RefillR_B as EditBoxV2
Level 249926
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 280
init ypos := 450
init width := 100
init height := 40
init fgcolor := 0
init bgcolor := clr_buttonbackground
init value := "100.00"

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_ReflRate as EditBoxV2
Level 249623
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 208
init width := 75
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 1
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0

func focusOff()
    appendtext = ""
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare eb_Start_Receive as EditBoxV2
Level 249622
#Visible True
#Lock False
init parent := config_screen
init xpos := 280
init ypos := 484
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Start_Vol_Pump as EditBoxV2
Level 249617
#Visible True
#Lock False
init parent := config_screen
init xpos := 283
init ypos := 436
init width := 96
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""
init font := helvb18_bdf
init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
Enddec
Declare eb_Tar_Vol as EditBoxV2
Level 249572
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 258
init ypos := 481
init width := 144
init height := 48
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := 100000
init charlimit := 7
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_singleline
init decimalplaces := 2
init tone_error := note_medium


init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground

func valueChanged()

endfunc
Enddec
Declare eb_tar_vol_a as EditBoxV2
Level 249916
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 68
init ypos := 375
init width := 100
init height := 40
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium


init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_tar_vol_b as EditBoxV2
Level 249918
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 288
init ypos := 375
init width := 100
init height := 40
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 0
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2
init tone_error := note_medium


init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init borderstyle := bdr_tabborder
init cursorcolor := clr_buttonforeground
Enddec
Declare eb_Target_Press as EditBoxV2
Level 249532
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 255
init ypos := 405
init width := 96
init height := 48
init fgcolor := clr_buttonforeground
init bgcolor := clr_screenbackground
init value := "20"

init usesoftkeybar := false
init maxlines := 1
init min := 20
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 0
init tone_error := note_medium


func focusOff()
    appendtext = ""
endfunc
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20



func valueChanged()
    dim TargetPress as integer
    'gmccom_pmax.executecommand = true
    check error
            val(TargetPress, Value)
        on error
            _ClearException()
        enderr

    if TargetPress > PMax then
        lbl_RampStatus.Value="Target Pressure must be less than PMax Limit"
        TargetPress=.99*PMax
        eb_Target_Press.value= _formatfloat(TargetPress,6,2,_FLOAT_NORMAL)
        Warning_Sound()
    endif


endfunc
Enddec
Declare eb_VolPCyl as EditBoxV2
Level 249615
#Visible True
#Lock False
init parent := config_screen
init xpos := 360
init ypos := 258
init width := 75
init height := 30
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
init value := ""

init usesoftkeybar := false
init maxlines := 1
init min := 1
init max := default
init charlimit := 5
init xjustify := hjustify_center
init yjustify := vjustify_center
init boxtype := eb_numericstrict
init decimalplaces := 2

func focusOff()
    appendtext = ""
endfunc
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare elps_A as RectangleV2
Level 249563
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 13
init ypos := 95
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_A_1 as RectangleV2
Level 249524
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 13
init ypos := 85
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_A_2 as RectangleV2
Level 249398
#Visible True
#Lock False
init parent := profile_screen
init xpos := 13
init ypos := 85
init width := 20
init height := 16
init bgcolor := 20
Enddec
Declare elps_A_3 as RectangleV2
Level 249376
#Visible True
#Lock False
init parent := remote_display
init xpos := 13
init ypos := 95
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_b as RectangleV2
Level 249564
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 443
init ypos := 95
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_B_1 as RectangleV2
Level 249525
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 443
init ypos := 85
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_B_2 as RectangleV2
Level 249399
#Visible True
#Lock False
init parent := profile_screen
init xpos := 443
init ypos := 85
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare elps_b_3 as RectangleV2
Level 249375
#Visible True
#Lock False
init parent := remote_display
init xpos := 443
init ypos := 95
init width := 20
init height := 16
init bgcolor := 161
Enddec
Declare Error_Log_EB as EditBoxV2
Level 249483
#Visible True
#Lock False
init parent := error_log_screen
init xpos := 35
init ypos := 106
init width := 410
init height := 566
init boxtype := eb_multilinescroll
init font := helvb12_bdf
Enddec
Declare Error_Log_Screen as ScreenV2
Level 249484
#Visible True
#Lock False
init parent := default
init xpos := -1
init ypos := -4
init width := 480
init height := 800
init enabled := False
init bgcolor := clr_buttonbackgroundalt

func screenEnabled()


endfunc
Enddec
Declare Error_Popup_Screen as PopupScreenV2
Level 249997
#Visible False
#Lock False
init xpos := 70
init ypos := 40
init width := 340
init height := 487
init titleheight := 50
init value := "ERROR DETECTED"
init xjustify := hjustify_center
init font := helvb24_bdf
init cancelbutton := false
init titlefgcolor := clr_buttonforeground
init titlebgcolor := 225
init enabled := false
Enddec
Declare ExceptionDisplay as ExceptionDisplayV2
Level 249365
#Visible False
#Lock False
init font := default_ttf
init ptsize := 12
Enddec
Declare Fact_Set_Warning_screen as ScreenV2
Level 249787
#Visible False
#Lock False
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := False
init bgcolor := clr_labelbackground
Enddec
Declare Flow_mode_screen as ScreenV2
Level 249583
#Visible False
#Lock Me
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := false
init bgcolor := clr_buttonbackgroundalt
Enddec
Declare G_55_PopupMenu_1 as G55PopupMenu
Level 249336
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_2
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_2 as G55PopupMenu
Level 249337
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_3
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_3 as G55PopupMenu
Level 249338
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_4
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_4 as G55PopupMenu
Level 249339
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_5
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_5 as G55PopupMenu
Level 249340
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_6
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_6 as G55PopupMenu
Level 249341
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_7
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_7 as G55PopupMenu
Level 249342
#Visible True
#Lock False
    init mainsubmenu := g_55_popupmenu_8
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare G_55_PopupMenu_8 as G55PopupMenu
Level 249343
#Visible True
#Lock False
    init initialselected := 0

    func itemselected(selecteditem as integer, id as integer)
        _G55_Curr_SoftKeyInfo.itemSelected(id)
    endfunc
init font := helvr18_bdf
init height := 20
init ptsize := 7
init width := 20
init xpos := 0
init ypos := -80
Enddec
Declare GalilComm as GalilCommV2
Level 249788
#Visible True
#Lock Me
init connectiontype := gmc_useserial
init serialformat := gmc_use_default
init messagefilter := _cc_suppressallmessages


init messagefont := default_ttf
init messageptsize := 12
init connectatstartup := false
Enddec
Declare GalilStartCom as TimerV2
Level 249831
#Visible False
#Lock False
init timertype := _tt_oneshot

func timeout()
    GalilComm.OpenChannel()
endfunc
Enddec
Declare Gauge_VolumeA as GaugeV2
Level 249527
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 15
init ypos := 110
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeA_1 as GaugeV2
Level 249561
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 15
init ypos := 125
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeA_2 as GaugeV2
Level 249851
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 8
init ypos := 110
init width := 15
init height := 600
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeA_3 as GaugeV2
Level 249904
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 8
init ypos := 110
init width := 15
init height := 600
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeA_4 as GaugeV2
Level 249400
#Visible True
#Lock False
init parent := profile_screen
init xpos := 15
init ypos := 110
init width := 15
init height := 550
init direction := move_down
init value := 25

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeA_5 as GaugeV2
Level 249378
#Visible True
#Lock False
init parent := remote_display
init xpos := 15
init ypos := 125
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB as GaugeV2
Level 249526
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 445
init ypos := 110
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB_1 as GaugeV2
Level 249562
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 444
init ypos := 125
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB_2 as GaugeV2
Level 249852
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 457
init ypos := 110
init width := 15
init height := 600
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB_3 as GaugeV2
Level 249905
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 456
init ypos := 110
init width := 15
init height := 600
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB_4 as GaugeV2
Level 249401
#Visible True
#Lock False
init parent := profile_screen
init xpos := 445
init ypos := 110
init width := 15
init height := 550
init direction := move_down
init value := 90

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare Gauge_VolumeB_5 as GaugeV2
Level 249377
#Visible True
#Lock False
init parent := remote_display
init xpos := 444
init ypos := 125
init width := 15
init height := 550
init direction := move_down
init value :=10

init font := helvr18_bdf
init ptsize := 12
Enddec
Declare GMCcom_Amax as GMCCommandExecV2
Level 249734
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Amax"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(Amax,temp)
    on error
            _ClearException()
    enderr
    eb_Amax.Value=_FormatFloat(Amax,6,2,_FLOAT_NORMAL)
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Amin as GMCCommandExecV2
Level 249733
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Amin"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(Amin,temp)
    on error
            _ClearException()
    enderr
    eb_Amin.Value=_FormatFloat(Amin,6,2,_FLOAT_NORMAL)
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Bmax as GMCCommandExecV2
Level 249736
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Bmax"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(Bmax,temp)
    on error
            _ClearException()
    enderr
    eb_Bmax.Value=_FormatFloat(Bmax,6,2,_FLOAT_NORMAL)
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Bmin as GMCCommandExecV2
Level 249735
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Bmin"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
   check error
            Val(Bmin,temp)
    on error
            _ClearException()
    enderr
    eb_Bmin.Value=_FormatFloat(Bmin,6,2,_FLOAT_NORMAL)
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_CyclDone3 as GMCCommandExecV2
Level 249759
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG CyclDone"

func ResponseReceived(response as string)
    Dim strTime as String
    Dim CyclDone as float
    check error
         val(CyclDone,response)

    on error
        _ClearException()
    enderr
   If CyclDone > 0 then
        'We need to initiate Title screen with Init and cycle complete
        InitComplete=true
        CycleComplete=true
        Init_Title_screen()
'        skb_title.enabled=true
'        skb_title.softKeyList=skl_Title_2

'#fix commeted out
'        If not Exiting_Remote then
'            lbl_msg_title.value="Operator Terminal Rebooted Unexpectedly"
'            lbl_msg_title.enabled=true
'        endif

    Else 'we are not in pressure control mode, flow mode and cycle has not been completed
        GMCcom_InitDone4.executeCommand=true
    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
init enabled := false
Enddec
Declare GMCCom_Debug as GMCCommandExecV2
Level 249774
#Visible True
#Lock False
init parent := daq_objects
init commobject := galilcomm
init command := "MG Debug"

func ResponseReceived(response as string)
    dim temp as float
    dim respstr as string


    respstr = Clip_String(response,2)

    check error
             Val(temp,respstr)
    on error
            _ClearException()
    enderr
    if temp==1 then
        but_Debug.enabled=true
    else
        but_debug.enabled=false
    endif

endfunc
Enddec
Declare GMCcom_Dgain as GMCCommandExecV2
Level 249699
#Visible True
#Lock False
func ResponseReceived(response as string)
    dim temp as string
     dim Dgain as float

    temp = Clip_String(response,2)
    check error
            Val(Dgain,temp)
    on error
            _ClearException()
    enderr
    lbl_Dgain_cur.Value=_FormatFloat(Dgain,6,1,_FLOAT_NORMAL)
    eb_new_Dgain.Value=_FormatFloat(Dgain,6,1,_FLOAT_NORMAL)
endfunc

init parent := daq_objects
init command := "MG Dgain"
init commobject := galilcomm
Enddec
Declare GMCcom_DH as GMCCommandExecV2
Level 249764
#Visible True
#Lock False
init commobject := galilcomm
init command := "DH?"

func ResponseReceived(response as string)

    check error
         val(DH,response)
    on error
        _ClearException()
    enderr

    If DH== 1 then
        rb_DHCP_Enabled.isChecked=true
        eb_IP_1.enabled=false
        eb_IP_2.enabled=false
        eb_IP_3.enabled=false
        eb_IP_4.enabled=false

    else
        rb_DHCP_Disabled.isChecked=true
        eb_IP_1.enabled=true
        eb_IP_2.enabled=true
        eb_IP_3.enabled=true
        eb_IP_4.enabled=true
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_Emax as GMCCommandExecV2
Level 249702
#Visible True
#Lock False
func ResponseReceived(response as string)
    dim temp as string
     dim Emax as float

    temp = Clip_String(response,2)
    check error
            Val(Emax,temp)
    on error
            _ClearException()
    enderr

    eb_Max_Error.Value=_FormatFloat(Emax,6,0,_FLOAT_NORMAL)
    lbl_Maxerror_cur.value=_formatfloat(Emax,6,0,_FLOAT_NORMAL)
endfunc

init command := "MG Emax"
init commobject := galilcomm
init parent := daq_objects
Enddec
Declare GMCCom_ErrCode as GMCCommandExecV2
Level 249771
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG ErrCode"
init enabled := true

func ResponseReceived(response as string)
     dim ErrorCode as float
    dim respstr as string

    respstr = Clip_String(response,2)

    check error
             Val(ErrorCode,respstr)
    on error
            _ClearException()
    enderr
    lbl_ErrCode.value=_FormatFloat(ErrorCode,2,0,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_ErrMsg as GMCCommandExecV2
Level 249755
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG ErrMsg"

func ResponseReceived(response as string)
    Dim strTime as String
    Dim temp as float
    check error
         val(temp,response)

    on error
        _ClearException()
    enderr
    ErrNo=temp
    If ErrNo > 0 then
        Handle_Error(ErrNo)
    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
init enabled := false
Enddec
Declare GMCcom_FillR as GMCCommandExecV2
Level 249744
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG ReflPc"

func ResponseReceived(response as string)
    check error
            val(RevFlowRmax,response)
    on error
            _ClearException()
    enderr
    eb_fillr.value=_FormatFloat(RevFlowRmax,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCCom_First_PowerUP as GMCCommandExecV2
Level 249756
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG PowerUp,Remote"
init enabled := true

func ResponseReceived(response as string)
    dim tmpPowerUp as float
    dim tmpRemote as float
    dim PUstr as string
    dim idx as integer
    dim Remotestr as string
    dim respstr as string

    idx:=find(response,0,-1," ")
    PUstr=left(response,idx)
    Remotestr:=Mid(response,idx+1,-1)

    check error
        Val(tmpPowerUp,PUstr)
        Val(tmpRemote,Remotestr)
    on error
        _ClearException()
    enderr
    if tmpPowerUp==0 then ' just the terminal is powering up start the process of finding current Galil State
        'Query PState First, FState, CyclDone, and InitDone in order till we find correct state
        If tmpRemote >0 then
            GMCPoll_Remote.enabled=true
        else
            GMCcom_PState1.executeCommand=true
            tmrPowerUp.enabled=true
            GMCPoll_NewErr.enabled=true
        endif
    elseif tmpPowerUp==1 then  ' Galil is powering up as well- display Power Up screen
        Init_Power_Up_Screen()
    else
        REM Bad data
        debugText="Value of PowerUp read as "+str(tmpPowerUp)
        Write_To_Debug(debugText, "GMCCOM_PowerUP")

    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_FRMax as GMCCommandExecV2
Level 249751
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG FRMax"

func ResponseReceived(response as string)

    check error
         val(FRMax,response)
    on error
        _ClearException()
    enderr
    eb_FlowR.max=FRMax
    eb_FlowR_A.max=FRMax
    eb_FlowR_B.max=FRMax
    eb_RefillR_A.max=FRMax
    eb_RefillR_B.max=FRMax
    eb_FlowRLim.max=FRMax*1.1
    eb_flowrlim_1.max=FRMax*1.1
    eb_FlowRLim_Warn.max=FRMax*1.1
    eb_FillR.max=FRMax
    eb_ReflRate.max=FRMax
    eb_InitRate.max=FRMax
    If FlowRLim==0 then
        FlowRLim=FRMax
    endif
    If FlowRLimWarn==0 then
        FlowRLimWarn=FRMax
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects

init enabled := false
Enddec
Declare GMCcom_FState2 as GMCCommandExecV2
Level 249758
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG FState,TarVol,PmpRate"

func ResponseReceived(response as string)
    dim FState as float
    dim tmpTarVol as float
    dim tmppmprate as float
    dim FSstr as string
    dim idx as integer
    dim TVstr as string
    dim PRstr as string
    dim respstr as string
    Dim strTime as String
    Dim tmpStr as string

    idx:=find(response,0,-1," ")
    FSstr=left(response,idx)
    response:=Mid(response,idx+1,-1)
    idx:=find(response,0,-1," ")
    TVstr=left(response,idx)
    PRstr=Mid(response,idx+1,-1)

    check error
        Val(FState,FSstr)
        Val(tmpTarVol,TVstr)
        Val(tmpPmprate,PRstr)
    on error
        _ClearException()
    enderr

    If FState > 0 then
        'We need to initiate Flow Mode screen with stop enabled
        Title_Screen.enabled= false
         flow_mode_screen.enabled = true
        gmcpoll_mlcura.enabled=true
        gmcpoll_mlcurb.enabled=true
        gmcpoll_pcur.enabled =true
        gmcpoll_mltot.enabled=true
        GMCPoll_PcurA.enabled=true
        GMCPoll_PcurB.enabled=true
'        sk_start_flow.value="STOP"
'        skb_Flow_Mode.softKeyList=skl_F_Mode_1
'        sk_Rate_Vol.value="VOLUME"
        LineNo=3
'        Highlight_Line("Pos",LineNo)
        lbl_Flow_Instructions.value="Operator terminal was restarted for an unknown reason."

        GMCPoll_Flowing.enabled=true
        Disabled = false
        FlowStopped=False
        GMCPoll_Flowing.enabled=true
        InitComplete=true
        CycleComplete=true
'        tmr_CheckML.enabled=true

        Target_Volume=tmpTarVol
        mlmax=tmpTarVol
        tmpStr=_FormatFloat(tmpTarVol,6,2,_FLOAT_NORMAL)
        If tmpTarVol > 1000000 then
            eb_tar_vol.value="INF"
        else
            if eb_tar_vol.value<>tmpStr then
                eb_tar_vol.value=tmpStr
            endif
        endif

        tmppmprate=-tmppmprate
        mlpermin=tmppmprate
        tmpStr=_FormatFloat(tmppmprate,6,2,_FLOAT_NORMAL)
        If tmpStr<> eb_FlowR.Value then
            eb_FlowR.value= tmpStr
        endif

        lbl_Current_Flow_Rate.value = _formatfloat(tmppmprate,6,2,_FLOAT_NORMAL)
        Set_Flow_Buttons()


    Else 'we are not in pressure control mode or Flow mode
        GMCcom_CyclDone3.ExecuteCommand=true
    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command, response, failReason)
endfunc

init parent := daq_objects
init enabled := false
Enddec
Declare GMCcom_FState_Remote as GMCCommandExecV2
Level 249738
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG FState"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(fstate,temp)
    on error
            _ClearException()
    enderr
    If fstate>0 and Remote==0 then
        Init_Flow_Mode_Screen()
    endif
    If fstate ==1 and (elps_a.bgcolor<>20 or elps_b.bgcolor<>160 )then
        elps_a.bgcolor=20
        elps_b.bgcolor=160
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=160
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=160
    endif
    If fstate ==2 and (elps_a.bgcolor<>20 or elps_b.bgcolor<>20 )then
        elps_a.bgcolor=20
        elps_b.bgcolor=20
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=20
    endif
    If fstate ==3 and (elps_a.bgcolor<>252 or elps_b.bgcolor<>20 )then
        elps_a.bgcolor=252
        elps_b.bgcolor=20
        elps_a_2.bgcolor=252
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=252
        elps_b_3.bgcolor=20
    endif
    If fstate ==4 and (elps_a.bgcolor<>160 or elps_b.bgcolor<>20 )then
        elps_a.bgcolor=160
        elps_b.bgcolor=20
        elps_a_2.bgcolor=160
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=160
        elps_b_3.bgcolor=20
    endif
    If fstate ==5 and (elps_a.bgcolor<>20 or elps_b.bgcolor<>20 )then
        elps_a.bgcolor=20
        elps_b.bgcolor=20
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=20
    endif
    If fstate ==6 and (elps_a.bgcolor<>20 or elps_b.bgcolor<>252 )then
        elps_a.bgcolor=20
        elps_b.bgcolor=252
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=252
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=252
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_FwdAlrmA as GMCCommandExecV2
Level 249711
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG FwdAlrmA"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(FwdAlrmA,temp)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_FwdAlrmB as GMCCommandExecV2
Level 249709
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG FwdAlrmB"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
            Val(FwdAlrmB,temp)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_IA as GMCCommandExecV2
Level 249763
#Visible True
#Lock False
init commobject := galilcomm
init command := "IA ?,?,?,?"

func ResponseReceived(response as string)
    dim tmp as string
    dim n as integer
    dim IA[6] as float
    dim idx as integer
    dim LengthLeft as Boolean
    init LengthLeft:=True
    n=0
    while LengthLeft do
        idx:=find(response,0,-1,",")
        if idx>0 then
            tmp=left(response,idx)
            response:=Mid(response,idx+1,-1)
            check error
                 val(IA[n],tmp)
            on error
                _ClearException()
            enderr
        else 'we are at the end of the string
            If Len(response)>0 then
                tmp=response
                check error
                 val(IA[n],tmp)
            on error
                _ClearException()
            enderr
            endif
            LengthLeft=False
        endif
    n=n+1
    loop
    eb_IP_1.Value=Str(IA[0])
    eb_IP_2.Value=Str(IA[1])
    eb_IP_3.Value=Str(IA[2])
    eb_IP_4.Value=Str(IA[3])
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_Igain as GMCCommandExecV2
Level 249700
#Visible True
#Lock False
func ResponseReceived(response as string)
    dim temp as string
     dim Igain as float

    temp = Clip_String(response,2)
    check error
            Val(Igain,temp)
    on error
            _ClearException()
    enderr
    lbl_Igain_cur.Value=_FormatFloat(Igain,6,2,_FLOAT_NORMAL)
    eb_new_Igain.Value=_FormatFloat(Igain,6,2,_FLOAT_NORMAL)
endfunc

init parent := daq_objects
init command := "MG Igain"
init commobject := galilcomm
Enddec
Declare GMCcom_InitDone4 as GMCCommandExecV2
Level 249760
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG InitDone"

func ResponseReceived(response as string)
    Dim strTime as String
    Dim InitDone as float
    check error
         val(InitDone,response)

    on error
        _ClearException()
    enderr
    If InitDone > 0 then
        'We need to initiate Title screen with Init complete
        InitComplete=true
        CycleComplete=false
        Init_Title_screen()
'        skb_title.enabled=true
'        skb_title.softKeyList=skl_Title_2

'#fix commented out
'        if not Exiting_Remote then
'            lbl_msg_title.value="Operator Terminal Rebooted Unexpectedly"
'            lbl_msg_title.enabled=true
'        endif
    Else 'we start at title screen init and cycle not complete
        InitComplete=false
        CycleComplete=false
        Init_Title_screen()
'        skb_title.enabled=true
'        skb_title.softKeyList=skl_Title_1

'#fix commented out
'        If not I_sent_Restart then
'            lbl_msg_title.value="Operator Terminal Rebooted Unexpectedly"
'            lbl_msg_title.enabled=true
'        endif
    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
init enabled := false
Enddec
Declare GMCcom_InitRate as GMCCommandExecV2
Level 249766
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG InitRate"

func ResponseReceived(response as string)

    check error
         val(InitRate,response)
    on error
        _ClearException()
    enderr
    eb_InitRate.value=_FormatFloat(InitRate,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_InVopn as GMCCommandExecV2
Level 249765
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG InVopn"


func ResponseReceived(response as string)
Dim temp as float

    check error
         val(temp,response)
    on error
        _ClearException()
    enderr

    If temp== 0 then
        InVopn=false
        rb_InV_Closed.isChecked=true
    else
        rb_InV_Open.isChecked=true
        InVopn=true
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCCom_Isum as GMCCommandExecV2
Level 249698
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Isum"

func ResponseReceived(response as string)
     dim temp as string
     dim Isum as float

    temp = Clip_String(response,2)
    check error
            Val(Isum,temp)
    on error
            _ClearException()
    enderr
    lbl_Isum.Value=_FormatFloat(Isum,6,2,_FLOAT_NORMAL)

endfunc
Enddec
Declare GMCCom_Kprop as GMCCommandExecV2
Level 249703
#Visible True
#Lock False
init parent := daq_objects
init enabled := true
init commobject := galilcomm
init command := "MG Kprop"

func ResponseReceived(response as string)
     dim temp as string
     dim Kprop as float

    temp = Clip_String(response,2)
    check error
            Val(Kprop,temp)
    on error
            _ClearException()
    enderr
    lbl_Kprop_cur.Value=_FormatFloat(Kprop,6,0,_FLOAT_NORMAL)
    eb_new_Kprop.Value=_FormatFloat(Kprop,6,0,_FLOAT_NORMAL)
endfunc
Enddec
Declare GMCcom_Kx as GMCCommandExecV2
Level 249701
#Visible True
#Lock False
func ResponseReceived(response as string)
    dim temp as string
     dim Kx as float

    temp = Clip_String(response,2)
    check error
            Val(Kx,temp)
    on error
            _ClearException()
    enderr
    lbl_kx_cur.Value=_FormatFloat(Kx,6,0,_FLOAT_NORMAL)
    eb_new_kx.Value=_FormatFloat(Kx,6,0,_FLOAT_NORMAL)
endfunc

init parent := daq_objects
init command := "MG Kx"
init commobject := galilcomm
Enddec
Declare GMCCom_LineNum as GMCCommandExecV2
Level 249773
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG LineNum"
init enabled := true

func ResponseReceived(response as string)
  dim LineNo as float
    dim respstr as string

    respstr = Clip_String(response,2)

    check error
             Val(LineNo,respstr)
    on error
            _ClearException()
    enderr
    lbl_LineNum.value=_FormatFloat(LineNo,4,0,_FLOAT_NORMAL)
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCCom_MLaccum as GMCCommandExecV2
Level 249713
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG MLaccum"

func ResponseReceived(response as string)
    check error
            val(MLaccum,response)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_MLPmmA as GMCCommandExecV2
Level 249705
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG MLPmmA"

func ResponseReceived(response as string)
    check error
            val(MLpermmA,response)
    on error
            _ClearException()
    enderr
     lbl_ml_per_mm.value=_formatfloat(MLpermmA,6,4,_FLOAT_NORMAL)

endfunc
Enddec
Declare GMCcom_MLPmmB as GMCCommandExecV2
Level 249704
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG MLPmmB"

func ResponseReceived(response as string)

    check error
            val(MLpermmB,response)
    on error
            _ClearException()
    enderr
'     lbl_ml_per_mm.value=_formatfloat(MLpermmB,6,4,_FLOAT_NORMAL)

endfunc
Enddec
Declare GMCcom_PfsVA as GMCCommandExecV2
Level 249728
#Visible True
#Lock False
func ResponseReceived(response as string)


    check error
             val(Full_Scale_voltsA,response)
    on error
            _ClearException()
    enderr
    lbl_fs_volts.Value=_formatfloat(Full_Scale_voltsA,6,4,_FLOAT_NORMAL)

endfunc

init command := "MG PfsVA"
init commobject := galilcomm
init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_PfsVB as GMCCommandExecV2
Level 249727
#Visible True
#Lock False
func ResponseReceived(response as string)


    check error
             val(Full_Scale_voltsB,response)
    on error
            _ClearException()
    enderr
    lbl_FS_volts.Value=_formatfloat(Full_Scale_voltsB,6,4,_FLOAT_NORMAL)

endfunc

init command := "MG PfsVB"
init commobject := galilcomm
init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Pmax as GMCCommandExecV2
Level 249743
#Visible True
#Lock Me
init commobject := galilcomm
init command := "MG PMax"

func ResponseReceived(response as string)

    check error
             val(Pmax,response)
    on error
            _ClearException()
    enderr
    eb_Pmax.value=_FormatFloat(Pmax,6,2,_FLOAT_NORMAL)




endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_PmpMode as GMCCommandExecV2
Level 249762
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG PmpMode"

func ResponseReceived(response as string)

    check error
         val(PmpMode,response)
    on error
        _ClearException()
    enderr

    If PmpMode== 0 then
        but_Set_Mode.value ="RECEIVE MODE"
        but_Set_Mode_1.value ="RECEIVE MODE"
        rb_Receive_Mode.isChecked=true
    else
        but_Set_Mode.value="PUMP MODE"
        but_Set_Mode_1.value="PUMP MODE"
        rb_PumpMode.isChecked=true
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_PmpStart as GMCCommandExecV2
Level 249715
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG PmpStart"

func ResponseReceived(response as string)

    check error
             val(PmpStart,response)
    on error
            _ClearException()
    enderr
    eb_start_vol_pump.value=_FormatFloat(PmpStart,6,2,_FLOAT_NORMAL)
endfunc

init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCCom_PowerUP as GMCCommandExecV2
Level 249712
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG PowerUp"
init enabled := true

func ResponseReceived(response as string)
    dim temp as float
    dim respstr as string


    respstr = Clip_String(response,2)

    check error
             Val(temp,respstr)
    on error
            _ClearException()
    enderr
    if temp==0 then

        if PowerUpComCheck then
            REM Read 0 but com check is on, turn it off
            tmrpowerup.TimePeriod=10
            PowerUpComCheck=false
        endif

'        tmr_CheckML.enabled=true
        return
    elseif temp==1 then
        if PowerUpComCheck then
            tmrpowerup.enabled=false
            tmr_CheckML.enabled=false
            'probably need to exit the current screen
            close_all()
            Init_Power_Up_Screen()
        else
            REM Read 1, but haven't verified.
            REM Change time period to 1 so we don't wait 10 seconds for another response.
            PowerUpComCheck=true
            tmrPowerUp.TimePeriod=1

            debugText="Value of PowerUp read as "+str(temp)
            Write_To_Debug(debugText, "GMCCOM_PowerUP")
        endif

    Else
        REM Bad data
        debugText="Value of PowerUp read as "+str(temp)
        Write_To_Debug(debugText, "GMCCOM_PowerUP")

    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)


endfunc
Enddec
Declare GMCcom_PRange as GMCCommandExecV2
Level 249719
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG PRange[Pxdcr]"

func ResponseReceived(response as string)
'    _D(str(me)+ " ResponseRecv: "+response)

    check error
             val(PRange,response)
    on error
            _ClearException()
    enderr
    lbl_p_range.value=_FormatFloat(PRange,5,0,_FLOAT_NORMAL)
    lbl_press_range.value=_FormatFloat(PRange,5,0,_FLOAT_NORMAL)
    eb_PMax.max=PRange*1.1
    eb_PMax.min=PRange*.01
    eb_PMax_1.max=PRange*1.1
    eb_PMax_1.min=PRange*.01
    eb_Target_Press.max=PRange
    eb_PMax_Warn.max=PRange*1.1
    eb_PMax_Warn.min=PRange*.01
    If PRange > 15 and PRange < 25 then
        Pxdcr=0
    endif
    If PRange > 40 and PRange < 60 then
        Pxdcr=1
    endif
    If PRange > 100 and PRange < 150 then
        Pxdcr=2
    endif
    If PRange > 190 and PRange < 210 then
        Pxdcr=3
    endif
    If PRange > 490 and PRange < 510 then
        Pxdcr=4
    endif
    If PRange > 900 and PRange < 1100 then
        Pxdcr=5
    endif
    If PRange > 4900 and PRange < 5100 then
        Pxdcr=6
    endif
    If PRange > 9500 and PRange < 10500 then
        Pxdcr=7
    endif

endfunc

init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
'    _D(str(me)+ " FailureReceived")
    Controller_Communication_Error(me.command,response, failReason)
endfunc

func ExecuteCommand(newVal as boolean)
    default (newVal)
endfunc
Enddec
Declare GMCcom_PState1 as GMCCommandExecV2
Level 249757
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG PState,TarPres,RampRate"

func ResponseReceived(response as string)
    Dim strTime as String
    Dim PState as float
    dim PSstr as string
    dim idx as integer
    dim TPstr as string
    dim RRstr as string
    dim respstr as string
    Dim tmpStr as string

    idx:=find(response,0,-1," ")
    PSstr=left(response,idx)
    response:=Mid(response,idx+1,-1)
    idx:=find(response,0,-1," ")
    TPstr=left(response,idx)
    RRstr=Mid(response,idx+1,-1)

    check error
        Val(PState,PSstr)
        Val(Ptarget,TPstr)
        Val(Prate,RRstr)
    on error
        _ClearException()
    enderr

    If PState > 0 then
        'We need to initiate PMode screen with stop enabled
        Title_Screen.enabled= false
        P_Cont_On=true
        InitComplete=true
        CycleComplete=true
        'Set G-72 buttons
'       sk_Pcontrol.value = "STOP"
'        sk_cycle.value = "CYCLE"
'        sk_ramp.value="RAMP"
        pressure_mode_screen.enabled = true
        gmcpoll_mlcura.enabled=true
        gmcpoll_mlcurb.enabled=true
        gmcpoll_pcur.enabled =true
        gmcpoll_mltot.enabled=true
        GMCPoll_PcurA.enabled=true
        GMCPoll_PcurB.enabled=true
        GMCPoll_PState_Status.enabled=true
        GMCPoll_CurFlow.enabled=true
        eb_FlowRLim.Value=_formatfloat(FlowRLim,6,2,_FLOAT_NORMAL)
'        lbl_Target_Press.fgColor=160
'        lbl_Target_Press.value=_FormatFloat(Pcur,6,2,_FLOAT_NORMAL)
'        skb_const_p_mode.softKeyList=skl_P_Mode_4
'This message needs to be displayed somewhere
'        lbl_Pmode_msg.value="Operator terminal rebooted unexpectedly"
'        tmr_CheckML.enabled=true

        eb_Target_Press.value=_FormatFloat(Ptarget,6,2,_FLOAT_NORMAL)

        Pratemin=Prate*60

        If psi_per_sec then
            but_psi_per_sec_min.Value="psi/sec"
            eb_PressR.max=200
            eb_PressR.value=_FormatFloat(Prate,6,2,_FLOAT_NORMAL)
        else
            but_psi_per_sec_min.Value="psi/min"
            eb_PressR.max=12000
            eb_PressR.value=_FormatFloat(Pratemin,6,2,_FLOAT_NORMAL)
        endif

        Set_Press_Buttons()


    Else 'we are not in pressure control mode
        GMCcom_FState2.executeCommand=true
    endif

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
init enabled := false
Enddec
Declare GMCcom_PState_Remote as GMCCommandExecV2
Level 249737
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG PState"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)

    check error
             Val(PState,temp)
    on error
            _ClearException()
    enderr
    If PState > 0 and Remote==0 then
        If Pressure_mode_screen.enabled==false then
            Init_Const_P_Screen()
        endif
    endif
    If PState==PStatelast then
        return
    endif

    PStatelast=PState

    If PState ==1 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>160) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=160
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=160
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=160
    endif
    If PState ==2 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=20
    endif
    If PState ==3 and (elps_a_1.bgcolor<>252 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=252
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=252
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=252
        elps_b_3.bgcolor=20
    endif
    If PState ==4 and (elps_a_1.bgcolor<>160 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=160
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=160
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=160
        elps_b_3.bgcolor=20
    endif
    If PState ==5 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=20
    endif
    If PState ==6 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>252) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=252
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=252
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=252
    endif
endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_RcvStart as GMCCommandExecV2
Level 249714
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG RcvStart"

func ResponseReceived(response as string)

    check error
             val(RcvStart,response)
    on error
            _ClearException()
    enderr
    eb_start_receive.value=_FormatFloat(RcvStart,6,2,_FLOAT_NORMAL)
endfunc

init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_ReflRate as GMCCommandExecV2
Level 249761
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG ReflFmn"

func ResponseReceived(response as string)

    check error
         val(ReflRate,response)
    on error
        _ClearException()
    enderr
    eb_ReflRate.value=_FormatFloat(ReflRate,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_ReflRate_ManA as GMCCommandExecV2
Level 249767
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG RefillRA"

func ResponseReceived(response as string)

    check error
         val(RefillRA,response)
    on error
        _ClearException()
    enderr
    eb_RefillR_A.value=_FormatFloat(RefillRA,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_ReflRate_ManB as GMCCommandExecV2
Level 249768
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG RefillRB"

func ResponseReceived(response as string)

    check error
         val(RefillRB,response)
    on error
        _ClearException()
    enderr
    eb_RefillR_B.value=_FormatFloat(RefillRB,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCCom_Rev as GMCCommandExecV2
Level 249772
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG Rev"
init enabled := true

func ResponseReceived(response as string)
    dim Revision as float
    dim respstr as string

 '   respstr = Clip_String(response,2)

    check error
             Val(Revision,response)
    on error
            _ClearException()
    enderr
    lbl_Rev.value=_FormatFloat(Revision,6,4,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_RevAlrmA as GMCCommandExecV2
Level 249710
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG RevAlrmA"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)

    check error
             Val(RevAlrmA,temp)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_RevAlrmB as GMCCommandExecV2
Level 249708
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init command := "MG RevAlrmB"

func ResponseReceived(response as string)
    dim temp as string

    temp = Clip_String(response,2)

    check error
             Val(RevAlrmB,temp)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Rod as GMCCommandExecV2
Level 249720
#Visible True
#Lock False
init commobject := galilcomm
init enabled := true
init command := "MG RodDia[RodSize]"

func ResponseReceived(response as string)

    check error
             val(RodDia,response)
    on error
            _ClearException()
    enderr
    lbl_Rod_Dia.value=_FormatFloat(RodDia,6,2,_FLOAT_NORMAL)
'    lbl_rod_dia_a.value=_FormatFloat(RodDia,6,2,_FLOAT_NORMAL)
    lbl_rod_dia_b.value=_FormatFloat(RodDia,6,2,_FLOAT_NORMAL)
    If RodDia > 5 and RodDia < 7 then
'        ddl_Rod_Dia.selected=0
        RodSize=0
    endif
    If RodDia > 7 and RodDia < 10 then
'        ddl_Rod_Dia.selected=1
        RodSize=1
    endif
    If RodDia > 10 and RodDia < 12 then
'        ddl_Rod_Dia.selected=2
        RodSize=2
    endif
    If RodDia > 12 and RodDia < 13 then
'        ddl_Rod_Dia.selected=3
        RodSize=3
    endif

endfunc

init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_Stroke as GMCCommandExecV2
Level 249718
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG StkeA"

func ResponseReceived(response as string)

    check error
             val(StrokeA,response)
    on error
            _ClearException()
    enderr

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCCom_Update_Current_Values as GMCCommandExecV2
Level 249775
#Visible True
#Lock False
init parent := daq_objects
init commobject := galilcomm
init command := "MG AveSp,PcurA,PcurB,Pcur"

func ResponseReceived(response as string)
    dim temp_AveSp, temp_PcurA, temp_PcurB, temp_Pcur as float
    dim respstr as string
    dim Error_Log_Text as string
    dim avesp_len, pcura_len, pcurb_len, pcur_len as integer


    avesp_len=find(response, 0, -1, " ")
    pcura_len=find(response,avesp_len, -1, " ")
    pcurb_len=find(response,pcura_len, -1, " ")
    pcur_len=len(response)-(avesp_len+pcura_len+pcurb_len+3)


    check error
    val(temp_avesp, left(response,avesp_len-1))
    val(temp_pcura, mid(response,avesp_len+1,pcura_len))
    val(temp_pcurb, mid(response,pcura_len+avesp_len+2,pcurb_len))
    val(temp_pcur,right(response,(pcur_len)))
    on error
        _clearexception()
    enderr


    REM Get timestamp and write current values to the error log.
    REM Note not all errors will cause a warning display to be shown, but we want a record of them

    Error_Log_Text="\nCurrent Values - PcurA: " +str(temp_PcurA) +", PcurB: " +str(temp_PcurB) +", Pcur: " +str(temp_Pcur) +", AveSp: " + str(temp_avesp)+", Pressure warning limit: " +eb_Pmax_Warn.Value +", Pressure Shutdown limit " + eb_PMax_1.value +", Flow Warning " + eb_flowRlim_Warn.value +", Flow Shutdown " + eb_FlowRlim_1.Value
    error_log_eb.Append(Error_log_text, true)




endfunc
Enddec
Declare GMCcom_VolpCyl as GMCCommandExecV2
Level 249729
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG VolpCyl"

func ResponseReceived(response as string)

    check error
             val(VolpCyl,response)
    on error
            _ClearException()
    enderr
    eb_VolPCyl.value=_FormatFloat(VolpCyl,6,2,_FLOAT_NORMAL)

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_VolumeA as GMCCommandExecV2
Level 249717
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG VolA"

func ResponseReceived(response as string)

    check error
             val(VolumeA,response)
    on error
            _ClearException()
    enderr
    lbl_tot_vol_a.value=_FormatFloat(VolumeA,6,2,_FLOAT_NORMAL)
    'fix these when we have added new gauges
    gauge_volumea.max=VolumeA
    gauge_volumea_1.max=VolumeA
    gauge_volumea_2.max=VolumeA
    gauge_volumea_3.max=VolumeA
    gauge_volumea_4.max=VolumeA
    gauge_volumea_5.max=VolumeA

    AbsVolMax = VolumeA-.5

    eb_start_vol_pump.max=0.95*VolumeA
    eb_start_receive.max=0.95*VolumeA
    eb_Amin.max=VolumeA-.05
    eb_Amax.max=VolumeA-.05

    eb_volpcyl.max=VolumeA-.05
    eb_Cal_Start.max=0.95*VolumeA



endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_VolumeB as GMCCommandExecV2
Level 249716
#Visible True
#Lock False
init commobject := galilcomm
init command := "MG VolB"

func ResponseReceived(response as string)

    check error
             val(VolumeB,response)
    on error
            _ClearException()
    enderr
    lbl_tot_vol_b.value=_FormatFloat(VolumeB,6,2,_FLOAT_NORMAL)
    'fix these when we have added new gauges
    gauge_volumeb.max=VolumeB
    gauge_volumeb_1.max=VolumeB
    gauge_volumeb_2.max=VolumeB
    gauge_volumeb_3.max=VolumeB
    gauge_volumeb_4.max=VolumeB
    gauge_volumeb_5.max=VolumeB
    eb_Bmin.max=VolumeB-.05
    eb_Bmax.max=VolumeB-.05

endfunc

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc

init parent := daq_objects
Enddec
Declare GMCcom_VppsiA as GMCCommandExecV2
Level 249707
#Visible True
#Lock False
func ResponseReceived(response as string)


    check error
             val(VoltsperPSIA,response)
    on error
            _ClearException()
    enderr
    lbl_volts_per_psi.value=_formatfloat(VoltsperPSIA,6,4,_FLOAT_NORMAL)


endfunc

init command := "MG VppsiA[Pxdcr]"
init commobject := galilcomm
init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCcom_VppsiB as GMCCommandExecV2
Level 249706
#Visible True
#Lock False
func ResponseReceived(response as string)


    check error
             val(VoltsperPSIB,response)
    on error
            _ClearException()
    enderr
    lbl_Volts_per_psi.value=_formatfloat(VoltsperPSIB,6,4,_FLOAT_NORMAL)


endfunc

init command := "MG VppsiB[Pxdcr]"
init commobject := galilcomm
init parent := daq_objects

func FailureReceived(response as string, failReason as GMC_FailureReason)
    Controller_Communication_Error(me.command,response, failReason)
endfunc
Enddec
Declare GMCCommand as GMCCommandExecV2
Level 249721
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
Enddec
Declare GMCPoll_CurFlow as GMCPollV2
Level 249746
#Visible True
#Lock False
init command := "MG AveSp"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)

    dim temp as string


    temp = Clip_String(response,2)
    check error
        Val(CurRate,temp)
    on error
        _ClearException()
'        debugEB.appendText="AveSp response "+response
    enderr

    If CurRate > FRMax or -CurRate > FRMax then
        REM Flowing faster than we should be, log it
        debugText="Value of AveSp read as "+str(CurRate)
        Write_To_Debug(debugText, "GMCPoll_CurFlow")
    endif

    If eb_flowr.DecimalPlaces==2 then
        lbl_Current_Flow_Rate.value=_FormatFloat(CurRate,6,2,_FLOAT_NORMAL)
    else
        lbl_Current_Flow_Rate.value=_FormatFloat(CurRate,6,3,_FLOAT_NORMAL)
    endif
    lbl_Current_Flow_Rate_1.value=_FormatFloat(CurRate,6,2,_FLOAT_NORMAL)
    lbl_Current_Flow_Rate_2.value=_FormatFloat(CurRate,6,2,_FLOAT_NORMAL)
    If Remote_Control and PState>0 then
        lbl_Current_Flow_Rate_3.value=_FormatFloat(CurRate,6,2,_FLOAT_NORMAL)
    endif


    If Profile_Screen.enabled then
        If SegTypeArray[Current_Segment]==1 or SegTypeArray[Current_Segment]==2 then
             'in flow segment in profile, don't check for speed errors
             return
        endif
    endif

    If not flow_limit_disabled then
        If CurRate>FlowRLimWarn or -CurRate>FlowRLimWarn then
            If WarnSpeedComCheck then
                REM Make sure to read twice before hitting error
                REM We have exceeded the flowrate warning limit and need to warn the operator

                If not AlreadyWarned then
                    Handle_Error(7)
                endif

                AlreadyWarned=true
            else

                debugText="Value of AveSp read as "+str(CurRate)
                Write_To_Debug(debugText, "GMCPoll_CurFlow")

                WarnSpeedComCheck=true
            endif

        elseif WarnSpeedComCheck then
            REM Not Overspeed, but comcheck is on, turn it off
            WarnSpeedComCheck=false

        endif


        If CurRate>FlowRLim or -CurRate>FlowRLim then
            IF OverSpeedComCheck then
                REM Make sure to check twice before stopping pump
                'We have exceeded the flowrate max limit and need to stop the pump

                If not AlreadyWarnedMaxFlow then
                    'Stop flow

                    If flow_mode_screen.enabled then
                        Stop_Flow()
                        Exit_Flow_Mode_screen()
                    endif

                    If Pressure_mode_screen.enabled then
                        hold_press_ramp()
                        'Stop P Mode
                        Stop_P_Mode()
                        P_Cont_On=false
                        Exit_Press_Mode_screen()
                    endif

                    If Profile_screen.enabled then
                        but_profile.value="START PROFILE"
                        lbl_Profile_Msg.value="Stopping Profile"
                        tmr_Segment.enabled=false
                        tmr_Profile_Times.enabled=false
                        NumberofSegments=Current_Segment
                        Exit_Segment(Current_Segment)
                    endif

                    Handle_Error(10)
                endif

            AlreadyWarnedMaxFlow=true

            else
                REM Overspeed, but haven't checked twice
                debugText=CurrentDate+"Value of AveSp read as "+str(CurRate)
                Write_To_Debug(debugText, "GMCPoll_CurFlow")


                OverSpeedComCheck=true
            endif

        elseif OverSpeedComCheck then
            REM Not overspeed but com check is on, turn it off
            OverSpeedComCheck=false
        endif
    endif

endfunc
init updateperiod := 400

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Cycle as GMCPollV2
Level 249695
#Visible True
#Lock False
init parent := daq_objects
init command := "MG Cycle"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim cycle as float

    respstr = Clip_String(response,2)

    check error
             Val(cycle,respstr)
    on error
            _ClearException()
    enderr
    If cycle == 0 then
        GMCPoll_Cycle.enabled=false
        Cycle_Popup_Screen.enabled=false
        If Estop then
            cyclecomplete=false
        else
            cyclecomplete=true
        endif
        Set_Press_Buttons()
        Set_Flow_Buttons()

        If Estop then
            Estop = false
            lbl_pressure_msg.value="Cycle Canceled"
            lbl_Flow_Instructions.value="Cycle Canceled"
        else
            if Pressure_mode_screen.enabled==true then
                lbl_pressure_msg.value="Cycle Completed"
                lbl_RampStatus.Value="Cycle Completed"
                If PcurA>5 or PcurB>5 then
                    lbl_pressure_Msg.value="Cycle Completed - Pressure transducers may need to be zeroed."
                endif
            elseif Flow_mode_screen.enabled==true then
                lbl_Flow_Instructions.value="Cycle Completed"
                If PcurA>5 or PcurB>5 then
                    lbl_Flow_Instructions.value="Cycle Completed - Pressure transducers may need to be zeroed."
                endif
            elseif Profile_screen.enabled then
                lbl_Profile_Msg.value="Cycle Completed"
                If PcurA>5 or PcurB>5 then
                    lbl_Profile_Msg.value="Cycle Completed - Pressure transducers may need to be zeroed."
                endif
                if Profile_Definition_Complete then
                    but_Profile.Value="START PROFILE"
                    but_Profile.enabled=true
                endif
            endif
        endif
    endif
endfunc


init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Cycle_RS as GMCPollV2
Level 249770
#Visible True
#Lock False
init parent := daq_objects
init command := "MG Cycle"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim cycle as float

    respstr = Clip_String(response,2)

    check error
             Val(cycle,respstr)
    on error
            _ClearException()
    enderr
    If cycle == 0 then
        GMCPoll_Cycle_RS.enabled=false
        Cycle_Popup_Screen.enabled=false
        cyclecomplete=true
        Set_Press_Buttons()
        Set_Flow_Buttons()
        Init_Title_screen()

    endif
endfunc


init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_DAQ as GMCPollV2
Level 249722
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init enabled := false
init updateperiod := 5000
init command := "MG _XQ0"

func ResponseReceived (response as reference to string)
    dim temp as string
    dim status as float


    temp = Clip_String(response,2)
    check error
        Val(status,temp)
    on error
        _ClearException()
'        debugEB.appendText="_XQ0 response "+response
    enderr
    If status==-1 then
        REM If this is -1 our daq loop has stopped and we need to restart.
        if DAQLoopComCheck then
            REM make sure we are getting legitimate value

    '        DAQ_Warning_screen.enabled=true
            tmr_CheckML.enabled=false
    '        Restart_DAQ()
            gmcpoll_DAQ.enabled=false
            gmcpoll_mltot.enabled=false
            gmcpoll_mlcura.enabled=false
            gmcpoll_mlcurb.enabled=false
            gmcpoll_pcur.enabled=false
            'shut down any active screens
            If Flow_mode_screen.enabled then
                Exit_Flow_Mode_screen()
            endif
            If Pressure_mode_screen.enabled then
                Exit_Press_Mode_screen()
            endif
            Handle_Error(14)
        else
            REM Read a negative value, but haven't checked
            DAQLoopComCheck=true
        endif
    else
        REM Reset our com check if not a negative value.
        DAQLoopComCheck=false
    endif
endfunc

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Finding as GMCPollV2
Level 249697
#Visible False
#Lock False
func ResponseReceived (response as reference to string)
    dim respstr as string
    dim finding as float

    respstr = Clip_String(response,2)

    check error
             Val(finding,respstr)
    on error
            _ClearException()
    enderr
    if Shift then
        finding = 0
    endif
    If finding == 0 then
        GMCPoll_Finding.enabled=false
        but_Setup.enabled=true
        but_FlowMode.enabled=true
        but_PressureMode.enabled=true
        cyclecomplete=false
        InitComplete=True
        Cancel_PowerUp()

        'pause 5 secs to allow burn to complete then get current config
        tmr_Initialize.enabled=true
    endif
endfunc

init command := "MG Finding "
init commobject := galilcomm
init enabled := false
init parent := daq_objects

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Finding_RS as GMCPollV2
Level 249769
#Visible True
#Lock False
func ResponseReceived (response as reference to string)
    dim respstr as string
    dim finding as float

    respstr = Clip_String(response,2)

    check error
             Val(finding,respstr)
    on error
            _ClearException()
    enderr
    if Shift then
        finding = 0
    endif
    If finding == 0 then
        GMCPoll_Finding_RS.enabled=false
        cyclecomplete=false
        InitComplete=True
        Init_Popup_Screen.enabled = false
        Cycle_Popup_Screen.enabled=true
        GMCPoll_Cycle_RS.enabled=true
'Need to intialize the cycle popup screen and appropriate polling object
    endif
endfunc

init command := "MG Finding "
init commobject := galilcomm
init enabled := false
init parent := daq_objects

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Flow_Rate as GMCPollV2
Level 249741
#Visible True
#Lock False
init command := "MG PmpRate"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)
    dim temp as string
    dim PumpRate as float
    dim tmpStr as String

    temp = Clip_String(response,2)
    check error
        Val(PumpRate,temp)
    on error
        _ClearException()
'        debugEB.appendText="PmpRate response "+response
    enderr
    PumpRate=-PumpRate
    tmpStr=_FormatFloat(PumpRate,6,2,_FLOAT_NORMAL)
    If tmpStr<> eb_FlowR.Value then
        eb_FlowR.value= tmpStr
    endif
    if Remote_Control and Fstate>0 then
        lbl_Current_Flow_Rate_3.value=tmpStr
    elseif Remote_Control and Pstate==0 then
        lbl_Current_Flow_Rate_3.value="0.00"
    endif

endfunc

init updateperiod := 5000

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Flowing as GMCPollV2
Level 249696
#Visible True
#Lock False
init commobject := galilcomm
init parent := daq_objects
init enabled := false
init command := "MG FState"

func ResponseReceived (response as reference to string)
    dim respstr as string


    respstr = Clip_String(response,2)
    check error
        Val(fstate,respstr)
    on error
        _ClearException()
'        debugEB.appendText="FState response "+response
    enderr

    IF fstate>6 then
        REM Known bad value
        debugtext="Value of FState read as "+str(fstate)
        Write_To_Debug(debugtext, "GMCPoll_Flowing")
    endif

    If FlowStopped and not Remote_Control then
        If fstate==0 then
            GMCPoll_Flowing.enabled=false
            Refilling=false
            Set_Flow_Buttons()
            'disable alarms
            Disabled = True

        else
'            return
        endif
    endif
    If fstate==fstatelast then
        return
    endif
    If fstate == 0 then
        If (elps_a.bgcolor<>160 or elps_b.bgcolor<>160) then
            elps_a.bgcolor=160
            elps_b.bgcolor=160
            elps_a_2.bgcolor=160
            elps_b_2.bgcolor=160
            elps_a_3.bgcolor=160
            elps_b_3.bgcolor=160
        endif
        If not Remote_Control then
            GMCPoll_Flowing.enabled=false
            But_StartFlow.enabled=true
            Set_Flow_Buttons()
        endif
    endif
    If fstate == 1 then
        If (elps_a.bgcolor<>20 or elps_b.bgcolor<>160) then
            elps_a.bgcolor=20
            elps_b.bgcolor=160
            elps_a_2.bgcolor=20
            elps_b_2.bgcolor=160
            elps_a_3.bgcolor=20
            elps_b_3.bgcolor=160
        endif

        if Tar_Vol_Reached then
            elps_a.bgcolor=160
        endif
    endif
    If fstate == 2 then
        if (elps_a.bgcolor<>20 or elps_b.bgcolor<>20) then
            elps_a.bgcolor=20
            elps_b.bgcolor=20
            elps_a_2.bgcolor=20
            elps_b_2.bgcolor=20
            elps_a_3.bgcolor=20
            elps_b_3.bgcolor=20
        endif
    endif
    If fstate == 3 then
        if (elps_a.bgcolor<>252 or elps_b.bgcolor<>20) then
            elps_a.bgcolor=252
            elps_b.bgcolor=20
            elps_a_2.bgcolor=252
            elps_b_2.bgcolor=20
            elps_a_3.bgcolor=252
            elps_b_3.bgcolor=20
        endif
   endif
    If fstate == 4 then
        if (elps_a.bgcolor<>160 or elps_b.bgcolor<>20) then
            elps_a.bgcolor=160
            elps_b.bgcolor=20
            elps_a_2.bgcolor=160
            elps_b_2.bgcolor=20
            elps_a_3.bgcolor=160
            elps_b_3.bgcolor=20
        endif

        if Tar_Vol_Reached then
            elps_b.bgcolor=160
        endif
    endif
    If fstate == 5 then
        if (elps_a.bgcolor<>20 or elps_b.bgcolor<>20) then
            elps_a.bgcolor=20
            elps_b.bgcolor=20
            elps_a_2.bgcolor=20
            elps_b_2.bgcolor=20
            elps_a_3.bgcolor=20
            elps_b_3.bgcolor=20
        endif
    endif
    If fstate == 6 then
        if (elps_a.bgcolor<>20 or elps_b.bgcolor<>252) then
            elps_a.bgcolor=20
            elps_b.bgcolor=252
            elps_a_2.bgcolor=20
            elps_b_2.bgcolor=252
            elps_a_3.bgcolor=20
            elps_b_3.bgcolor=252
        endif
    endif
    if fstate==3 or fstate==6 then
        Refilling=true
    else
        Refilling=false
    endif
    fstatelast=fstate
    If fstate>0 then
        lbl_Current_Mode.value="FLOW"
    elseif PState== 0 then
        lbl_Current_Mode.value="IDLE"
    endif
endfunc

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_FlowingA as GMCPollV2
Level 249752
#Visible True
#Lock False
init parent := daq_objects
init command := "MG FlowingA"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string


    respstr = Clip_String(response,2)

    check error
             Val(FlowingA,respstr)
    on error
            _ClearException()
    enderr
    If FlowingA == 0 then
        but_Start_Flow_Man_A.Value="START FLOW - A"
        lbl_Manual_Control_Msg.value="Cylinder A flow volume completed"
        GMCPoll_FlowingA.enabled=false
        ReadytoFlowA=False
        Set_Manual_Flow_Buttons()
    endif
endfunc



init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_FlowingB as GMCPollV2
Level 249753
#Visible True
#Lock False
init parent := daq_objects
init command := "MG FlowingB"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string

    respstr = Clip_String(response,2)

    check error
             Val(FlowingB,respstr)
    on error
            _ClearException()
    enderr
    If FlowingB == 0 then
        but_Start_Flow_Man_B.Value="START FLOW - B"
        lbl_Manual_Control_Msg.value="Cylinder B flow volume completed"
        GMCPoll_FlowingB.enabled=false
        ReadytoFlowB=False
        Set_Manual_Flow_Buttons()
    endif
endfunc


init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_FState_Cal as GMCPollV2
Level 249730
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_2"
init parent := daq_objects
init xpos := 550
init ypos := 51
init width := 19
init height := 22
init command := "MG FState"

func ResponseReceived (response as reference to string)
    dim temp as string
    dim FStmp as float

    temp = Clip_String(response,2)

    check error
             Val(FStmp,temp)
    on error
            _ClearException()
    enderr

    If FStmp<1 then
        'RCYCA and RCYCB has completed
        GMCPoll_FState_Cal.enabled=false
        but_Start_Flow_Cal.Value="START FLOW"
        but_Start_Flow_Cal.enabled=false
        eb_ml_measured.enabled=true
        but_fill_to_start.enabled=true
        CalFlowing=False
    endif

endfunc
init enabled := false
init updateperiod := 500

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_MLcurA as GMCPollV2
Level 249725
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_2"
init parent := daq_objects
init xpos := 550
init ypos := 51
init width := 19
init height := 22
init command := "MG MLcurA"

func ResponseReceived (response as reference to string)
    dim temp as string


    temp = Clip_String(response,2)
    check error
        Val(MLcurA,temp)
    on error
        _ClearException()
    enderr

    lbl_ml_cur_cal.value=_FormatFloat(MLcurA,6,2,_FLOAT_NORMAL)
    lbl_Vol_Cur_A.value=_FormatFloat(MLcurA,6,2,_FLOAT_NORMAL)
    lbl_Vol_Cur_A_1.value=_FormatFloat(MLcurA,6,2,_FLOAT_NORMAL)
    gauge_volumea.Value=MLcurA
    gauge_volumea_1.Value=MLcurA
    gauge_volumea_2.Value=MLcurA
    gauge_volumea_3.Value=MLcurA
    gauge_volumea_4.Value=MLcurA
    gauge_volumea_5.Value=MLcurA

    If Manual_Control_Screen.enabled and FlowingA==0 then
        eb_tar_vol_a.max=MLcurA-Amin
    endif
    if vol_cal_screen.enabled then
        Vol_Flowed= MLstartCal - MLcurA
        If CalFlowing then
            lbl_ml_flowed.value=_formatfloat(Vol_Flowed,6,2,_FLOAT_NORMAL)
        endif
    endif

endfunc
init enabled := false
init updateperiod := 200

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_MLcurB as GMCPollV2
Level 249724
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_2"
init parent := daq_objects
init xpos := 550
init ypos := 51
init width := 19
init height := 22
init command := "MG MLcurB"

func ResponseReceived (response as reference to string)
    dim temp as string


    temp = Clip_String(response,2)
    check error
        Val(MLcurB,temp)
    on error
        _ClearException()
    enderr

     lbl_ml_cur_cal.value=_FormatFloat(MLcurB,6,2,_FLOAT_NORMAL)
     lbl_Vol_Cur_B.value=_FormatFloat(MLcurB,6,2,_FLOAT_NORMAL)
     lbl_Vol_Cur_B_1.value=_FormatFloat(MLcurB,6,2,_FLOAT_NORMAL)
     gauge_volumeb.Value=MLcurB
     gauge_volumeb_1.Value=MLcurB
     gauge_volumeb_2.Value=MLcurB
     gauge_volumeb_3.Value=MLcurB
     gauge_volumeb_4.Value=MLcurB
     gauge_volumeb_5.Value=MLcurB

     If Manual_Control_Screen.enabled and FlowingB==0 then
        eb_tar_vol_b.max=MLcurB-Bmin
    endif
    if vol_cal_screen.enabled then
        Vol_Flowed= MLstartCal - MLcurB
        If CalFlowing then
            lbl_ml_flowed.value=_formatfloat(Vol_Flowed,6,2,_FLOAT_NORMAL)
        endif
    endif
endfunc
init enabled := false
init updateperiod := 200

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_MLtot as GMCPollV2
Level 249726
#Visible True
#Lock False
init command := "MG MLtot"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
        Val(MLtot,temp)
    on error
        _ClearException()
'        debugEB.appendText="MLtot response "+response
    enderr
    If MLtot>0 and GMCPoll_Flowing.enabled then
        If MLtot >= Target_Volume then
            If MLtotComCheck then
            REM Check twice before stopping
                Tar_Vol_Reached = true
                FlowStopped=True
                Set_Flow_Buttons()
            else
                MLtotComCheck=true
            endif
        else
            MLtotComCheck=false

        endif
    endif
        If Pressure_mode_screen.enabled then
        lbl_Vol_tot.value=_FormatFloat(MLtot,6,3,_FLOAT_NORMAL)
    endif
    If Flow_mode_screen.enabled then
        lbl_Current_Pos.value=_FormatFloat(MLtot,6,2,_FLOAT_NORMAL)
    endif

    If Remote_Display.enabled then
        lbl_Current_Pos_1.value=_FormatFloat(MLtot,6,2,_FLOAT_NORMAL)
    endif


    lbl_Vol_Tot.value=_FormatFloat(MLtot,6,2,_FLOAT_NORMAL)
    lbl_Vol_Tot_1.value=_FormatFloat(MLtot,6,2,_FLOAT_NORMAL)
endfunc
init updateperiod := 400

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_NewErr as GMCPollV2
Level 249754
#Visible True
#Lock False
init command := "MG NewErr"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)
    dim temp as string

    temp = Clip_String(response,2)
    check error
        Val(NewErr,temp)
    on error
        _ClearException()
'        debugEB.appendText="AveSp response "+response
    enderr

    if NewErr == 0 then

        If NewErrComCheck then
            REM Com check is on, but received 0, turn off
            NewErrComCheck=false
        endif

    endif

    if NewErr == 1 then

        IF NewErrComCheck then
            REM Make sure we are getting valid response
            'Send NewErr = 0
            GMCCommand.command = "NewErr=0"
            GMCCommand.executeCommand = true
            'Get ErrMsg
            GMCcom_ErrMsg.executeCommand=true
        else
            REM Read 1, but haven't verified
            NewErrComCheck=true
        endif

    elseif NewErr > 1 then
        REM Bad data
        debugText="Value of NewErr read as "+str(NewErr)
        Write_To_Debug(debugText, "GMCPoll_NewErr")
        NewErrComCheck=false


    endif


endfunc
init updateperiod := 800

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Pcur as GMCPollV2
Level 249723
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_1"
init parent := daq_objects
init xpos := 548
init ypos := 57
init width := 16
init height := 17
init command := "MG Pcur"

func ResponseReceived (response as reference to string)
    dim Temp as String
    dim tmpStr as string

    Temp = Clip_String(response,2)
    check error
        Val(Pcur,Temp)
    on error
        _ClearException()
'        debugEB.appendText="Pcur response "+response
    enderr
    tmpStr=_FormatFloat(Pcur,6,0,_FLOAT_NORMAL)
    If Pressure_Mode_screen.enabled then
        if lbl_P_Act.value<>tmpStr then
            lbl_P_Act.value=tmpStr
        endif
    endif
   If Flow_Mode_screen.enabled then
        if lbl_P_Act_2.value<>tmpStr then
            lbl_P_Act_2.value=tmpStr
        endif
    endif
    If Profile_screen.enabled then
        if lbl_P_Act_1.value<>tmpStr then
            lbl_P_Act_1.value=tmpStr
        endif
    endif
    If Remote_Display.enabled then
        if lbl_P_Act_3.value<>tmpStr then
            lbl_P_Act_3.value=tmpStr
        endif
    endif
    If Pcur > PRange or Pcur < -PRange then
        lbl_P_Act.BlinkPeriod=2000
        lbl_P_Act.fgColor=225

        warning_sound()
        lbl_Flow_Instructions.value = str(PRange)
        lbl_Pressure_Warning.enabled=true
    else
        lbl_P_Act.BlinkPeriod=0
        lbl_P_Act.fgColor=255

        lbl_Pressure_Warning.enabled=false
    endif

endfunc
init enabled := false
init updateperiod := 400

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_PcurA as GMCPollV2
Level 249748
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_1"
init parent := daq_objects
init xpos := 343
init ypos := 36
init width := 10
init height := 11
init command := "MG PcurA"

func ResponseReceived (response as reference to string)
    dim Temp as String
    dim tmpStr as string

    Temp = Clip_String(response,2)

    check error
             Val(PcurA,Temp)
    on error
            _ClearException()
    enderr
    tmpStr=_FormatFloat(PcurA,6,0,_FLOAT_NORMAL)
    If Pressure_Mode_screen.enabled then
        if lbl_P_Act_A.value<>tmpStr then
            lbl_P_Act_A.value=tmpStr
        endif
    endif
    If Flow_Mode_screen.enabled then
        if lbl_P_Act_A_1.value<>tmpStr then
            lbl_P_Act_A_1.value=tmpStr
        endif
    endif
    If Profile_screen.enabled then
        if lbl_P_Act_A_2.value<>tmpStr then
            lbl_P_Act_A_2.value=tmpStr
        endif
    endif
    If Power_Up_screen.enabled then
        if lbl_P_Cur_A.value<>tmpStr then
            lbl_P_Cur_A.value=tmpStr
        endif
    endif
    If Manual_Control_screen.enabled then
        if lbl_P_Cur_A_1.value<>tmpStr then
            lbl_P_Cur_A_1.value=tmpStr
        endif
    endif
    If Remote_Display.enabled then
        if lbl_P_Act_A_3.value<>tmpStr then
            lbl_P_Act_A_3.value=tmpStr
        endif
    endif
    If PcurA > PMaxWarn then
        If Pumping and not FlowStopped then  'only apply this error in flowmode
            If not AlreadyWarned then
                If PcurAComCheck then
                REM Check value twice before warning.
                    Handle_Error(5)
                    AlreadyWarned=true
                else
                    PcurAComCheck=true
                endif

            endif

        endif
    else
        PcurAComCheck=false
    Endif


    lbl_psi_indicated.value=tmpStr


endfunc
init enabled := false
init updateperiod := 1000
Enddec
Declare GMCPoll_PcurB as GMCPollV2
Level 249747
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_1"
init parent := daq_objects
init xpos := 343
init ypos := 36
init width := 10
init height := 11
init command := "MG PcurB"

func ResponseReceived (response as reference to string)
    dim Temp as String
    dim tmpStr as string

    Temp = Clip_String(response,2)

    check error
             Val(PcurB,Temp)
    on error
            _ClearException()
    enderr
    tmpStr=_FormatFloat(PcurB,6,0,_FLOAT_NORMAL)
    If Pressure_Mode_screen.enabled then
        if lbl_P_Act_B.value<>tmpStr then
            lbl_P_Act_B.value=tmpStr
        endif
    endif
    If Flow_Mode_screen.enabled then
        if lbl_P_Act_B_1.value<>tmpStr then
            lbl_P_Act_B_1.value=tmpStr
        endif
    endif
    If Profile_screen.enabled then
        if lbl_P_Act_B_2.value<>tmpStr then
            lbl_P_Act_B_2.value=tmpStr
        endif
    endif
    If Power_Up_screen.enabled then
        if lbl_P_Cur_B.value<>tmpStr then
            lbl_P_Cur_B.value=tmpStr
        endif
    endif
    If Manual_Control_screen.enabled then
        if lbl_P_Cur_B_1.value<>tmpStr then
            lbl_P_Cur_B_1.value=tmpStr
        endif
    endif
    If Remote_Display.enabled then
        if lbl_P_Act_B_3.value<>tmpStr then
            lbl_P_Act_B_3.value=tmpStr
        endif
    endif
    If PcurB > PMaxWarn then
        If Pumping and not FlowStopped then  'only apply this error in flowmode
            If not AlreadyWarned then
                IF PcurBComCheck then
                REM Check Pressure twice before warn.
                    Handle_Error(6)
                    AlreadyWarned=true
                else
                    PcurBComCheck=true
                endif
            endif

        endif
    else
        PcurBComCheck=false
    Endif


    lbl_psi_indicated.value=tmpStr


endfunc
init enabled := false
init updateperiod := 1000
Enddec
Declare GMCPoll_Pready as GMCPollV2
Level 249742
#Visible True
#Lock False
init parent := daq_objects
init command := "MG Pready"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim Pready as float

    respstr = Clip_String(response,2)

    check error
             Val(Pready,respstr)
    on error
            _ClearException()
    enderr
    If Pready == 1 then
        P_Cont_On = true
        Pumping=true
        lbl_RampStatus.Value="Controlling in pressure mode"
        Init_Press_Ramp()
        Set_Press_Buttons()
        lbl_RampStatus.Value = "Ramping to Target Pressure"
        GMCPoll_Pready.enabled=false
    endif
endfunc



init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_PState_status as GMCPollV2
Level 249731
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_2"
init parent := daq_objects
init xpos := 550
init ypos := 51
init width := 19
init height := 22
init command := "MG PState"

func ResponseReceived (response as reference to string)
    dim temp as string


    temp = Clip_String(response,2)
    check error
        Val(PState,temp)
    on error
        _ClearException()
'        debugEB.appendText="PState response "+response
    enderr

    if PState>6 then
        REM Known bad value
        debugtext="Value of PState read as "+str(PState)
        Write_To_Debug(debugtext, "GMCPoll_PState_status")
    endif

    If P_Stop_Pressed and not Remote_Control then
        If PState==0 then
            GMCPoll_PState_status.enabled = false
            elps_a_1.bgcolor=160
            elps_b_1.bgcolor=160
            Set_Press_Buttons()
            P_Stop_Pressed=False
            Refilling=false
            Set_Press_Buttons()
            lbl_RampStatus.Value="Pressure Control Stopped"
            return
        else
            return
        endif
    endif
    If PState==PStatelast then
        return
    endif

    PStatelast=PState
    If PState ==0  then
        elps_a_1.bgcolor=160
        elps_b_1.bgcolor=160
        elps_a_2.bgcolor=160
        elps_b_2.bgcolor=160
        elps_a_3.bgcolor=160
        elps_b_3.bgcolor=160
        lbl_Current_Mode.value="IDLE"
        If but_PCont.value == "STOP P CONTROL" then
            but_PCont.value="START P CONTROL"
            P_Cont_On = false
            Pumping=false
            Set_Press_Buttons()
        endif

    endif
    If PState ==1 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>160) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=160
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=160
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=160
    endif
    If PState ==2 and (elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>160) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=160
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=160
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=160
    endif
    If PState ==3 and (elps_a_1.bgcolor<>252 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=252
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=252
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=252
        elps_b_3.bgcolor=20
    endif
    If PState ==4 and (elps_a_1.bgcolor<>160 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=160
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=160
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=160
        elps_b_3.bgcolor=20
    endif
    If PState ==5 and (elps_a_1.bgcolor<>160 or elps_b_1.bgcolor<>20) then
        elps_a_1.bgcolor=160
        elps_b_1.bgcolor=20
        elps_a_2.bgcolor=160
        elps_b_2.bgcolor=20
        elps_a_3.bgcolor=160
        elps_b_3.bgcolor=20
    endif
    If PState ==6 and(elps_a_1.bgcolor<>20 or elps_b_1.bgcolor<>252) then
        elps_a_1.bgcolor=20
        elps_b_1.bgcolor=252
        elps_a_2.bgcolor=20
        elps_b_2.bgcolor=252
        elps_a_3.bgcolor=20
        elps_b_3.bgcolor=252
    endif
    if PState==3 or PState==6 then
        Refilling=true
    else
        Refilling=false
    endif
    if PState>0 then
        lbl_Current_Mode.value="PRESSURE"
    elseIF FState==0 then
        lbl_Current_Mode.value="IDLE"
    endif

endfunc
init enabled := false
init updateperiod := 1000

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_Ramping as GMCPollV2
Level 249745
#Visible True
#Lock False
init parent := daq_objects
init command := "MG Ramping"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim Ramping as float

    respstr = Clip_String(response,2)

    check error
             Val(Ramping,respstr)
    on error
            _ClearException()
    enderr
    If Ramping == 0 then
        GMCPoll_Ramping.enabled=false
        rampcomplete=true
        CurrentlyRamping=false
        Set_Press_Buttons()
        eb_target_press.fgcolor=28
        lbl_RampStatus.Value = "Ramp complete - Controlling Pressure"
    endif
endfunc
Enddec
Declare GMCPoll_RCycle as GMCPollV2
Level 249694
#Visible True
#Lock False
init parent := daq_objects
init command := "MG Cycle"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim cycle as float

    respstr = Clip_String(response,2)

    check error
             Val(cycle,respstr)
    on error
            _ClearException()
    enderr
    If cycle == 0 then
        GMCPoll_RCycle.enabled=false
        Cycle_Popup_Screen.enabled=false
        if Estop then
            Estop=false
        else
            if CalStartML>0 and CalFlowML>0 then
                but_Start_Flow_Cal.enabled=true
            endif
            InStartPos=true
            lbl_ml_flowed.value="0.00"
        endif
    endif
endfunc

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Remote as GMCPollV2
Level 249732
#Visible True
#Lock False
init commobject := galilcomm
init value := "gmcpoll_2"
init parent := daq_objects
init xpos := 550
init ypos := 51
init width := 19
init height := 22
init command := "MG Remote"

func ResponseReceived (response as reference to string)
    dim temp as string


    temp = Clip_String(response,2)
    check error
        Val(Remote,temp)
    on error
        _ClearException()
'        debugEB.appendText="Remote response "+response
    enderr
    If Remote==1 and not Remote_Control then
        Remote_Control=True

        Power_Up_Screen.enabled=false
        Title_Screen.enabled=false
        Init_Remote_Display()
    endif

    If Remote==0 and Remote_Display.enabled then
        Exit_Remote_Display()
        Init_Title_Screen()
        Remote_Control=false
    endif


endfunc
init enabled := false
init updateperiod := 5000

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
Enddec
Declare GMCPoll_StReflA as GMCPollV2
Level 249749
#Visible True
#Lock False
init parent := daq_objects
init command := "MG StReflA"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim StReflA as float

    respstr = Clip_String(response,2)

    check error
             Val(StReflA,respstr)
    on error
            _ClearException()
    enderr
    If StReflA == 0 then
        but_Refill_A.enabled=true
        lbl_Manual_Control_Msg.value="Cylinder A refill cycle complete."
        GMCPoll_StReflA.enabled=false
        RefillingA=False
        but_Aout.Value="CLOSED"
        but_AIn.Value="CLOSED"
        but_Aout.enabled=true
        but_AIn.enabled=true
'        but_Start_Flow_Man_A.enabled=true
        If FlowRA <> 0 and FloVolA <> 0 then
            ReadytoFlowA=true
        else
            ReadytoFlowA=false
        endif
        If FlowRB <> 0 and FloVolB <> 0 then
            ReadytoFlowB=true
        else
            ReadytoFlowB=false
        endif
        Set_Manual_Flow_Buttons()
        If not RefillingB then
            but_Estop_1.enabled=false
        endif
    endif
endfunc



init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_StReflB as GMCPollV2
Level 249750
#Visible True
#Lock False
init parent := daq_objects
init command := "MG StReflB"
init commobject := galilcomm
init enabled := false

func ResponseReceived (response as reference to string)
    dim respstr as string
    dim StReflB as float

    respstr = Clip_String(response,2)

    check error
             Val(StReflB,respstr)
    on error
            _ClearException()
    enderr
    If StReflB == 0 then
        but_Refill_B.enabled=true
        lbl_Manual_Control_Msg.value="Cylinder B refill cycle complete."
        GMCPoll_StReflB.enabled=false
        RefillingB=False
        but_Bout.Value="CLOSED"
        but_BIn.Value="CLOSED"
        but_Bout.enabled=true
        but_BIn.enabled=true
'        but_Start_Flow_Man_B.enabled=true
        If FlowRA <> 0 and FloVolA <> 0 then
            ReadytoFlowA=true
        else
            ReadytoFlowA=false
        endif
        If FlowRB <> 0 and FloVolB <> 0 then
            ReadytoFlowB=true
        else
            ReadytoFlowB=false
        endif
        Set_Manual_Flow_Buttons()
        If not RefillingA then
            but_Estop_1.enabled=false
        endif
    endif
endfunc


init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_Target_Press as GMCPollV2
Level 249739
#Visible True
#Lock False
init command := "MG PSetPt"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)
    dim temp as string
    dim SetPoint as float
    dim tmpStr as string

    temp = Clip_String(response,2)

    check error
             Val(SetPoint,temp)
    on error
            _ClearException()
    enderr
    tmpStr = _FormatFloat(SetPoint,6,2,_FLOAT_NORMAL)
    if eb_Target_Press.value<> tmpStr then
        eb_Target_Press.value= tmpStr
    endif

endfunc

init updateperiod := 5000

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare GMCPoll_TarVol as GMCPollV2
Level 249740
#Visible True
#Lock False
init command := "MG TarVol"
init commobject := galilcomm
init enabled := false
init parent := daq_objects

func ResponseReceived (response as reference to string)
    dim temp as string
    dim TarVol as float
    dim tmpStr as string

    temp = Clip_String(response,2)

    check error
             Val(TarVol,temp)
    on error
            _ClearException()
    enderr
    tmpStr=_FormatFloat(TarVol,6,2,_FLOAT_NORMAL)
    If TarVol > 1000000 then
        eb_tar_vol.value="INF"
    else
        if eb_tar_vol.value<>tmpStr then
            eb_tar_vol.value=tmpStr
        endif
    endif


endfunc

init updateperiod := 5000

init height := 40
init font := helvr18_bdf
init width := 40
init xinset := 1
init xpos := 0
init yinset := 0
init ypos := 0
init ptsize := 12
Enddec
Declare Image_1 as ImageV2
Level 249822
#Visible True
#Lock False
init parent := title_screen
init xpos := 0
init ypos := 0
init image := G_72_OpeningScreen
Enddec
Declare Image_10 as ImageV2
Level 249832
#Visible True
#Lock False
init parent := system_maintenance_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_11 as ImageV2
Level 249848
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_12 as ImageV2
Level 249895
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_13 as ImageV2
Level 249931
#Visible True
#Lock False
init parent := limits_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_14 as ImageV2
Level 249958
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_15 as ImageV2
Level 249402
#Visible True
#Lock False
init parent := profile_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_16 as ImageV2
Level 249333
#Visible True
#Lock False
init parent := welcome_screen
init xpos := 0
init ypos := 0
init image := G_72_OpeningScreen
Enddec
Declare Image_17 as ImageV2
Level 249366
#Visible True
#Lock Me
init parent := remote_display
init xpos := 1
init ypos := 0
init image := Banner_Rev5
Enddec
Declare Image_18 as ImageV2
Level 249481
#Visible True
#Lock False
init parent := error_log_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_2 as ImageV2
Level 249546
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5
Enddec
Declare Image_3 as ImageV2
Level 249485
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_4 as ImageV2
Level 249463
#Visible True
#Lock False
init parent := sys_setup_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_5 as ImageV2
Level 249793
#Visible True
#Lock False
init parent := valve_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_6 as ImageV2
Level 249629
#Visible True
#Lock False
init parent := p_cal_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_7 as ImageV2
Level 249818
#Visible True
#Lock False
init parent := wait_for_cycle_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_8 as ImageV2
Level 249584
#Visible True
#Lock False
init parent := initialize_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Image_9 as ImageV2
Level 249659
#Visible True
#Lock False
init parent := vol_cal_screen
init xpos := 1
init ypos := 0
init image := Banner_Rev5

init transparent := true
Enddec
Declare Init_Popup_Screen as PopupScreenV2
Level 250000
#Visible False
#Lock False
init xpos := 80
init ypos := 200
init width := 300
init height := 350
init dragmode := _ps_nodrag
init cancelbutton := false
init value := "PUMP INITIALIZING"
init font := helvb18_bdf
init xjustify := hjustify_centeralign
init enabled := false
Enddec
Declare Initialize_screen as ScreenV2
Level 249589
#Visible False
#Lock Me
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := False
Enddec
Declare IP_Address_Screen as ScreenV2
Level 249973
#Visible False
#Lock False
init width := 480
init height := 800
init enabled := false
Enddec
Declare KeypadSettings as KeypadSettingsv2
Level 249363
#Visible False
#Lock False
init barfont := default_ttf
init barptsize := 12
Enddec
Declare KeyTranslator as KeyTranslationv2
Level 249364
#Visible False
#Lock False
init translationtable := "0241F11242F22243F33244F4876L985U1068D1182R1645-1749118502195132446.255242653527546328\x083355734568355794127\x1b424804313\r"
init translationTableShifted := "0241F11242F22243F33244F4840(941)1060<1162>1644,17476<home>18229<up>19493<pgup>2435#25219<left>2637%27228<right>33473<end>34226<down>35490<pgdn>418\x084294^4332 "
Enddec
Declare KProp_screen as ScreenV2
Level 249508
#Visible False
#Lock False
init parent := pressure_mode_screen
init xpos := 8
init ypos := 3
init width := 304
init height := 318
init borderstyle := bdr_compositeobject
init enabled := false
Enddec
Declare Label_1 as LabelV2
Level 249674
#Visible True
#Lock False
init value := "Cylinder to Calibrate"
init parent := vol_cal_screen
init xpos := 25
init ypos := 101
init width := 256
init height := 35
init font := helvb18_bdf
init xjustify := hjustify_leftalign
init borderstyle := bdr_none
Enddec
Declare Label_10 as LabelV2
Level 249679
#Visible True
#Lock False
init value := "Calibration Constant (ml/mm)"
init parent := vol_cal_screen
init xpos := 25
init ypos := 376
init width := 280
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_leftalign
Enddec
Declare Label_101 as LabelV2
Level 249668
#Visible True
#Lock False
init value := "Measured ml"
init parent := vol_cal_screen
init xpos := 330
init ypos := 504
init width := 128
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_103 as LabelV2
Level 249667
#Visible True
#Lock False
init value := "VOLUME CALIBRATION"
init parent := vol_cal_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 60
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_11 as LabelV2
Level 249521
#Visible True
#Lock False
init value := "psi"
init parent := pressure_mode_screen
init xpos := 373
init ypos := 420
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_12 as LabelV2
Level 249680
#Visible True
#Lock False
init value := "Nominal Rod Dia (mm)"
init parent := vol_cal_screen
init xpos := 25
init ypos := 340
init width := 216
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_leftalign
Enddec
Declare Label_13 as LabelV2
Level 249642
#Visible True
#Lock False
init value := "Transducer to Calibrate"
init parent := p_cal_screen
init xpos := 25
init ypos := 100
init width := 280
init height := 35
init font := helvb18_bdf
init xjustify := hjustify_leftalign
init borderstyle := bdr_none
Enddec
Declare Label_14 as LabelV2
Level 249833
#Visible True
#Lock False
init value := "SYSTEM MAINTENANCE"
init parent := system_maintenance_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_15 as LabelV2
Level 249557
#Visible True
#Lock False
init value := "ml"
init parent := flow_mode_screen
init xpos := 378
init ypos := 258
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_16 as LabelV2
Level 249558
#Visible True
#Lock False
init value := "ml/min"
init parent := flow_mode_screen
init xpos := 371
init ypos := 189
init width := 54
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_17 as LabelV2
Level 249559
#Visible True
#Lock False
init value := "ml/min"
init parent := flow_mode_screen
init xpos := 367
init ypos := 430
init width := 54
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_18 as LabelV2
Level 249560
#Visible True
#Lock False
init value := "ml"
init parent := flow_mode_screen
init xpos := 398
init ypos := 495
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_19 as LabelV2
Level 249682
#Visible True
#Lock False
init value := "Volume to Flow (ml)"
init parent := vol_cal_screen
init xpos := 25
init ypos := 248
init width := 270
init height := 35
init font := helvb18_bdf
init xjustify := hjustify_leftalign
init borderstyle := bdr_none
Enddec
Declare Label_2 as LabelV2
Level 249677
#Visible True
#Lock False
init value := "Valve to Flow Through"
init parent := vol_cal_screen
init xpos := 25
init ypos := 150
init width := 270
init height := 35
init font := helvb18_bdf
init xjustify := hjustify_leftalign
init borderstyle := bdr_none
Enddec
Declare Label_20 as LabelV2
Level 249684
#Visible True
#Lock False
init value := "Current Pos (ml)"
init parent := vol_cal_screen
init xpos := 15
init ypos := 504
init width := 140
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_21 as LabelV2
Level 249594
#Visible True
#Lock False
init value := "CYL A"
init parent := config_screen
init xpos := 252
init ypos := 348
init width := 85
init height := 24
init font := helvb18_bdf
Enddec
Declare Label_22 as LabelV2
Level 249595
#Visible True
#Lock False
init value := "CYL B"
init parent := config_screen
init xpos := 367
init ypos := 348
init width := 85
init height := 24
init font := helvb18_bdf
Enddec
Declare Label_23 as LabelV2
Level 249640
#Visible True
#Lock False
init value := "Pressure Range (psi)"
init parent := p_cal_screen
init xpos := 25
init ypos := 200
init width := 216
init height := 35
init borderstyle := bdr_none
init transparent := true

init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_leftalign
Enddec
Declare Label_24 as LabelV2
Level 249649
#Visible True
#Lock False
init value := "Volts/psi"
init parent := p_cal_screen
init xpos := 25
init ypos := 250
init width := 216
init height := 35
init borderstyle := bdr_none
init transparent := true

init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_leftalign
Enddec
Declare Label_25 as LabelV2
Level 249650
#Visible True
#Lock False
init value := "Full Scale Volts"
init parent := p_cal_screen
init xpos := 25
init ypos := 300
init width := 216
init height := 35
init borderstyle := bdr_none
init transparent := true

init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_leftalign
Enddec
Declare Label_26 as LabelV2
Level 249523
#Visible True
#Lock False
init value := "ml/min"
init parent := pressure_mode_screen
init xpos := 366
init ypos := 515
init width := 58
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_27 as LabelV2
Level 249794
#Visible True
#Lock False
init value := "VALVE CONTROL"
init parent := valve_screen
init xpos := 0
init ypos := -3
init width := 480
init height := 64
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_28 as LabelV2
Level 249849
#Visible True
#Lock False
init value := "SYSTEM RESTART"
init parent := power_up_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_29 as LabelV2
Level 249859
#Visible True
#Lock False
init value := "ml"
init parent := power_up_screen
init xpos := 410
init ypos := 157
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_3 as LabelV2
Level 249490
#Visible True
#Lock False
init value := "PRESSURE MODE"
init parent := pressure_mode_screen
init xpos := 0
init ypos := -3
init width := 480
init height := 64
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_30 as LabelV2
Level 249858
#Visible True
#Lock False
init value := "psi"
init parent := power_up_screen
init xpos := 410
init ypos := 107
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_31 as LabelV2
Level 249863
#Visible True
#Lock False
init value := "psi"
init parent := power_up_screen
init xpos := 410
init ypos := 275
init width := 32
init height := 40
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_32 as LabelV2
Level 249862
#Visible True
#Lock False
init value := "ml"
init parent := power_up_screen
init xpos := 410
init ypos := 325
init width := 32
init height := 40
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_33 as LabelV2
Level 249898
#Visible True
#Lock False
init value := "(psi)"
init parent := manual_control_screen
init xpos := 57
init ypos := 135
init width := 40
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_34 as LabelV2
Level 249897
#Visible True
#Lock False
init value := "(ml)"
init parent := manual_control_screen
init xpos := 62
init ypos := 188
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_35 as LabelV2
Level 249896
#Visible True
#Lock False
init value := "MANUAL CONTROL"
init parent := manual_control_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_36 as LabelV2
Level 249920
#Visible True
#Lock False
init value := "(ml)"
init parent := manual_control_screen
init xpos := 178
init ypos := 385
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_37 as LabelV2
Level 249915
#Visible True
#Lock False
init value := "(ml/min)"
init parent := manual_control_screen
init xpos := 166
init ypos := 300
init width := 65
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_38 as LabelV2
Level 249464
#Visible True
#Lock False
init value := "SYSTEM SETUP"
init parent := sys_setup_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_39 as LabelV2
Level 249924
#Visible True
#Lock False
init value := "(psi)"
init parent := manual_control_screen
init xpos := 274
init ypos := 135
init width := 40
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_4 as LabelV2
Level 249522
#Visible False
#Lock False
init value := "psi/sec"
init parent := pressure_mode_screen
init xpos := 366
init ypos := 466
init width := 58
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_40 as LabelV2
Level 249923
#Visible True
#Lock False
init value := "(ml)"
init parent := manual_control_screen
init xpos := 279
init ypos := 188
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_41 as LabelV2
Level 249922
#Visible True
#Lock False
init value := "(ml)"
init parent := manual_control_screen
init xpos := 395
init ypos := 385
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_42 as LabelV2
Level 249921
#Visible True
#Lock False
init value := "(ml/min)"
init parent := manual_control_screen
init xpos := 383
init ypos := 300
init width := 65
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_43 as LabelV2
Level 249869
#Visible True
#Lock False
init value := "ml"
init parent := power_up_screen
init xpos := 410
init ypos := 212
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_44 as LabelV2
Level 249872
#Visible True
#Lock False
init value := "ml"
init parent := power_up_screen
init xpos := 410
init ypos := 375
init width := 32
init height := 40
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_45 as LabelV2
Level 249556
#Visible True
#Lock False
init value := "psi"
init parent := flow_mode_screen
init xpos := 378
init ypos := 143
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_46 as LabelV2
Level 249876
#Visible True
#Lock False
init value := "ml"
init parent := power_up_screen
init xpos := 410
init ypos := 435
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_47 as LabelV2
Level 249939
#Visible True
#Lock False
init value := "PRESSURE & FLOW RATE LIMITS"
init parent := limits_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_48 as LabelV2
Level 249590
#Visible True
#Lock False
init value := "SYSTEM CONFIGURATION"
init parent := config_screen
init xpos := 0
init ypos := 0
init width := 512
init height := 48
init fgcolor := 255
init bgcolor := 38

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
Enddec
Declare Label_49 as LabelV2
Level 249938
#Visible True
#Lock False
init value := "ml/min"
init parent := limits_screen
init xpos := 378
init ypos := 157
init width := 55
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_5 as LabelV2
Level 249681
#Visible True
#Lock False
init value := "Start Position (ml)"
init parent := vol_cal_screen
init xpos := 25
init ypos := 199
init width := 305
init height := 35
init font := helvb18_bdf
init xjustify := hjustify_leftalign
init borderstyle := bdr_none
Enddec
Declare Label_50 as LabelV2
Level 249937
#Visible True
#Lock False
init value := "ml/min"
init parent := limits_screen
init xpos := 378
init ypos := 107
init width := 55
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_51 as LabelV2
Level 249949
#Visible True
#Lock False
init value := "psi"
init parent := limits_screen
init xpos := 379
init ypos := 310
init width := 55
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_52 as LabelV2
Level 249948
#Visible True
#Lock False
init value := "psi"
init parent := limits_screen
init xpos := 379
init ypos := 260
init width := 55
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_53 as LabelV2
Level 249927
#Visible True
#Lock False
init value := "(ml/min)"
init parent := manual_control_screen
init xpos := 166
init ypos := 450
init width := 65
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_54 as LabelV2
Level 249960
#Visible True
#Lock False
init value := "IP ADDRESS"
init parent := ip_address_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_55 as LabelV2
Level 249967
#Visible True
#Lock False
init value := "."
init parent := ip_address_screen
init xpos := 156
init ypos := 150
init width := 8
init height := 5
init borderstyle := bdr_none
init ptsize := 100
init bgcolor := clr_softkeybarbuttonbg
init fgcolor := clr_buttonforeground
init font := helvb24_bdf
Enddec
Declare Label_56 as LabelV2
Level 249968
#Visible True
#Lock False
init value := "."
init parent := ip_address_screen
init xpos := 226
init ypos := 150
init width := 8
init height := 5
init borderstyle := bdr_none
init ptsize := 100
init bgcolor := clr_softkeybarbuttonbg
init fgcolor := clr_buttonforeground
init font := helvb24_bdf
Enddec
Declare Label_57 as LabelV2
Level 249969
#Visible True
#Lock False
init value := "."
init parent := ip_address_screen
init xpos := 296
init ypos := 150
init width := 8
init height := 5
init borderstyle := bdr_none
init ptsize := 100
init bgcolor := clr_softkeybarbuttonbg
init fgcolor := clr_buttonforeground
init font := helvb24_bdf
Enddec
Declare Label_58 as LabelV2
Level 249406
#Visible True
#Lock False
init value := "PROFILE MODE"
init parent := profile_screen
init xpos := 0
init ypos := -3
init width := 480
init height := 64
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_59 as LabelV2
Level 249407
#Visible True
#Lock False
init value := "ml"
init parent := profile_screen
init xpos := 365
init ypos := 195
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_6 as LabelV2
Level 249520
#Visible True
#Lock False
init value := "ml"
init parent := pressure_mode_screen
init xpos := 378
init ypos := 258
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_60 as LabelV2
Level 249408
#Visible True
#Lock False
init value := "ml/min"
init parent := profile_screen
init xpos := 365
init ypos := 145
init width := 54
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_61 as LabelV2
Level 249409
#Visible True
#Lock False
init value := "psi"
init parent := profile_screen
init xpos := 365
init ypos := 108
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_62 as LabelV2
Level 249812
#Visible True
#Lock False
init value := "INLET"
init parent := valve_screen
init xpos := 258
init ypos := 579
init width := 73
init height := 17
init transparent := true
init borderstyle := bdr_none
init font := helvb14_bdf
Enddec
Declare Label_63 as LabelV2
Level 249813
#Visible True
#Lock False
init value := "OUTLET"
init parent := valve_screen
init xpos := 350
init ypos := 579
init width := 73
init height := 17
init transparent := true
init borderstyle := bdr_none
init font := helvb14_bdf
Enddec
Declare Label_64 as LabelV2
Level 249451
#Visible True
#Lock False
init value := "Tot"
init parent := profile_screen
init xpos := 260
init ypos := 244
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_65 as LabelV2
Level 249452
#Visible True
#Lock False
init value := "Seg"
init parent := profile_screen
init xpos := 381
init ypos := 246
init width := 40
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_66 as LabelV2
Level 249783
#Visible True
#Lock Me
init value := "FACTORY SETTINGS"
init parent := fact_set_warning_screen
init xpos := 0
init ypos := 0
init width := 512
init height := 64
init fgcolor := 255
init bgcolor := Clr_Banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
Enddec
Declare Label_67 as LabelV2
Level 249814
#Visible True
#Lock False
init value := "OPEN"
init parent := valve_screen
init xpos := 258
init ypos := 610
init width := 73
init height := 17
init transparent := true
init borderstyle := bdr_none
init font := helvb14_bdf
Enddec
Declare Label_68 as LabelV2
Level 249634
#Visible True
#Lock False
init value := "PRESSURE CALIBRATION"
init parent := p_cal_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 60
init fgcolor := 255
init bgcolor := clr_banner
init font := helvb24_bdf
init ptsize := 22
init transparent := true
Enddec
Declare Label_69 as LabelV2
Level 249815
#Visible True
#Lock False
init value := "CLOSED"
init parent := valve_screen
init xpos := 350
init ypos := 610
init width := 73
init height := 17
init transparent := true
init borderstyle := bdr_none
init font := helvb14_bdf
Enddec
Declare Label_7 as LabelV2
Level 249519
#Visible True
#Lock False
init value := "ml/min"
init parent := pressure_mode_screen
init xpos := 371
init ypos := 189
init width := 54
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_70 as LabelV2
Level 249688
#Visible True
#Lock False
init value := "Vol Flowed (ml)"
init parent := vol_cal_screen
init xpos := 170
init ypos := 504
init width := 140
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_71 as LabelV2
Level 249928
#Visible True
#Lock False
init value := "(ml/min)"
init parent := manual_control_screen
init xpos := 383
init ypos := 450
init width := 65
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_72 as LabelV2
Level 249379
#Visible True
#Lock False
init value := "ml/min"
init parent := remote_display
init xpos := 371
init ypos := 189
init width := 54
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_73 as LabelV2
Level 249380
#Visible True
#Lock False
init value := "ml"
init parent := remote_display
init xpos := 378
init ypos := 258
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_74 as LabelV2
Level 249381
#Visible True
#Lock False
init value := "psi"
init parent := remote_display
init xpos := 378
init ypos := 143
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_75 as LabelV2
Level 249482
#Visible True
#Lock False
init value := "Error Log"
init parent := error_log_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 63
init fgcolor := 255
init bgcolor := Clr_Banner

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_77 as LabelV2
Level 249466
#Visible True
#Lock False
init value := "Software Version VPA 301 29-4-2014"
init parent := sys_setup_screen
init xpos := 54
init ypos := 770
init width := 380
init height := 25

init font := default_ttf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_78 as LabelV2
Level 249491
#Visible True
#Lock False
init value := "Kprop "
init parent := kprop_screen
init xpos := 12
init ypos := 9
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_79 as LabelV2
Level 249493
#Visible True
#Lock False
init value := "Max Error"
init parent := kprop_screen
init xpos := 12
init ypos := 212
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_8 as LabelV2
Level 249509
#Visible True
#Lock False
init value := "psi"
init parent := pressure_mode_screen
init xpos := 378
init ypos := 143
init width := 32
init height := 19
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare Label_80 as LabelV2
Level 249494
#Visible True
#Lock False
init value := "Kx"
init parent := kprop_screen
init xpos := 12
init ypos := 60
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_81 as LabelV2
Level 249499
#Visible True
#Lock False
init value := "Dgain"
init parent := kprop_screen
init xpos := 12
init ypos := 112
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_82 as LabelV2
Level 249500
#Visible True
#Lock False
init value := "Igain"
init parent := kprop_screen
init xpos := 12
init ypos := 161
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_83 as LabelV2
Level 249506
#Visible True
#Lock False
init value := "Isum"
init parent := kprop_screen
init xpos := 12
init ypos := 265
init width := 280
init height := 48
init xjustify := hjustify_leftalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare Label_9 as LabelV2
Level 249586
#Visible True
#Lock False
init value := "INITIALIZE VPA"
init parent := initialize_screen
init xpos := 0
init ypos := 0
init width := 512
init height := 60
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf

init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare Label_98 as LabelV2
Level 249819
#Visible True
#Lock False
init value := "CYLINDER STROKING"
init parent := wait_for_cycle_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 60
init fgcolor := 255
init bgcolor := Clr_Banner
init font := helvb24_bdf
init ptsize := 22
init transparent := true
Enddec
Declare lbl_Calibrate_1 as LabelV2
Level 249632
#Visible True
#Lock False
init value := "INDICATED AND ACTUAL PRESSURES"
init parent := p_cal_screen
init xpos := 10
init ypos := 430
init width := 460
init height := 98

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_Calibrate_2 as LabelV2
Level 249639
#Visible True
#Lock False
init value := "Indicated Pressure (psi)"
init parent := p_cal_screen
init xpos := 30
init ypos := 455
init width := 200
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Calibrate_3 as LabelV2
Level 249641
#Visible True
#Lock False
init value := "Actual Pressure (psi)"
init parent := p_cal_screen
init xpos := 265
init ypos := 455
init width := 200
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Flow_Rate as LabelV2
Level 249569
#Visible True
#Lock False
init value := "0.00"
init parent := flow_mode_screen
init xpos := 245
init ypos := 186
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Flow_Rate_1 as LabelV2
Level 249529
#Visible True
#Lock False
init value := "100.12"
init parent := pressure_mode_screen
init xpos := 240
init ypos := 186
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Flow_Rate_2 as LabelV2
Level 249410
#Visible True
#Lock False
init value := "4.85"
init parent := profile_screen
init xpos := 250
init ypos := 145
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Flow_Rate_3 as LabelV2
Level 249370
#Visible True
#Lock False
init value := "0.00"
init parent := remote_display
init xpos := 245
init ypos := 186
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Mode as LabelV2
Level 249386
#Visible True
#Lock False
init value := "IDLE"
init parent := remote_display
init xpos := 244
init ypos := 296
init width := 120
init height := 48

init xjustify := hjustify_center

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20

init bgcolor := clr_buttonforeground
init fgcolor := clr_labelbackground
Enddec
Declare lbl_Current_Pos as LabelV2
Level 249566
#Visible True
#Lock False
init value := "0.00"
init parent := flow_mode_screen
init xpos := 244
init ypos := 241
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_Pos_1 as LabelV2
Level 249373
#Visible True
#Lock False
init value := "0.00"
init parent := remote_display
init xpos := 244
init ypos := 241
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Current_pos_bk as LabelV2
Level 249548
#Visible True
#Lock False
init value := ""
init parent := flow_mode_screen
init xpos := 50
init ypos := 80
init width := 380
init height := 216

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_1 as LabelV2
Level 249789
#Visible True
#Lock False
init value := ""
init parent := valve_screen
init xpos := 30
init ypos := 80
init width := 420
init height := 377

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_10 as LabelV2
Level 249873
#Visible True
#Lock False
init value := "Time - Date Stamp"
init parent := power_up_screen
init xpos := 30
init ypos := 470
init width := 420
init height := 45

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_centeralign
Enddec
Declare lbl_Current_pos_bk_11 as LabelV2
Level 249855
#Visible True
#Lock False
init value := "Total volume pumped"
init parent := power_up_screen
init xpos := 30
init ypos := 425
init width := 420
init height := 40

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_centeralign
Enddec
Declare lbl_Current_pos_bk_12 as LabelV2
Level 249932
#Visible True
#Lock False
init value := "Pressure Control Mode"
init parent := limits_screen
init xpos := 30
init ypos := 70
init width := 420
init height := 140

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_13 as LabelV2
Level 249933
#Visible True
#Lock False
init value := "Flow Control Mode"
init parent := limits_screen
init xpos := 31
init ypos := 223
init width := 420
init height := 140

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_14 as LabelV2
Level 249957
#Visible True
#Lock False
init value := "IP Address"
init parent := ip_address_screen
init xpos := 30
init ypos := 70
init width := 420
init height := 140

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_15 as LabelV2
Level 249970
#Visible True
#Lock False
init value := "DHCP"
init parent := ip_address_screen
init xpos := 30
init ypos := 250
init width := 420
init height := 140

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_16 as LabelV2
Level 249391
#Visible True
#Lock False
init value := ""
init parent := profile_screen
init xpos := 60
init ypos := 70
init width := 360
init height := 205

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_17 as LabelV2
Level 249367
#Visible True
#Lock False
init value := ""
init parent := remote_display
init xpos := 50
init ypos := 80
init width := 380
init height := 280

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_2 as LabelV2
Level 249547
#Visible True
#Lock False
init value := ""
init parent := flow_mode_screen
init xpos := 49
init ypos := 364
init width := 380
init height := 176

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := Clr_SoftkeybarBackground
Enddec
Declare lbl_Current_pos_bk_3 as LabelV2
Level 249486
#Visible True
#Lock False
init value := ""
init parent := pressure_mode_screen
init xpos := 50
init ypos := 80
init width := 380
init height := 216

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_4 as LabelV2
Level 249514
#Visible True
#Lock False
init value := ""
init parent := pressure_mode_screen
init xpos := 49
init ypos := 365
init width := 380
init height := 250

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_5 as LabelV2
Level 249834
#Visible True
#Lock False
init value := ""
init parent := system_maintenance_screen
init xpos := 30
init ypos := 80
init width := 420
init height := 377

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_6 as LabelV2
Level 249847
#Visible True
#Lock False
init value := "Cylinder A"
init parent := power_up_screen
init xpos := 30
init ypos := 70
init width := 420
init height := 170

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_7 as LabelV2
Level 249860
#Visible True
#Lock False
init value := "Cylinder B"
init parent := power_up_screen
init xpos := 30
init ypos := 250
init width := 420
init height := 170

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_topalign
Enddec
Declare lbl_Current_pos_bk_8 as LabelV2
Level 249879
#Visible True
#Lock False
init value := ""
init parent := manual_control_screen
init xpos := 26
init ypos := 71
init width := 205
init height := 580

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Current_pos_bk_9 as LabelV2
Level 249880
#Visible True
#Lock False
init value := ""
init parent := manual_control_screen
init xpos := 247
init ypos := 70
init width := 205
init height := 580

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Cycle_Msg_2 as LabelV2
Level 249979
#Visible True
#Lock False
init value := "Waiting for cylinder to stroke to start position"
init parent := cycle_popup_screen
init xpos := 10
init ypos := 50
init width := 280
init height := 101
init font := helvb18_bdf
init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init bgcolor := clr_messagebackground
Enddec
Declare lbl_Cycle_Msg_3 as LabelV2
Level 249784
#Visible True
#Lock False
init value := "Setting Factory Settings will reset system configuration settings and calibration settings to factory defaults.  Press OK to confirm."
init parent := fact_set_warning_screen
init xpos := 28
init ypos := 120
init width := 425
init height := 169

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init bgcolor := clr_messagebackground
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_date_of_Maint as LabelV2
Level 249840
#Visible True
#Lock False
init value := "01 Jan 2012"
init parent := system_maintenance_screen
init xpos := 300
init ypos := 100
init width := 140
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Dgain_Cur as LabelV2
Level 249502
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 80
init ypos := 118
init width := 96
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_DP_Range_Bgnd as LabelV2
Level 249600
#Visible True
#Lock False
init value := "Press range (psi)"
init parent := config_screen
init xpos := 15
init ypos := 50
init width := 250
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_DP_Range_Bgnd_1 as LabelV2
Level 249630
#Visible True
#Lock False
init value := "CALIBRATION SETUP"
init parent := p_cal_screen
init xpos := 10
init ypos := 70
init width := 460
init height := 85

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_DP_Range_Bgnd_10 as LabelV2
Level 249660
#Visible True
#Lock False
init value := "INDICATED AND MEASURED VOLUMES"
init parent := vol_cal_screen
init xpos := 5
init ypos := 474
init width := 470
init height := 98

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_DP_Range_Bgnd_3 as LabelV2
Level 249631
#Visible True
#Lock False
init value := "CURRENT CALIBRATION VALUES"
init parent := p_cal_screen
init xpos := 10
init ypos := 170
init width := 460
init height := 180

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_DP_Range_Bgnd_8 as LabelV2
Level 249662
#Visible True
#Lock False
init value := "CALIBRATION SETUP"
init parent := vol_cal_screen
init xpos := 5
init ypos := 68
init width := 470
init height := 226

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_DP_Range_Bgnd_9 as LabelV2
Level 249661
#Visible True
#Lock False
init value := "CURRENT CALIBRATION VALUES"
init parent := vol_cal_screen
init xpos := 5
init ypos := 303
init width := 470
init height := 101

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_dummy as LabelV2
Level 249597
#Visible True
#Lock False
init value := "label_39"
init parent := config_screen
init xpos := 640
init ypos := 100
init width := 1
init height := 1

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init fgcolor := clr_buttonforeground
init bgcolor := clr_buttonbackground
Enddec
Declare lbl_dummy_1 as LabelV2
Level 249596
#Visible True
#Lock False
init value := "label_39"
init parent := config_screen
init xpos := 400
init ypos := 63
init width := 1
init height := 1
Enddec
Declare lbl_ErrCode as LabelV2
Level 249990
#Visible True
#Lock False
init value := "22"
init parent := error_popup_screen
init xpos := 274
init ypos := 247
init width := 50
init height := 26
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb18_bdf

init blinkperiod := 0
Enddec
Declare lbl_ErrCode1 as LabelV2
Level 249995
#Visible True
#Lock False
init value := "Ecode"
init parent := error_popup_screen
init xpos := 270
init ypos := 217
init width := 58
init height := 26
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_ErrNo as LabelV2
Level 249989
#Visible True
#Lock False
init value := "127"
init parent := error_popup_screen
init xpos := 90
init ypos := 74
init width := 50
init height := 26
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb18_bdf

init blinkperiod := 0
Enddec
Declare lbl_Error_Msg as LabelV2
Level 249986
#Visible True
#Lock False
init value := ""
init parent := error_popup_screen
init xpos := 8
init ypos := 114
init width := 325
init height := 104
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvb18_bdf
Enddec
Declare lbl_ErrTime as LabelV2
Level 249988
#Visible True
#Lock False
init value := "12:32  Oct 16 2012"
init parent := error_popup_screen
init xpos := 148
init ypos := 74
init width := 180
init height := 26
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb18_bdf

init blinkperiod := 0
Enddec
Declare lbl_FillR_Bgnd as LabelV2
Level 249603
#Visible True
#Lock False
init value := "Fill Rate - Pressure Control (ml/min)"
init parent := config_screen
init xpos := 15
init ypos := 150
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Flow_Instructions as LabelV2
Level 249567
#Visible True
#Lock False
init value := "You must cycle cylinders to start before flow can be started"
init parent := flow_mode_screen
init xpos := 50
init ypos := 610
init width := 380
init height := 50
init bgcolor := Clr_MessageBackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Flow_Limit_bk_1 as LabelV2
Level 249987
#Visible True
#Lock False
init value := "Error No"
init parent := error_popup_screen
init xpos := 8
init ypos := 60
init width := 325
init height := 50
init font := helvb18_bdf
init xjustify := hjustify_leftalign
Enddec
Declare lbl_Flow_Mode as LabelV2
Level 249565
#Visible True
#Lock False
init value := "FLOW MODE"
init parent := flow_mode_screen
init xpos := 0
init ypos := 0
init width := 480
init height := 64
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare lbl_Flow_Shutdown as LabelV2
Level 249954
#Visible True
#Lock False
init value := "Flow Rate (Shut Down)"
init parent := limits_screen
init xpos := 31
init ypos := 520
init width := 420
init height := 60

init xjustify := hjustify_leftalign
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_centeralign
Enddec
Declare lbl_FS_volts as LabelV2
Level 249651
#Visible True
#Lock False
init value := "00.00"
init parent := p_cal_screen
init xpos := 340
init ypos := 300
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := clr_screenbackground
init ptsize := 12
init font := helvb18_bdf
Enddec
Declare lbl_FS_volts_new as LabelV2
Level 249655
#Visible True
#Lock False
init value := "00.00"
init parent := p_cal_screen
init xpos := 220
init ypos := 300
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := 61
init ptsize := 12
init font := helvb18_bdf

init blinkperiod := 1000
init enabled := false
Enddec
Declare lbl_Fwd_Amax_Bgnd as LabelV2
Level 249604
#Visible True
#Lock False
init value := "Forward Max (ml)"
init parent := config_screen
init xpos := 15
init ypos := 524
init width := 450
init height := 45
init font := helvb18_bdf
init xjustify := hjustify_leftalign

init ptsize := 12
Enddec
Declare lbl_Igain_Cur as LabelV2
Level 249501
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 80
init ypos := 168
init width := 96
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Init_Msg as LabelV2
Level 249998
#Visible True
#Lock False
init value := "Cylinders stroking to limits to define position"
init parent := init_popup_screen
init xpos := 10
init ypos := 50
init width := 280
init height := 101
init font := helvb18_bdf
init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init bgcolor := clr_messagebackground
Enddec
Declare lbl_IP_Msg as LabelV2
Level 249959
#Visible True
#Lock False
init value := "Current IP address shown, Enter new IP address"
init parent := ip_address_screen
init xpos := 30
init ypos := 560
init width := 420
init height := 100

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb18_bdf

init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Isum as LabelV2
Level 249507
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 120
init ypos := 273
init width := 171
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_KProp_Cur as LabelV2
Level 249492
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 80
init ypos := 19
init width := 96
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Kx_Cur as LabelV2
Level 249497
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 80
init ypos := 68
init width := 96
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Lapsed_Time_Profile as LabelV2
Level 249449
#Visible True
#Lock False
init value := "00:00:00"
init parent := profile_screen
init xpos := 180
init ypos := 236
init width := 80
init height := 30
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Lapsed_Time_Segment as LabelV2
Level 249450
#Visible True
#Lock False
init value := "00:00:00"
init parent := profile_screen
init xpos := 300
init ypos := 236
init width := 80
init height := 30
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Lim_Seg_1 as LabelV2
Level 249442
#Visible True
#Lock False
init value := "min"
init parent := profile_screen
init xpos := 398
init ypos := 317
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Lim_Seg_2 as LabelV2
Level 249443
#Visible True
#Lock False
init value := "ml"
init parent := profile_screen
init xpos := 398
init ypos := 365
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Lim_Seg_3 as LabelV2
Level 249444
#Visible True
#Lock False
init value := "psi"
init parent := profile_screen
init xpos := 398
init ypos := 413
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Lim_Seg_4 as LabelV2
Level 249445
#Visible True
#Lock False
init value := "min"
init parent := profile_screen
init xpos := 398
init ypos := 463
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Lim_Seg_5 as LabelV2
Level 249446
#Visible True
#Lock False
init value := ""
init parent := profile_screen
init xpos := 398
init ypos := 513
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Lim_Seg_6 as LabelV2
Level 249447
#Visible True
#Lock False
init value := ""
init parent := profile_screen
init xpos := 398
init ypos := 563
init width := 45
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Limits_Msg as LabelV2
Level 249936
#Visible True
#Lock False
init value := "Set limits for warning and for shut down. For maximum pressure in flow control mode and for maximum flow rate in pressure control mode"
init parent := limits_screen
init xpos := 30
init ypos := 600
init width := 420
init height := 100

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb18_bdf

init enabled := true
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_LineNum as LabelV2
Level 249991
#Visible True
#Lock False
init value := "1234"
init parent := error_popup_screen
init xpos := 152
init ypos := 247
init width := 50
init height := 26
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb18_bdf

init blinkperiod := 0
Enddec
Declare lbl_LineNum1 as LabelV2
Level 249994
#Visible True
#Lock False
init value := "LineNo"
init parent := error_popup_screen
init xpos := 148
init ypos := 217
init width := 58
init height := 26
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Maint_hrs as LabelV2
Level 249841
#Visible True
#Lock False
init value := "1000.00"
init parent := system_maintenance_screen
init xpos := 300
init ypos := 160
init width := 140
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Manual_Control_Msg as LabelV2
Level 249899
#Visible True
#Lock False
init value := ""
init parent := manual_control_screen
init xpos := 30
init ypos := 655
init width := 420
init height := 60

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb18_bdf

init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Maxerror_Cur as LabelV2
Level 249505
#Visible True
#Lock False
init value := "1000"
init parent := kprop_screen
init xpos := 120
init ypos := 219
init width := 80
init height := 32
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_ml_cur_cal as LabelV2
Level 249666
#Visible True
#Lock False
init value := "00.00"
init parent := vol_cal_screen
init xpos := 40
init ypos := 529
init width := 100
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_ml_flowed as LabelV2
Level 249687
#Visible True
#Lock False
init value := "00.00"
init parent := vol_cal_screen
init xpos := 190
init ypos := 529
init width := 100
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_ml_per_mm as LabelV2
Level 249665
#Visible True
#Lock False
init value := "0.0742"
init parent := vol_cal_screen
init xpos := 297
init ypos := 366
init width := 128
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_ml_per_mm_CALC as LabelV2
Level 249685
#Visible True
#Lock False
init value := "0.0742"
init parent := vol_cal_screen
init xpos := 216
init ypos := 596
init width := 128
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_MLtot as LabelV2
Level 249875
#Visible True
#Lock False
init value := "1000.00"
init parent := power_up_screen
init xpos := 275
init ypos := 427
init width := 136
init height := 36
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_msg_Title as LabelV2
Level 249823
#Visible True
#Lock False
init value := "Controller Communication Error"
init parent := title_screen
init xpos := 0
init ypos := 2
init width := 480
init height := 28
init borderstyle := Bdr_CompositeSunken

init font := helvr18_bdf
init bgcolor := clr_buttonbackground
init blinkperiod := 2000
init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_New_Constant_1 as LabelV2
Level 249643
#Visible True
#Lock False
init value := "ENTER NEW CONSTANT"
init parent := p_cal_screen
init xpos := 10
init ypos := 450
init width := 460
init height := 98

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init yjustify := vjustify_topalign
Enddec
Declare lbl_New_Constant_2 as LabelV2
Level 249656
#Visible True
#Lock False
init value := "Full Scale Volts"
init parent := p_cal_screen
init xpos := 30
init ypos := 490
init width := 200
init height := 17
init borderstyle := bdr_none
init transparent := true

init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Open_Valves_On_OP as LabelV2
Level 249952
#Visible True
#Lock False
init value := "Open Valves at 110% P range"
init parent := limits_screen
init xpos := 31
init ypos := 447
init width := 420
init height := 60

init xjustify := hjustify_leftalign
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_centeralign
Enddec
Declare lbl_P_Act as LabelV2
Level 249487
#Visible True
#Lock False
init value := "10000"
init parent := pressure_mode_screen
init xpos := 240
init ypos := 127
init width := 136
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Act_1 as LabelV2
Level 249411
#Visible True
#Lock False
init value := "2500"
init parent := profile_screen
init xpos := 250
init ypos := 100
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Act_2 as LabelV2
Level 249568
#Visible True
#Lock False
init value := "10000"
init parent := flow_mode_screen
init xpos := 244
init ypos := 128
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255


init blinkperiod := 0
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_centeralign
Enddec
Declare lbl_P_Act_3 as LabelV2
Level 249371
#Visible True
#Lock False
init value := "10000"
init parent := remote_display
init xpos := 244
init ypos := 128
init width := 120
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255


init blinkperiod := 0
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init xjustify := hjustify_centeralign
Enddec
Declare lbl_P_Act_A as LabelV2
Level 249530
#Visible True
#Lock False
init value := ""
init parent := pressure_mode_screen
init xpos := 0
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_A_1 as LabelV2
Level 249570
#Visible True
#Lock False
init value := ""
init parent := flow_mode_screen
init xpos := 0
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_A_2 as LabelV2
Level 249412
#Visible True
#Lock False
init value := "2501"
init parent := profile_screen
init xpos := 0
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_A_3 as LabelV2
Level 249369
#Visible True
#Lock False
init value := ""
init parent := remote_display
init xpos := 0
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_B as LabelV2
Level 249531
#Visible True
#Lock False
init value := ""
init parent := pressure_mode_screen
init xpos := 430
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_B_1 as LabelV2
Level 249571
#Visible True
#Lock False
init value := ""
init parent := flow_mode_screen
init xpos := 430
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_B_2 as LabelV2
Level 249413
#Visible True
#Lock False
init value := "2500"
init parent := profile_screen
init xpos := 430
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Act_B_3 as LabelV2
Level 249368
#Visible True
#Lock False
init value := ""
init parent := remote_display
init xpos := 430
init ypos := 65
init width := 50
init height := 15
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb12_bdf
Enddec
Declare lbl_P_Cal_msg as LabelV2
Level 249635
#Visible True
#Lock False
init value := "Open transducer valve to atmosphere and press SET ZERO.  Close valve and increase pressure.  Enter actual pressure value.  CALCULATE, then ACCEPT."
init parent := p_cal_screen
init xpos := 10
init ypos := 640
init width := 460
init height := 90
init font := helvb18_bdf
init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init ptsize := 12

init fgcolor := clr_buttonforeground
Enddec
Declare lbl_P_Cur_A as LabelV2
Level 249857
#Visible True
#Lock False
init value := "10000"
init parent := power_up_screen
init xpos := 275
init ypos := 95
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Cur_A_1 as LabelV2
Level 249901
#Visible True
#Lock False
init value := "10000"
init parent := manual_control_screen
init xpos := 116
init ypos := 115
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Cur_B as LabelV2
Level 249864
#Visible True
#Lock False
init value := "10000"
init parent := power_up_screen
init xpos := 275
init ypos := 275
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Cur_B_1 as LabelV2
Level 249900
#Visible True
#Lock False
init value := "10000"
init parent := manual_control_screen
init xpos := 333
init ypos := 115
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_P_Range as LabelV2
Level 249610
#Visible True
#Lock False
init value := "10,000"
init parent := config_screen
init xpos := 180
init ypos := 58
init width := 75
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Pmax_Bgnd as LabelV2
Level 249602
#Visible True
#Lock False
init value := "Pressure Limit (psi)"
init parent := config_screen
init xpos := 15
init ypos := 100
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Press_Range as LabelV2
Level 249636
#Visible True
#Lock False
init value := "10000"
init parent := p_cal_screen
init xpos := 340
init ypos := 200
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := clr_screenbackground
init ptsize := 12
init font := helvb18_bdf
Enddec
Declare lbl_Pressure_Msg as LabelV2
Level 249488
#Visible True
#Lock False
init value := "Enter Target Pressure and Ramp Rate to start pressure control"
init parent := pressure_mode_screen
init xpos := 50
init ypos := 620
init width := 380
init height := 50
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Pressure_Warning as LabelV2
Level 249782
#Visible False
#Lock False
init value := "PRESSURE RANGE EXCEEDED"
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 64
init enabled := false
init bgcolor := clr_messagebackground
init fgcolor := 225

init blinkperiod := 2000
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Profile_Msg as LabelV2
Level 249416
#Visible True
#Lock False
init value := "Currently executing segment 4"
init parent := profile_screen
init xpos := 50
init ypos := 620
init width := 380
init height := 50
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Profile_Segment_1 as LabelV2
Level 249392
#Visible True
#Lock False
init value := "1"
init parent := profile_screen
init xpos := 36
init ypos := 313
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Profile_Segment_2 as LabelV2
Level 249393
#Visible True
#Lock False
init value := "2"
init parent := profile_screen
init xpos := 36
init ypos := 361
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Profile_Segment_3 as LabelV2
Level 249394
#Visible True
#Lock False
init value := "3"
init parent := profile_screen
init xpos := 36
init ypos := 409
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Profile_Segment_4 as LabelV2
Level 249395
#Visible True
#Lock False
init value := "4"
init parent := profile_screen
init xpos := 36
init ypos := 459
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_buttonbackgroundalt

init fgcolor := clr_buttonforegroundalt
Enddec
Declare lbl_Profile_Segment_5 as LabelV2
Level 249396
#Visible True
#Lock False
init value := "5"
init parent := profile_screen
init xpos := 36
init ypos := 509
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_Profile_Segment_6 as LabelV2
Level 249397
#Visible True
#Lock False
init value := "6"
init parent := profile_screen
init xpos := 36
init ypos := 559
init width := 404
init height := 45

init xjustify := hjustify_leftalign
init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
Enddec
Declare lbl_psi_indicated as LabelV2
Level 249637
#Visible True
#Lock False
init value := "9999"
init parent := p_cal_screen
init xpos := 75
init ypos := 480
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := clr_screenbackground
init ptsize := 12
init font := helvb18_bdf
Enddec
Declare lbl_PUTime as LabelV2
Level 249874
#Visible True
#Lock False
init value := "12:32 01-10-13"
init parent := power_up_screen
init xpos := 261
init ypos := 475
init width := 150
init height := 36
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := clr_screenbackground

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_RampStatus as TranslucentLabelV2
Level 249528
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 55
init ypos := 570
init width := 365
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Waiting for Operator to Enter Ramp Param"

init fgcolor := 192
Enddec
Declare lbl_Rate_Seg_1 as LabelV2
Level 249436
#Visible True
#Lock False
init value := "ml/min"
init parent := profile_screen
init xpos := 290
init ypos := 317
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rate_Seg_2 as LabelV2
Level 249437
#Visible True
#Lock False
init value := "ml/min"
init parent := profile_screen
init xpos := 290
init ypos := 365
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rate_Seg_3 as LabelV2
Level 249438
#Visible True
#Lock False
init value := "psi/sec"
init parent := profile_screen
init xpos := 290
init ypos := 413
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rate_Seg_4 as LabelV2
Level 249439
#Visible True
#Lock False
init value := "psi"
init parent := profile_screen
init xpos := 290
init ypos := 463
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rate_Seg_5 as LabelV2
Level 249440
#Visible True
#Lock False
init value := ""
init parent := profile_screen
init xpos := 290
init ypos := 513
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rate_Seg_6 as LabelV2
Level 249441
#Visible True
#Lock False
init value := ""
init parent := profile_screen
init xpos := 290
init ypos := 563
init width := 35
init height := 38
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Receive_Mode_Warning as LabelV2
Level 249829
#Visible True
#Lock False
init value := "You can not enter Constant Flow Rate Mode while in Receive Mode"
init parent := title_screen
init xpos := 10
init ypos := 285
init width := 275
init height := 75
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_ReflRate_Bgnd as LabelV2
Level 249613
#Visible True
#Lock False
init value := "Min Fill Rate - Flow Control (ml/min)"
init parent := config_screen
init xpos := 15
init ypos := 200
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Remote_Display as LabelV2
Level 249374
#Visible True
#Lock False
init value := "REMOTE DISPLAY"
init parent := remote_display
init xpos := 0
init ypos := 0
init width := 480
init height := 64
init fgcolor := 255
init bgcolor := clr_banner

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 26
init transparent := true
Enddec
Declare lbl_Remote_Instructions as LabelV2
Level 249372
#Visible True
#Lock False
init value := "Pump is being controlled remotely"
init parent := remote_display
init xpos := 50
init ypos := 610
init width := 380
init height := 50
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Rev as LabelV2
Level 249992
#Visible True
#Lock False
init value := "2.0986"
init parent := error_popup_screen
init xpos := 15
init ypos := 247
init width := 80
init height := 26
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 255
init font := helvb18_bdf

init blinkperiod := 0
Enddec
Declare lbl_Rev1 as LabelV2
Level 249993
#Visible True
#Lock False
init value := "Rev"
init parent := error_popup_screen
init xpos := 26
init ypos := 217
init width := 58
init height := 26
init borderstyle := bdr_none

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 12
init transparent := true
Enddec
Declare lbl_Rev_Amin_Bgnd as LabelV2
Level 249605
#Visible True
#Lock False
init value := "Reverse Min (ml)"
init parent := config_screen
init xpos := 15
init ypos := 572
init width := 450
init height := 45
init font := helvb18_bdf
init xjustify := hjustify_leftalign

init ptsize := 12
init bgcolor := clr_labelbackground
Enddec
Declare lbl_Rod_Dia as LabelV2
Level 249609
#Visible True
#Lock False
init value := "12.70"
init parent := config_screen
init xpos := 400
init ypos := 58
init width := 60
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Rod_Dia_B as LabelV2
Level 249664
#Visible True
#Lock False
init value := "00.00"
init parent := vol_cal_screen
init xpos := 297
init ypos := 333
init width := 128
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvr18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Rod_Dia_Bgnd as LabelV2
Level 249598
#Visible True
#Lock False
init value := "Rod dia (mm)"
init parent := config_screen
init xpos := 268
init ypos := 50
init width := 202
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Setup_Msg as LabelV2
Level 249585
#Visible True
#Lock False
init value := ""
init parent := initialize_screen
init xpos := 80
init ypos := 120
init width := 352
init height := 128

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Start_VolA_Bgnd as LabelV2
Level 249606
#Visible True
#Lock False
init value := "Start Vol Pump Mode (ml)"
init parent := config_screen
init xpos := 15
init ypos := 428
init width := 380
init height := 45
init font := helvb18_bdf
init xjustify := hjustify_leftalign

init ptsize := 12
Enddec
Declare lbl_Start_VolA_Bgnd_1 as LabelV2
Level 249607
#Visible True
#Lock False
init value := "Start Vol Receive Mode (ml)"
init parent := config_screen
init xpos := 15
init ypos := 476
init width := 380
init height := 45
init font := helvb18_bdf
init xjustify := hjustify_leftalign

init ptsize := 12
Enddec
Declare lbl_Sys_Config_Instructions as LabelV2
Level 249608
#Visible True
#Lock False
init value := "Positions are indicated in terms of volume (ml) in the cylinder. Forward is towards full direction. Reverse is towards empty direction."
init parent := config_screen
init xpos := 30
init ypos := 670
init width := 420
init height := 70
init bgcolor := clr_messagebackground
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Sys_Maintenance_Msg as LabelV2
Level 249838
#Visible True
#Lock False
init value := "Press RESET when preventive maintenance is performed.  Boxes above indicate the date RESET was last pressed and the number of hours the pump has run since the last RESET"
init parent := system_maintenance_screen
init xpos := 20
init ypos := 500
init width := 440
init height := 112

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb18_bdf

init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Sys_Restart_Msg as LabelV2
Level 249846
#Visible True
#Lock False
init value := "If power was lost accidentally, this screen shows the last position recorded, and the change from the previously recorded position.  If values appear reasonable, and the changes from the previous values are small, then operator may choose to ACCEPT CURRENT VALUES, and continue without re-initializing the pump. Values are saved at 5 min intervals. If the change from previous exceeds .25 ml, it is recommended that the VPA be re-intialized.  INTIALIZE starts a standard intialization sequence. RESTART will initialize, keeping inlet valves open,  then Cycle to Start position."
init parent := power_up_screen
init xpos := 30
init ypos := 525
init width := 420
init height := 184

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb14_bdf

init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Sys_Setup_Msg as LabelV2
Level 249465
#Visible True
#Lock False
init value := "Calibration factors and Alarm Limits have been reset to factory settings.  VPA should be initialized again for settings to be correct."
init parent := sys_setup_screen
init xpos := 20
init ypos := 675
init width := 440
init height := 90

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvb18_bdf

init enabled := false
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Tot_Vol_A as LabelV2
Level 249611
#Visible True
#Lock False
init value := ""
init parent := config_screen
init xpos := 251
init ypos := 384
init width := 96
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Tot_Vol_B as LabelV2
Level 249612
#Visible True
#Lock False
init value := ""
init parent := config_screen
init xpos := 360
init ypos := 384
init width := 96
init height := 30
init bgcolor := 0
init borderstyle := bdr_bumpborder
init fgcolor := 255
init font := helvb18_bdf

init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Tot_VolA_Bgnd as LabelV2
Level 249601
#Visible True
#Lock False
init value := "Cylinder Volume (ml)"
init parent := config_screen
init xpos := 15
init ypos := 376
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Valve_Options_bk as LabelV2
Level 249807
#Visible True
#Lock False
init value := "VPA VALVE CONFIG DURING INIT & CYCLE"
init parent := valve_screen
init xpos := 30
init ypos := 550
init width := 420
init height := 150

init xjustify := hjustify_leftalign
init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground

init yjustify := vjustify_topalign
Enddec
Declare lbl_Vol_Cal_msg_B as LabelV2
Level 249663
#Visible True
#Lock False
init value := "Enter calibration setup parameters. Press FILL TO START VOL to move cylinder to start position. Press START FLOW to flow the volume indicated.  Measure and enter the volume produced."
init parent := vol_cal_screen
init xpos := 5
init ypos := 640
init width := 470
init height := 90

init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
init bgcolor := clr_messagebackground

init font := helvr18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_A as LabelV2
Level 249856
#Visible True
#Lock False
init value := "1000.00"
init parent := power_up_screen
init xpos := 275
init ypos := 145
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_A_1 as LabelV2
Level 249902
#Visible True
#Lock False
init value := "1000.00"
init parent := manual_control_screen
init xpos := 118
init ypos := 168
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_B as LabelV2
Level 249865
#Visible True
#Lock False
init value := "1000.00"
init parent := power_up_screen
init xpos := 275
init ypos := 325
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_B_1 as LabelV2
Level 249903
#Visible True
#Lock False
init value := "1000.00"
init parent := manual_control_screen
init xpos := 335
init ypos := 168
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_Change_A as LabelV2
Level 249868
#Visible True
#Lock False
init value := "1000.00"
init parent := power_up_screen
init xpos := 275
init ypos := 195
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Cur_Change_B as LabelV2
Level 249871
#Visible True
#Lock False
init value := "1000.00"
init parent := power_up_screen
init xpos := 275
init ypos := 375
init width := 136
init height := 40
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Tot as LabelV2
Level 249489
#Visible True
#Lock False
init value := "1000.00"
init parent := pressure_mode_screen
init xpos := 240
init ypos := 242
init width := 136
init height := 48
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_Vol_Tot_1 as LabelV2
Level 249414
#Visible True
#Lock False
init value := "1437.24"
init parent := profile_screen
init xpos := 250
init ypos := 190
init width := 110
init height := 35
init borderstyle := bdr_bumpborder
init bgcolor := 0
init fgcolor := 31

init font := helvb24_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_VolPCyl_Bgnd as LabelV2
Level 249599
#Visible True
#Lock False
init value := "Max Vol/Stroke - Flow Mode (ml)"
init parent := config_screen
init xpos := 15
init ypos := 250
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_VolPCyl_Bgnd_1 as LabelV2
Level 249626
#Visible True
#Lock False
init value := "Initialize / Cycle Rate (ml/min)"
init parent := config_screen
init xpos := 15
init ypos := 298
init width := 450
init height := 45

init xjustify := hjustify_leftalign

init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
Enddec
Declare lbl_volts_per_psi as LabelV2
Level 249638
#Visible True
#Lock False
init value := "00.00"
init parent := p_cal_screen
init xpos := 340
init ypos := 250
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := clr_screenbackground
init ptsize := 12
init font := helvb18_bdf
Enddec
Declare lbl_volts_per_psi_new as LabelV2
Level 249654
#Visible True
#Lock False
init value := "00.00"
init parent := p_cal_screen
init xpos := 220
init ypos := 250
init width := 100
init height := 35
init bgcolor := clr_buttonforeground
init borderstyle := bdr_bumpborder
init fgcolor := 61
init ptsize := 12
init font := helvb18_bdf

init blinkperiod := 1000
init enabled := false
Enddec
Declare lbl_Warnings_Enabled as LabelV2
Level 249950
#Visible True
#Lock False
init value := "Warning Limits"
init parent := limits_screen
init xpos := 31
init ypos := 375
init width := 420
init height := 60

init xjustify := hjustify_leftalign
init font := helvb18_bdf
init xinset := 1
init yinset := 0
init ptsize := 20
init bgcolor := clr_softkeybarbackground
init yjustify := vjustify_centeralign
Enddec
Declare lbl_Zero_Msg as LabelV2
Level 249974
#Visible True
#Lock False
init value := "One of the transducers currently exceeds 30 psi.  Are you sure you want to zero the pressure transducers?"
init parent := zero_pressure_popup_screen
init xpos := 10
init ypos := 50
init width := 280
init height := 101
init font := helvb18_bdf
init borderstyle := bdr_bumpborder
init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign

init bgcolor := clr_messagebackground
Enddec
Declare Limits_screen as ScreenV2
Level 249956
#Visible False
#Lock Me
init width := 480
init height := 800
init parent := default
init enabled := false
Enddec
Declare Manual_Control_Screen as ScreenV2
Level 249930
#Visible False
#Lock False
init width := 480
init height := 800
init parent := default

init enabled := false
init xpos := -1
init ypos := 0
Enddec
Declare P_Cal_screen as ScreenV2
Level 249658
#Visible False
#Lock False
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := False
Enddec
Declare PopupKP as NumberKeypadV2
Level 249821
#Visible False
#Lock False
init parent := default
init xpos := 40
init ypos := 60
init width := 400
init height := 333
init enabled := false

func EnterPressed()
    dim temp as float
    dim tmpFSvolts as float
    dim tmpvppsi as float
    dim tmpPTar as float

    enabled = false
    currentEB.Value = strval
    currentEB.bgcolor=clr_screenbackground
    If currentEB <> eb_flowrlim then
        If strval <> currentvalue then
            ValueChanged=true
        else
            ValueChanged=false
        endif
    else
        ValueChanged=false
    endif
    If Flow_Mode_Screen.enabled then
        check error
             val(mlpermin,eb_FlowR.Value)
        on error
            _ClearException()
        enderr

        If mlpermin<1 then
            eb_FlowR.DecimalPlaces=3

        else
            eb_FlowR.DecimalPlaces=2

        endif

        If eb_Tar_Vol.Value=="INF"  then
            mlmax=2000000000
            Tar_Vol_Reached=False

        else

            check error
                val(temp,eb_Tar_Vol.Value)
            on error
                _ClearException()
            enderr
            if temp<=0 then
                mlmax=2000000000
                Tar_Vol_Reached=False
                eb_Tar_Vol.Value="INF"
            elseIf temp<= MLTot then
                eb_Tar_Vol.Value=currentvalue
                valueChanged=false
                eb_Tar_Vol.Value="Invalid"
                lbl_Flow_Instructions.value="Enter a volume greater than the current volume"
                Warning_Sound()
            else
                mlmax=temp
                Tar_Vol_Reached=False
            endif
        endif
        Set_Flow_Buttons()
    endif

    If Pressure_mode_screen.enabled==true then
'       if CurrentEB==eb_target_press then
'            if value > PMax then
'                lbl_RampStatus.Value="Target Pressure must be less than PMax Limit"
'                value=.99*PMax
'                eb_Target_Press.value= _formatfloat(value,6,2,_FLOAT_NORMAL)
'                Warning_Sound()
'                return
'            endif
'        endif
'code now handled in Pressure Target text box
        If eb_PressR.value <>"0" then
                If psi_per_sec then
                    check error
                        val(Prate,eb_PressR.Value)
                    on error
                        _ClearException()
                    enderr
                else
                    check error
                        val(Pratemin,eb_PressR.Value)
                    on error
                        _ClearException()
                    enderr
                    Prate=Pratemin/60
                endif
                check error
                    val(FlowRLim,eb_flowrlim.Value)
                on error
                    _ClearException()
                enderr

            If eb_Target_Press.Value <>"0" then

                check error
                    val(Ptarget,eb_Target_Press.Value)
                on error
                    _ClearException()
                enderr
                If ValueChanged then
                    RampComplete=false
                endif
            else
                lbl_RampStatus.Value="Enter Target Pressure"
            endif
        else
            lbl_RampStatus.Value="Enter Ramp Rate"
        endif
        Set_Press_Buttons()
    endif
    If Vol_Cal_screen.enabled then
        If eb_Cal_Start.value <>"0" or eb_Cal_Start.value =="." then
            but_Fill_To_Start.enabled=true
            val(CalStartML,eb_Cal_Start.Value)
            MaxCalFlow=CalStartML
            eb_Flow_Vol.max=MaxCalFlow
        else
            but_Fill_To_Start.enabled=false
            CalStartML=0
        endif

        If eb_Flow_Vol.value <>"0" or eb_Flow_Vol.value =="." then
            val(temp,eb_Flow_Vol.Value)
            If temp > MaxCalFlow then
                eb_Flow_Vol.Value = str(MaxCalFlow)
            else
                CalFlowML=temp
                NewML=CalStartML-CalFlowML
            endif
            If InStartPos then
                but_Start_Flow_Cal.enabled=true
            endif
        else
            but_Start_Flow_Cal.enabled=false
        endif
        if CurrentEB==eb_ml_measured then
            If eb_ml_measured.value <>"0" or eb_ml_measured.value =="." then
                but_Calculate_volume.enabled=true
            else
                but_Calculate_volume.enabled=false
            endif
        endif
        If CurrentEB==eb_cal_start then
            But_Start_Flow_Cal.enabled=false
        endif

    endif
    If P_Cal_screen.enabled then
        If CalMode==false then
            tmpFSvolts=value
            If tmpFSvolts==0 then
                warning_sound()
                lbl_p_cal_msg.value="Enter non-zero value for Full Scale Volts"
                return
            endif
            tmpvppsi=tmpFSvolts/Prange
            but_Zero.enabled=false
            but_Accept_Pres_Calc.enabled=true
            lbl_p_cal_msg.value="Press Accept to send new value"
            lbl_volts_per_psi_new.value=_formatfloat(tmpvppsi,6,4,_FLOAT_NORMAL)
            lbl_FS_volts_new.value=_formatfloat(tmpFSvolts,6,4,_FLOAT_NORMAL)
            lbl_FS_volts_new.enabled=true
            lbl_volts_per_psi_new.enabled=true
        Else
            lbl_p_cal_msg.value="Press CALCULATE to see volts/psi for the pressure entered."
            but_Calculate_Constant.enabled=true
            but_Zero.enabled=false
        endif
    endif
    If Manual_Control_Screen.enabled then
        If currentEB == eb_FlowR_A then
            check error
                val(FlowRA,eb_FlowR_A.Value)
            on error
                _ClearException()
            enderr
        endif
        If currentEB == eb_FlowR_B then
            check error
                val(FlowRB,eb_FlowR_B.Value)
            on error
                _ClearException()
            enderr
        endif
        If currentEB == eb_RefillR_A then
            check error
                val(RefillRA,eb_RefillR_A.Value)
            on error
                _ClearException()
            enderr
            send_GMCcommand("RefillRA=" + str(RefillRA))
        endif
        If currentEB == eb_RefillR_B then
            check error
                val(RefillRB,eb_RefillR_B.Value)
            on error
                _ClearException()
            enderr
            send_GMCcommand("RefillRB=" + str(RefillRB))
        endif
        If currentEB == eb_tar_vol_a then
            check error
                val(FloVolA,eb_tar_vol_a.Value)
            on error
                _ClearException()
            enderr
        endif
        If currentEB == eb_tar_vol_b then
            check error
                val(FloVolB,eb_tar_vol_b.Value)
            on error
                _ClearException()
            enderr
        endif
        If FlowRA <> 0 and FloVolA <> 0 then
            ReadytoFlowA=true
        else
            ReadytoFlowA=false
        endif
        If FlowRB <> 0 and FloVolB <> 0 then
            ReadytoFlowB=true
        else
            ReadytoFlowB=false
        endif
        Set_Manual_Flow_Buttons()
    endif

endfunc

func CancelPressed()
    enabled = false
    currentEB.bgcolor=clr_buttonbackground
    currentEB.Value=PrevValue
    valueChanged=false
endfunc

init popupstyle := _nkp_stdpopup
init font := helvb24_bdf
init ptsize := 20

func ValueChanged()

endfunc
Enddec
Declare Power_Up_Screen as ScreenV2
Level 249878
#Visible False
#Lock Me
init width := 480
init height := 800
init parent := default
init enabled := false
Enddec
Declare Pressure_mode_screen as ScreenV2
Level 249545
#Visible False
#Lock False
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := False
init bgcolor := 255
Enddec
Declare Profile_Screen as ScreenV2
Level 249462
#Visible False
#Lock False
init width := 480
init height := 800
init enabled := false
Enddec
Declare pv_Limits as PersistentVariablesV2
Level 249361
#Visible True
#Lock False
init savelist := "default.FlowRLim;default.FlowRLimWarn;default.PMaxWarn;default.PMax;default.ErrorDisplayDisabled;default.Open_Valves_at_Over_Pressure;default.flow_limit_disabled;default.psi_per_sec;"
init filename := "LimPersist.dat"
Enddec
Declare pv_Maintenance as PersistentVariablesV2
Level 249359
#Visible True
#Lock Me
init savelist := "lbl_Maint_hrs.value;lbl_Date_of_Maint.value;default.MaintHours;"
init filename := "Maint_Persist.dat"
Enddec
Declare pv_powerup as PersistentVariablesV2
Level 249360
#Visible True
#Lock False
init savelist := "default.MLlastA;default.MLlastB;default.MLdeltaA;default.MLdeltaB;default.MLlasttot;default.timelast$;"
init filename := "MLPersist.dat"
Enddec
Declare rb_DHCP_Disabled as RadioButtonV2
Level 249972
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 142
init ypos := 325
init width := 142
init height := 40
init value := "Disabled"
init ptsize := 20
init font := helvb18_bdf
init ischecked := False
init checksize := 20
Enddec
Declare rb_DHCP_Enabled as RadioButtonV2
Level 249971
#Visible True
#Lock False
init parent := ip_address_screen
init xpos := 142
init ypos := 276
init width := 142
init height := 40
init value := "Enabled"
init ptsize := 20
init font := helvb18_bdf
init ischecked := true
init checksize := 20

func OnStateChange()
    If ischecked then
        DH=1
        eb_IP_1.enabled=false
        eb_IP_2.enabled=false
        eb_IP_3.enabled=false
        eb_IP_4.enabled=false
    else
        DH=0
        eb_IP_1.enabled=true
        eb_IP_2.enabled=true
        eb_IP_3.enabled=true
        eb_IP_4.enabled=true
        GMCcom_IA.executeCommand=true
    endif
endfunc
Enddec
Declare rb_InV_Closed as RadioButtonV2
Level 249811
#Visible True
#Lock False
init parent := valve_screen
init xpos := 350
init ypos := 650
init width := 72
init height := 36
init value := "CLSD"
init font := helvb14_bdf

init checksize := 15
init ischecked := true

func OnStateChange()
    but_Save_Valve_Config.enabled=true
    If IsChecked then
        InVopn=false
    endif
endfunc
init valueon := "OPEN"
Enddec
Declare rb_InV_Open as RadioButtonV2
Level 249810
#Visible True
#Lock False
init parent := valve_screen
init xpos := 263
init ypos := 650
init width := 72
init height := 36
init value := "CLSD"
init font := helvb14_bdf
init checksize := 15

func OnStateChange()
    but_Save_Valve_Config.enabled=true
    If IsChecked then
        InVopn=true
    endif
endfunc
init valueon := "OPEN"
Enddec
Declare rb_PumpMode as RadioButtonV2
Level 249624
#Visible True
#Lock False
init parent := config_screen
init xpos := 407
init ypos := 426
init width := 48
init height := 45
init value := ""
init ischecked := true
init checksize := 30
init yjustify := vjustify_centeralign
init xjustify := hjustify_centeralign
init style := _crb_circle
Enddec
Declare rb_Receive_Mode as RadioButtonV2
Level 249625
#Visible True
#Lock False
init parent := config_screen
init xpos := 407
init ypos := 476
init width := 48
init height := 45
init value := ""
init ischecked := false
init checksize := 30
init yjustify := vjustify_centeralign
init xjustify := hjustify_centeralign
init style := _crb_circle
Enddec
Declare Remote_Display as ScreenV2
Level 249388
#Visible False
#Lock False
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init enabled := false
Enddec
Declare ScreenSaver as ScreenSaverV2
Level 249362
#Visible False
#Lock False
init dimscreen_time := 0
init launchscreensaver_time := 0
init backlightoff_time := 0
init marqueefont := default_ttf
init marqueeptsize := 51
Enddec
Declare Sys_Setup_screen as ScreenV2
Level 249479
#Visible False
#Lock False
init parent := default
init xpos := -1
init ypos := -4
init width := 480
init height := 800
init enabled := False
init bgcolor := clr_buttonbackgroundalt

func screenEnabled()


endfunc
Enddec
Declare System_Maintenance_Screen as ScreenV2
Level 249844
#Visible False
#Lock False
init width := 480
init height := 800
init xpos := 0
init ypos := 0
init enabled := false
Enddec
Declare Title_Screen as ScreenV2
Level 249830
#Visible False
#Lock Me
init parent := default
init xpos := 0
init ypos := 0
init width := 480
init height := 800
init bgcolor := clr_screenbackground
init enabled := false
init transparent := false
Enddec
Declare tmr_Burn_New_Var as TimerV2
Level 249351
#Visible True
#Lock False
init timertype := _tt_oneshot
init enabled := false
init timeperiod := 20

func timeout()
    GMCCommand.command = "BV"
    GMCCommand.executeCommand = true
    tmr_Burn_New_Var.enabled=false
endfunc
Enddec
Declare tmr_Check_Connection as TimerV2
Level 249357
#Visible True
#Lock False
init timertype := _tt_periodic

func timeout()

    If GalilComm.IsConnectionPending()<>true then
        tmr_FirstPowerUp.enabled=true
        tmr_check_connection.enabled=false
        Get_Current_Config()
    endif
endfunc

init timeperiod := 1
init enabled := false
Enddec
Declare tmr_CheckML as TimerV2
Level 249352
#Visible True
#Lock False
init timeunits := _tt_minutes
init timeperiod := 5

func timeout()
    MLdeltaA=MLcurA-MLlastA
    MLdeltaB=MLcurB-MLlastB
    MLlastTot=MLtot
    MLlast(MLcurA,MLcurB) 'converts to MLlastA and MLlastB
    Date_and_Time(TimeLast$)
    pv_powerup.save()
endfunc

init enabled := false
Enddec
Declare tmr_Delay_Get_Config as TimerV2
Level 249353
#Visible True
#Lock False
func timeout()
    Get_Current_Config()
endfunc

init timeperiod := 1
init timertype := _tt_oneshot
init enabled := false
Enddec
Declare tmr_Delay_Init_Ramp as TimerV2
Level 249356
#Visible True
#Lock False
init timertype := _tt_oneshot
init enabled := false

func timeout()
    Init_Press_Ramp()
    Set_Press_Buttons()
    lbl_RampStatus.Value = "Ramping to Target Pressure"
endfunc

init parent := default
init timeperiod := 2
Enddec
Declare tmr_Delay_Start as TimerV2
Level 249347
#Visible True
#Lock False
init timertype := _tt_oneshot
init enabled := false

func timeout()
    if Flow_Mode_screen.enabled then
        but_Set_Mode_1.inactive=false
        but_limits.inactive=false
        but_zeroVol.inactive=false
        but_cycToStart.inactive=false
        but_updateFlow.inactive=false
        but_StartFlow.inactive=false
        but_QuitFlow.inactive=false
        But_OpenValves_2.inactive=false
    endif
    If Pressure_Mode_screen.enabled then
        but_Set_Mode.inactive=false
        but_limits_1.inactive=false
        but_Ramp.inactive=false
        but_cycToStart_1.inactive=false
        But_OpenValves.inactive=false
        but_Pcont.inactive=false
        but_QuitPressure.inactive=false
    endif
    If Profile_Screen.enabled then
        but_End_Profile_Def.inactive=false
        but_Profile.inactive=false
        but_QuitProfile.inactive=false
        but_limits_3.inactive=false
        but_cycToStart_2.inactive=false
        But_OpenValves_1.inactive=false
    endif
endfunc
Enddec
Declare tmr_Disabled as TimerV2
Level 249355
#Visible True
#Lock False
func timeout()
    Disabled = false
    tmr_Disabled.enabled=false
endfunc

init timeunits := _tt_minutes
init timeperiod := 5
init timertype := _tt_oneshot
init enabled := false
Enddec
Declare tmr_error_beep_delay as TimerV2
Level 249690
#Visible True
#Lock False
init parent := daq_objects
init timeperiod := 2
init timertype := _tt_oneshot
init enabled := false
Enddec
Declare tmr_Fact_Set as TimerV2
Level 249354
#Visible True
#Lock False
init enabled := false
init timertype := _tt_oneshot
init timeperiod := 15

func timeout()
    lbl_sys_setup_msg.enabled=false
endfunc
Enddec
Declare tmr_FirstPowerUp as TimerV2
Level 249358
#Visible True
#Lock False
init timeperiod := 5
init timertype := _tt_oneshot
init enabled := false

func timeout()
    GMCCom_First_PowerUP.executeCommand=true
    tmr_FirstPowerUp.enabled=false

endfunc
Enddec
Declare tmr_Hide_Error_Display as TimerV2
Level 249350
#Visible True
#Lock False
init enabled := false
init timertype := _tt_oneshot
init timeperiod := 15

func timeout()
    Error_Popup_Screen.enabled=true
endfunc
Enddec
Declare tmr_Initialize as TimerV2
Level 249693
#Visible True
#Lock False
init timeperiod := 1
init enabled := false


func timeout()
    lbl_Setup_Msg.value=""
    Get_Current_Config()
    Initialize_screen.enabled=false
    Init_Config_Screen()
endfunc


init parent := daq_objects
init timertype := _tt_oneshot
Enddec
Declare tmr_MLaccum as TimerV2
Level 249692
#Visible True
#Lock False
init parent := daq_objects
init timeperiod := 5
init enabled := false
init timertype := _tt_oneshot

func timeout()
    GMCCom_MLaccum.executeCommand=true
endfunc
Enddec
Declare tmr_Profile_Times as TimerV2
Level 249390
#Visible True
#Lock False
init parent := profile_screen
init enabled := false
init timeperiod := 5
init timertype := _tt_periodic
init timeunits := _tt_seconds

func timeout()
    Profile_Seconds=Profile_Seconds+5
    Segment_Seconds=Segment_Seconds+5
    lbl_lapsed_time_Profile.value=SecondsToDispString(Profile_Seconds)
    lbl_lapsed_time_Segment.value=SecondsToDispString(Segment_Seconds)

endfunc
Enddec
Declare tmr_Receive_Warning as TimerV2
Level 249346
#Visible True
#Lock False
init parent := default
init timeperiod := 15
init enabled := false
init timertype := _tt_oneshot

func timeout()
    lbl_Receive_Mode_Warning.enabled=false
endfunc
Enddec
Declare tmr_refill as TimerV2
Level 249348
#Visible True
#Lock False
init enabled := false
init timeperiod := 1

func timeout()
    If NOT Refilling then
        tmr_refill.enabled=false
        If not LastSegment or Profile_Stopped then
            lbl_Profile_Msg.value="Starting next segment."
            Start_Segment(Next_Segment)
        else
            lbl_Profile_Msg.value="Profile Complete"
            but_profile.enabled=false
            but_Profile.Value="START PROFILE"
        endif

    endif
endfunc
Enddec
Declare tmr_restart_delay as TimerV2
Level 249345
#Visible True
#Lock False
init parent := default
init timeperiod := 1
init timertype := _tt_oneshot
init enabled := false

func timeout()

    'send HX
    GMCcommand.command="ST;ZC0,0;HX"
    GMCcommand.executeCommand=true
    RestartRequired=false
    InitComplete=false
    CycleComplete=false
    'send XQ#AUTO
    GMCcommand.command="XQ#AUTO"
    GMCcommand.executeCommand=true


endfunc
Enddec
Declare tmr_Segment as TimerV2
Level 249389
#Visible True
#Lock False
init parent := profile_screen
init enabled := false
init timeperiod := default
init timertype := _tt_oneshot
init timeunits := _tt_seconds

func timeout()
    If Current_Segment<NumberofSegments then
        Profile_Transition(Current_Segment)
    else
        Exit_Segment(Current_Segment)
    endif

endfunc
Enddec
Declare tmr_update_but_delay as TimerV2
Level 249344
#Visible True
#Lock False
init parent := default
init timeperiod := 1
init timertype := _tt_oneshot
init enabled := false

func timeout()

    Set_Flow_Buttons()

endfunc
Enddec
Declare tmr_Wait_For_Refill as TimerV2
Level 249349
#Visible True
#Lock False
init timeperiod := 1
init enabled := false

func timeout()
    If NOT Refilling then
        tmr_Wait_For_Refill.enabled=false
        if exitingpscreen then
            but_Man_Control.enabled=true
            but_PressureMode.enabled=true
            but_FlowMode.enabled=true
            but_ProfileMode.enabled=true
            GMCPoll_PState_Status.enabled=false
            exitingpscreen=false
        else
            Set_Press_Buttons()
        endif
    endif


endfunc
Enddec
Declare tmrPowerUp as TimerV2
Level 249691
#Visible True
#Lock False
init parent := daq_objects
init enabled := false

func timeout()
    Check_PowerUp()
endfunc
Enddec
Declare TranslucentLabel_1 as TranslucentLabelV2
Level 249549
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 60
init ypos := 135
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Pressure"
Enddec
Declare TranslucentLabel_10 as TranslucentLabelV2
Level 249511
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 61
init ypos := 248
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Total Vol Pumped"
Enddec
Declare TranslucentLabel_11 as TranslucentLabelV2
Level 249510
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 62
init ypos := 192
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Flow Rate"
Enddec
Declare TranslucentLabel_12 as TranslucentLabelV2
Level 249517
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 59
init ypos := 469
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Pressure Ramp Rate"
Enddec
Declare TranslucentLabel_13 as TranslucentLabelV2
Level 249516
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 59
init ypos := 412
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Target Pressure"
Enddec
Declare TranslucentLabel_14 as TranslucentLabelV2
Level 249515
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 63
init ypos := 368
init width := 339
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Pressure Control Settings"
Enddec
Declare TranslucentLabel_15 as TranslucentLabelV2
Level 249792
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 300
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinder B Outlet"
Enddec
Declare TranslucentLabel_16 as TranslucentLabelV2
Level 249791
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 200
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinder A Inlet"
Enddec
Declare TranslucentLabel_17 as TranslucentLabelV2
Level 249790
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 100
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinder A Outlet"
Enddec
Declare TranslucentLabel_18 as TranslucentLabelV2
Level 249798
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 400
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinder B Inlet"
Enddec
Declare TranslucentLabel_19 as TranslucentLabelV2
Level 249836
#Visible True
#Lock False
init parent := system_maintenance_screen
init xpos := 40
init ypos := 100
init width := 250
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Date of last maintenance"
Enddec
Declare TranslucentLabel_2 as TranslucentLabelV2
Level 249550
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 61
init ypos := 248
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Total Vol Pumped"
Enddec
Declare TranslucentLabel_20 as TranslucentLabelV2
Level 249839
#Visible True
#Lock False
init parent := system_maintenance_screen
init xpos := 40
init ypos := 160
init width := 250
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Hours since last maintenance"
Enddec
Declare TranslucentLabel_21 as TranslucentLabelV2
Level 249518
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 59
init ypos := 525
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate Limit"
Enddec
Declare TranslucentLabel_22 as TranslucentLabelV2
Level 249854
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 145
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Last saved position"
Enddec
Declare TranslucentLabel_23 as TranslucentLabelV2
Level 249853
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 95
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Current pressure"
Enddec
Declare TranslucentLabel_24 as TranslucentLabelV2
Level 249867
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 195
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Change from prev save"
Enddec
Declare TranslucentLabel_25 as TranslucentLabelV2
Level 249866
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 325
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Last saved position"
Enddec
Declare TranslucentLabel_26 as TranslucentLabelV2
Level 249861
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 275
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Current pressure"
Enddec
Declare TranslucentLabel_27 as TranslucentLabelV2
Level 249870
#Visible True
#Lock False
init parent := power_up_screen
init xpos := 60
init ypos := 375
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Change from prev save"
Enddec
Declare TranslucentLabel_28 as TranslucentLabelV2
Level 249885
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 162
init width := 195
init height := 48
init opacity := 1
init font := helvr18_bdf
init value := "Position"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_29 as TranslucentLabelV2
Level 249884
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 108
init width := 195
init height := 48
init opacity := 1
init font := helvr18_bdf
init value := "Pressure"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_3 as TranslucentLabelV2
Level 249551
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 62
init ypos := 192
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Flow Rate"
Enddec
Declare TranslucentLabel_30 as TranslucentLabelV2
Level 249883
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 60
init ypos := 75
init width := 150
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Cylinder A"
Enddec
Declare TranslucentLabel_31 as TranslucentLabelV2
Level 249882
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 275
init width := 192
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_32 as TranslucentLabelV2
Level 249881
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 350
init width := 192
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Volume to Pump"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_33 as TranslucentLabelV2
Level 249890
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 252
init ypos := 162
init width := 195
init height := 48
init opacity := 1
init font := helvr18_bdf
init value := "Position"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_34 as TranslucentLabelV2
Level 249889
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 252
init ypos := 108
init width := 195
init height := 48
init opacity := 1
init font := helvr18_bdf
init value := "Pressure"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_35 as TranslucentLabelV2
Level 249888
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 277
init ypos := 75
init width := 150
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Cylinder B"
Enddec
Declare TranslucentLabel_36 as TranslucentLabelV2
Level 249887
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 253
init ypos := 275
init width := 195
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_37 as TranslucentLabelV2
Level 249886
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 255
init ypos := 350
init width := 195
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Volume to Pump"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_38 as TranslucentLabelV2
Level 249892
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 425
init width := 192
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Refill Rate"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_39 as TranslucentLabelV2
Level 249891
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 35
init ypos := 500
init width := 192
init height := 80
init opacity := 1
init font := helvr18_bdf
init value := "      Inlet         Outlet"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_4 as TranslucentLabelV2
Level 249552
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 75
init ypos := 437
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate"
Enddec
Declare TranslucentLabel_40 as TranslucentLabelV2
Level 249893
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 255
init ypos := 425
init width := 192
init height := 70
init opacity := 1
init font := helvr18_bdf
init value := "Refill Rate"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_41 as TranslucentLabelV2
Level 249894
#Visible True
#Lock False
init parent := manual_control_screen
init xpos := 255
init ypos := 500
init width := 192
init height := 80
init opacity := 1
init font := helvr18_bdf
init value := "      Inlet         Outlet"

init xjustify := hjustify_leftalign
init yjustify := vjustify_topalign
Enddec
Declare TranslucentLabel_42 as TranslucentLabelV2
Level 249935
#Visible True
#Lock False
init parent := limits_screen
init xpos := 61
init ypos := 147
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate (Shut Down)"
Enddec
Declare TranslucentLabel_43 as TranslucentLabelV2
Level 249934
#Visible True
#Lock False
init parent := limits_screen
init xpos := 60
init ypos := 97
init width := 200
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Flow Rate (Warning)"
Enddec
Declare TranslucentLabel_44 as TranslucentLabelV2
Level 249947
#Visible True
#Lock False
init parent := limits_screen
init xpos := 62
init ypos := 300
init width := 200
init height := 40
init opacity := 1
init font := helvr18_bdf
init value := "Pressure (Shut Down)"
Enddec
Declare TranslucentLabel_45 as TranslucentLabelV2
Level 249946
#Visible True
#Lock False
init parent := limits_screen
init xpos := 61
init ypos := 250
init width := 200
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Pressure (Warning)"
Enddec
Declare TranslucentLabel_46 as TranslucentLabelV2
Level 249403
#Visible True
#Lock False
init parent := profile_screen
init xpos := 70
init ypos := 192
init width := 170
init height := 30
init opacity := 1
init font := helvr18_bdf
init value := "Total Vol Pumped"
Enddec
Declare TranslucentLabel_47 as TranslucentLabelV2
Level 249404
#Visible True
#Lock False
init parent := profile_screen
init xpos := 70
init ypos := 147
init width := 170
init height := 30
init opacity := 1
init font := helvr18_bdf
init value := "Current Flow Rate"
Enddec
Declare TranslucentLabel_48 as TranslucentLabelV2
Level 249405
#Visible True
#Lock False
init parent := profile_screen
init xpos := 70
init ypos := 102
init width := 170
init height := 30
init opacity := 1
init font := helvr18_bdf
init value := "Current Pressure"
Enddec
Declare TranslucentLabel_49 as TranslucentLabelV2
Level 249415
#Visible True
#Lock False
init parent := profile_screen
init xpos := 150
init ypos := 75
init width := 180
init height := 25
init opacity := 0
init font := helvr18_bdf
init value := "Current Values"
Enddec
Declare TranslucentLabel_5 as TranslucentLabelV2
Level 249553
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 74
init ypos := 487
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Volume to Pump"
Enddec
Declare TranslucentLabel_50 as TranslucentLabelV2
Level 249448
#Visible True
#Lock False
init parent := profile_screen
init xpos := 70
init ypos := 237
init width := 120
init height := 30
init opacity := 1
init font := helvr18_bdf
init value := "Lapsed Time"

init xjustify := hjustify_leftalign
Enddec
Declare TranslucentLabel_51 as TranslucentLabelV2
Level 249453
#Visible True
#Lock False
init parent := profile_screen
init xpos := 80
init ypos := 285
init width := 100
init height := 25
init opacity := 0
init font := helvr18_bdf
init value := "Mode"
Enddec
Declare TranslucentLabel_52 as TranslucentLabelV2
Level 249454
#Visible True
#Lock False
init parent := profile_screen
init xpos := 195
init ypos := 285
init width := 100
init height := 25
init opacity := 0
init font := helvr18_bdf
init value := "Rate"
Enddec
Declare TranslucentLabel_53 as TranslucentLabelV2
Level 249455
#Visible True
#Lock False
init parent := profile_screen
init xpos := 320
init ypos := 285
init width := 100
init height := 25
init opacity := 0
init font := helvr18_bdf
init value := "Limit"
Enddec
Declare TranslucentLabel_54 as TranslucentLabelV2
Level 249808
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 600
init width := 200
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinders moving down"
Enddec
Declare TranslucentLabel_55 as TranslucentLabelV2
Level 249809
#Visible True
#Lock False
init parent := valve_screen
init xpos := 40
init ypos := 650
init width := 200
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Cylinders moving up"
Enddec
Declare TranslucentLabel_56 as TranslucentLabelV2
Level 249382
#Visible True
#Lock False
init parent := remote_display
init xpos := 153
init ypos := 85
init width := 172
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Current Values"
Enddec
Declare TranslucentLabel_57 as TranslucentLabelV2
Level 249383
#Visible True
#Lock False
init parent := remote_display
init xpos := 62
init ypos := 192
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Flow Rate"
Enddec
Declare TranslucentLabel_58 as TranslucentLabelV2
Level 249384
#Visible True
#Lock False
init parent := remote_display
init xpos := 61
init ypos := 248
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Total Vol Pumped"
Enddec
Declare TranslucentLabel_59 as TranslucentLabelV2
Level 249385
#Visible True
#Lock False
init parent := remote_display
init xpos := 60
init ypos := 135
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Pressure"
Enddec
Declare TranslucentLabel_6 as TranslucentLabelV2
Level 249554
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 167
init ypos := 377
init width := 172
init height := 36
init opacity := 0
init font := helvb24_bdf
init value := "Flow Settings"
Enddec
Declare TranslucentLabel_60 as TranslucentLabelV2
Level 249387
#Visible True
#Lock False
init parent := remote_display
init xpos := 61
init ypos := 304
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Control Mode"
Enddec
Declare TranslucentLabel_7 as TranslucentLabelV2
Level 249555
#Visible True
#Lock False
init parent := flow_mode_screen
init xpos := 153
init ypos := 85
init width := 172
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Current Values"
Enddec
Declare TranslucentLabel_8 as TranslucentLabelV2
Level 249513
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 60
init ypos := 135
init width := 172
init height := 36
init opacity := 1
init font := helvr18_bdf
init value := "Current Pressure"
Enddec
Declare TranslucentLabel_9 as TranslucentLabelV2
Level 249512
#Visible True
#Lock False
init parent := pressure_mode_screen
init xpos := 153
init ypos := 85
init width := 172
init height := 36
init opacity := 0
init font := helvr24_bdf
init value := "Current Values"
Enddec
Declare Valve_Screen as ScreenV2
Level 249817
#Visible False
#Lock False
init width := 480
init height := 800
init xpos := 0
init ypos := -4



init enabled := false
Enddec
Declare Vol_Cal_screen as ScreenV2
Level 249689
#Visible False
#Lock False
init parent := default
init xpos := 1
init ypos := -6
init width := 480
init height := 800
init enabled := False
Enddec
Declare Wait_For_Cycle_screen as ScreenV2
Level 249820
#Visible False
#Lock False
init parent := default
init xpos := 40
init ypos := 0
init width := 400
init height := 800
init enabled := False
Enddec
Declare Welcome_Screen as ScreenV2
Level 249334
#Visible True
#Lock False
init width := 480
init height := 800
Enddec
Declare Zero_Pressure_Popup_Screen as PopupScreenV2
Level 249977
#Visible False
#Lock Me
init xpos := 80
init ypos := 200
init width := 300
init height := 350
init cancelbutton := false
init enabled := false
init font := helvb18_bdf
init xjustify := hjustify_centeralign
init value := "ZERO P XDCRS"
Enddec
#Hide Library Basic Source ButtonV2
#Hide Library Extra Source ClockDisplayV2
#Hide Library Core Source coreCommunication
#Hide Library Core Source coreEditBox
#Hide Library Core Source coreLabel
#Hide Library DataProc Source DateTimeFunctions
#Hide Library DataProc Source DelimitedCommV2
#Hide Library Basic Source DropdownlistV2
#Hide Library Basic Source ExceptionDisplayV2
#Hide Library Basic Source gaugeV2
#Hide Library Galil_mcV2 Source GMCCommandDisplayV2
#Hide Library Basic Source imageV2
#Hide Library Basic Source keypadsettingsV2
#Hide Library Basic Source keypadtranslatorV2
#Hide Library Basic Source NumberKeypadV2
#Hide Library DataProc Source PerstistentVarsV2
#Hide Library Extra Source PopupScreen
#Hide Library Basic Source RadioButtonV2
#Hide Library Extra Source RectangleV2
#Hide Library Basic Source ScreenSaverV2
#Hide Library Basic Source ScreenV2
#Hide Library Basic Source timerV2
#Hide Library Extra Source TranslucentLabelV2
#SetFile -1 "*l%global%"
Includesys Library "basic.qlib"
Includesys Library "extra.qlib"
Includesys Library "DataProc.qlib"
Includesys Library "core.qlib.qhide"
Includesys Library "Galil_mcV2.qlib"
#hide Includesys reference to Library "ModbusV2.qlib"
#hide Includesys reference to Library "multilingual.qlib"
#hide Includesys reference to Library "NIObjsV2.qlib"
#hide Includesys reference to Library "OrbComm.qlib"
#hide Includesys reference to Library "progobjs.lib"
#hide Includesys reference to Library "common.lib"
#hide library basic source necessary
#SetFile -1 "*r%global%"
Include Bitmap "y:/customer files/vpa 2/operator terminal/software/g72/g72 to ron/banner_rev5.bmp" As Banner_Rev5
Include Bitmap "y:/customer files/vpa 2/operator terminal/software/g72/g72 to ron/qlarity.bmp" As default
Include Bitmap "y:/customer files/vpa 2/operator terminal/software/g72/g72 to ron/g-72_openingscreen.bmp" As G_72_OpeningScreen
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr08.bdf" As default
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr14.bdf" As Helv14
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvb10.bdf" As helvb10
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvb12.bdf" As helvb12
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvb14.bdf" As helvb14
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvb18.bdf" As helvb18
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvb24.bdf" As helvb24
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr12.bdf" As helvr12
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr14.bdf" As helvr14
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr18.bdf" As helvr18
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/helvr24.bdf" As helvr24
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/lutbs18.bdf" As lutbs18
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/5x7.bdf" As Small
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/veramono18.bdf" As veramono18
Include BDFfont "y:/customer files/vpa 2/operator terminal/software/g72/veramono32.bdf" As veramono32
Include TTfont "y:/customer files/vpa 2/operator terminal/software/g72/g72 to ron/vera.ttf" As default
Include TTfont "y:/customer files/vpa 2/operator terminal/software/g72/g72 to ron/verabd.ttf" As VeraBd
#config colormap "Clr_Banner := 3;Clr_ButtonBackground := 219;Clr_ButtonBackgroundAlt := 223;Clr_ButtonForeground := 0;Clr_ButtonForegroundAlt := 2;Clr_FillColor := 15;Clr_LabelBackground := 223;Clr_LabelForeground := 2;Clr_MessageBackground := 254;Clr_ScreenBackground := 255;Clr_ScreenForeground := 2;Clr_SoftkeybarBackground := 183;Clr_SoftkeybarButtonBg := 255;Clr_SoftkeybarButtonFg := 2;Red := 225;"
#hide #ifnot opt_colormap%
#hide #option opt_colormap%
#hide enum colormap% as Clr_Banner:=268, Clr_ButtonBackground:=258, Clr_ButtonBackgroundAlt:=260, Clr_ButtonForeground:=259, Clr_ButtonForegroundAlt:=261, Clr_FillColor:=264, Clr_LabelBackground:=256, Clr_LabelForeground:=257, Clr_MessageBackground:=269, Clr_ScreenBackground:=262, Clr_ScreenForeground:=263, Clr_SoftkeybarBackground:=265, Clr_SoftkeybarButtonBg:=266, Clr_SoftkeybarButtonFg:=267, Red:=270
#hide #hidden dim _colorMap[] as color
#hide init _colorMap := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 223, 2, 219, 0, 223, 2, 255, 2, 15, 183, 255, 2, 3, 254, 225]
#hide #endif
#config stylemap "Bdr_BumpBorder := 33895724;Bdr_ButtonBorder := 33890340;Bdr_CheckBoxBorder := 654643206;Bdr_CompositeObject := 33890340;Bdr_CompositeSunken := 33890342;Bdr_InnerButton := 637865988;Bdr_InnerLabel := 1862602758;Bdr_LabelBorder := 33886214;Bdr_None := 0;Bdr_Scrollbar := 1325731844;Bdr_SignalBars := 335905;Bdr_Softkey := 33760548;Bdr_TabBorder := 34222116;"
#hide #ifnot opt_stylemap%
#hide #option opt_stylemap%
#hide enum stylemap% as Bdr_BumpBorder:=4, Bdr_ButtonBorder:=0, Bdr_CheckBoxBorder:=6, Bdr_CompositeObject:=9, Bdr_CompositeSunken:=10, Bdr_InnerButton:=7, Bdr_InnerLabel:=8, Bdr_LabelBorder:=1, Bdr_None:=2, Bdr_Scrollbar:=3, Bdr_SignalBars:=12, Bdr_Softkey:=11, Bdr_TabBorder:=5
#hide #hidden dim _styleMap[] as integer
#hide init _styleMap := [33890340, 33886214, 0, 1325731844, 33895724, 34222116, 654643206, 637865988, 1862602758, 33890340, 33890342, 33760548, 335905]
#hide #endif
